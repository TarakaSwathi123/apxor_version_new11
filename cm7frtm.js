(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('apxor'), require('apxor-qe')) :
  typeof define === 'function' && define.amd ? define(['exports', 'apxor', 'apxor-qe'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global["apxor-rtm"] = {}, global.Apxor, global.CE));
})(this, (function (exports, Apxor, CE) { 'use strict';

  function _iterableToArrayLimit$1(r, l) {
    var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
    if (null != t) {
      var e,
        n,
        i,
        u,
        a = [],
        f = !0,
        o = !1;
      try {
        if (i = (t = t.call(r)).next, 0 === l) {
          if (Object(t) !== t) return;
          f = !1;
        } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);
      } catch (r) {
        o = !0, n = r;
      } finally {
        try {
          if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;
        } finally {
          if (o) throw n;
        }
      }
      return a;
    }
  }
  function ownKeys(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r && (o = o.filter(function (r) {
        return Object.getOwnPropertyDescriptor(e, r).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread2$1(e) {
    for (var r = 1; r < arguments.length; r++) {
      var t = null != arguments[r] ? arguments[r] : {};
      r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {
        _defineProperty$1(e, r, t[r]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {
        Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
      });
    }
    return e;
  }
  function _typeof$1(o) {
    "@babel/helpers - typeof";

    return _typeof$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
      return typeof o;
    } : function (o) {
      return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
    }, _typeof$1(o);
  }
  function _classCallCheck$1(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties$1(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
    }
  }
  function _createClass$1(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties$1(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties$1(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
      writable: false
    });
    return Constructor;
  }
  function _defineProperty$1(obj, key, value) {
    key = _toPropertyKey(key);
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _inherits$1(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    Object.defineProperty(subClass, "prototype", {
      writable: false
    });
    if (superClass) _setPrototypeOf$1(subClass, superClass);
  }
  function _getPrototypeOf$1(o) {
    _getPrototypeOf$1 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf$1(o);
  }
  function _setPrototypeOf$1(o, p) {
    _setPrototypeOf$1 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };
    return _setPrototypeOf$1(o, p);
  }
  function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }
  function _assertThisInitialized$1(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
  }
  function _possibleConstructorReturn$1(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    } else if (call !== void 0) {
      throw new TypeError("Derived constructors may only return object or undefined");
    }
    return _assertThisInitialized$1(self);
  }
  function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf$1(Derived),
        result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf$1(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn$1(this, result);
    };
  }
  function _slicedToArray$1(arr, i) {
    return _arrayWithHoles$1(arr) || _iterableToArrayLimit$1(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest$1();
  }
  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
  }
  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
  }
  function _arrayWithHoles$1(arr) {
    if (Array.isArray(arr)) return arr;
  }
  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
  }
  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }
  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
    return arr2;
  }
  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _nonIterableRest$1() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _toPrimitive(input, hint) {
    if (typeof input !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
      var res = prim.call(input, hint || "default");
      if (typeof res !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  function _toPropertyKey(arg) {
    var key = _toPrimitive(arg, "string");
    return typeof key === "symbol" ? key : String(key);
  }

  var VERSION = 139;
  var SERVER_URL = "https://server.apxor.com";

  // FIXME: Upgrade these URLs to v2/sync APIs and implement delta sync in Core plugin
  var RTA_VALIDATE_URL = SERVER_URL + "/v2/sync/<app_id>/configs/validate?platform=web&userId=<u_id>&actionType=rta&version=" + VERSION;
  var RTA_SYNC_URL = SERVER_URL + "/v2/sync/<app_id>/rta?platform=web&userId=<u_id>&version=" + VERSION;
  var SURVEY_VALIDATE_URL = SERVER_URL + "/v2/sync/<app_id>/configs/validate?platform=web&userId=<u_id>&actionType=survey&version=" + VERSION;
  var SURVEY_SYNC_URL = SERVER_URL + "/v2/sync/<app_id>/surveys?platform=web&userId=<u_id>&version=" + VERSION;
  var SURVEY_RESPONSE_URL = SERVER_URL + "/v2/api/survey-response?appId=<app_id>";
  var CONFIG_API_URL = SERVER_URL + "/v1/sse/art-config?appId=<app_id>&deviceId=<u_id>&isExperiment=true";
  var TEST_DEVICES_API_URL = SERVER_URL + "/v1/external/test-devices/validate?appId=<app_id>&deviceId=<u_id>";
  var ANSWER_TYPES = {
    SINGLE_CHOICE: 1,
    MULTI_CHOICE: 2,
    RATING: 3,
    SHORT_ANSWER: 4,
    YES_NO: 5
  };
  var APX_OVERLAY = "apx-oly";
  var APX_DIALOG_CONTENT = "apx-dlg-c";
  var APX_DIALOG_YES = "apx-dy";
  var APX_DIALOG_NO = "apx-dn";
  var INAPP_SHOWN = "inapp_shown";
  var INAPP_XICON_CLICKED = "InAppXIconClicked";
  var INAPP_BUTTON_CLICKED = function INAPP_BUTTON_CLICKED(buttonName) {
    return "InApp".concat(buttonName, "Clicked");
  };
  var WALK_THROUGH_CANCELLED = "walk_through_cancelled";
  var SURVEY_ON_DISMISS = "on_dismiss";
  var USER_ATTRIBUTES = "u";
  var SESSION_ATTRIBUTES = "s";
  var APPLICATION_VIEW_ID = "v";
  var EVENT_TYPE = "ev";
  var VARIABLE_TYPE = "t";
  var DEFAULT_VALUE = "def";
  var ATTRIBUTE_NAME = "n";
  var DYNAMIC_TEXT = "Script";
  var EVENT_PROPERTY_NAME = "prop";
  var IN_APP_TYPE = "IN_APP";
  var CENTER = "center";
  var EMOJI_ICONS_10 = ["&#128545;", "&#128544;", "&#128534;", "&#128547;", "&#128577;", "&#128528;", "&#128578;", "&#128512;", "&#128516;", "&#128515;", "&#128525;"];
  var EMOJI_ICONS_5 = ["&#128545;", "&#128577;", "&#128528;", "&#128515;", "&#128525;"];
  var RATING_COLORS_5 = ["#E5510A", "#EA731D", "#F8C94F", "#A3CF6A", "#7BB65C"];
  var RATING_COLORS_10 = ["#E5510A", "#EA731D", "#EA8F4D", "#EA8F4D", "#F1B052", "#F8C94F", "#F6DE4F", "#D7D55A", "#B7CF6A", "#A3CF6A", "#7BB65C"];
  var SCROLL_BEHAVIOUR = {
    SMOOTH: "smooth"
  };
  var CAROUSEL_TYPE = {
    NUMBER: "number",
    CAROUSEL: "carousel"
  };
  var BUTTON_CONTAINER_POSITION = {
    TOP: "top",
    CENTER: "center",
    BOTTOM: "bottom",
    SURVEY_BOTTOM: "survey_bottom"
  };
  var CLOSE_BUTTON_STYLE = {
    NORMAL: "normal",
    FILL: "filled"
  };
  var BACK_BUTTON_STYLE = {
    NORMAL: "normal",
    FILL: "fill"
  };
  var INAPP_POSITION = {
    TOP_LEFT: "top-left",
    TOP_RIGHT: "top-right",
    BOTTOM_LEFT: "bottom-left",
    BOTTOM_RIGHT: "bottom-right",
    TOP_CENTER: "top-center",
    BOTTOM_CENTER: "bottom-center",
    CENTER: "center"
  };
  var DIRECTION = {
    HORIZONTAL: "horizontal",
    VERTICAL: "vertical"
  };
  var EVENT_PREFIX = {
    INAPP: "InApp_",
    INLINE: "InLine_",
    SURVEY: "Survey_"
  };
  var VIDEOS_MODES = {
    PLAYER: "mini",
    PIP: "PIP"
  };
  var INAPP_TYPE = {
    VIDEO: "videos",
    MODAL: "modal"
  };
  var COLORS = {
    BLACK: "#000000",
    WHITE: "#ffffff"
  };
  var APX_PREVIEW_CAMPAIGN_NAME = "APX-PR3VI3W-CAMPGAIN";
  var APX_TERMINATION_ID = "apx_termination_ID";

  var isUndefined$1 = function isUndefined(term) {
    return typeof term === "undefined";
  };

  /**
   *
   * @param term
   * @returns {boolean}
   */
  var isNull = function isNull(term) {
    return term === null;
  };

  /**
   *
   * @param term
   * @returns {boolean}
   */
  var isDefined = function isDefined(term) {
    return typeof term !== "undefined" && !isNull(term);
  };
  var getElementByXPath = function getElementByXPath(path) {
    var index = path.indexOf("svg");
    if (index !== -1) {
      path = path.substring(0, index) + "svg:svg";
    }
    try {
      return document.evaluate(path, document, function (prefix) {
        if (prefix === "svg") {
          return "http://www.w3.org/2000/svg";
        } else {
          return null;
        }
      }, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue;
    } catch (e) {
      window.ApxorLogger.error("Error finding element in DOM:" + e);
    }
    return null;
  };
  var getShuffledArr = function getShuffledArr(arr) {
    return _toConsumableArray(arr).map(function (_, i, arrCopy) {
      var rand = i + Math.floor(Math.random() * (arrCopy.length - i));
      var _ref = [arrCopy[i], arrCopy[rand]];
      arrCopy[rand] = _ref[0];
      arrCopy[i] = _ref[1];
      return arrCopy[i];
    });
  };
  var getButtonPosition = function getButtonPosition(position) {
    switch (position) {
      case "center":
        return "center";
      case "left":
        return "flex-start";
      case "right":
        return "flex-end";
      case "ends":
        return "space-between";
      default:
        return "center";
    }
  };
  var getButtonsCSSFromConfig = function getButtonsCSSFromConfig() {
    var stepper = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var buttons_css = arguments.length > 1 ? arguments[1] : undefined;
    var button_direction = arguments.length > 2 ? arguments[2] : undefined;
    var button_alignment = arguments.length > 3 ? arguments[3] : undefined;
    var position = arguments.length > 4 ? arguments[4] : undefined;
    var buttons = "";
    var prev = 0;
    var totalSlots = 0;
    if (position === BUTTON_CONTAINER_POSITION.TOP) {
      totalSlots = 3;
    } else if (position === BUTTON_CONTAINER_POSITION.BOTTOM) {
      totalSlots = 5;
    } else if (position === BUTTON_CONTAINER_POSITION.SURVEY_BOTTOM) {
      totalSlots = 5;
    } else {
      totalSlots = 1;
    }
    var numbered = {};
    var numberedfont = {};
    if (stepper.enable_numbered) {
      var _numbered;
      numbered = stepper.numbered;
      numberedfont = (_numbered = numbered) === null || _numbered === void 0 ? void 0 : _numbered.font;
    }
    var justifyContent = "space-between";
    buttons_css.forEach(function (button_css, index) {
      var _ref2;
      var slot = button_css.slot,
        type = button_css.type,
        sub_type = button_css.sub_type,
        bg_color = button_css.bg_color,
        text_color = button_css.text_color,
        size = button_css.size,
        style = button_css.style,
        weight = button_css.weight,
        font_family = button_css.font_family,
        enable_border = button_css.enable_border,
        _button_css$border = button_css.border,
        stroke_width = _button_css$border.width,
        stroke_color = _button_css$border.color,
        radius = _button_css$border.radius,
        button_border_style = _button_css$border.style,
        enable_margin = button_css.enable_margin,
        _button_css$margin = button_css.margin,
        margin_bottom = _button_css$margin.bottom,
        margin_left = _button_css$margin.left,
        margin_right = _button_css$margin.right,
        margin_top = _button_css$margin.top,
        enable_padding = button_css.enable_padding,
        _button_css$padding = button_css.padding,
        padding_bottom = _button_css$padding.bottom,
        padding_left = _button_css$padding.left,
        padding_right = _button_css$padding.right,
        padding_top = _button_css$padding.top,
        _button_css$text_marg = button_css.text_margin,
        text_margin_bottom = _button_css$text_marg.bottom,
        text_margin_left = _button_css$text_marg.left,
        text_margin_right = _button_css$text_marg.right,
        text_margin_top = _button_css$text_marg.top,
        _button_css$text_padd = button_css.text_padding,
        text_padding_bottom = _button_css$text_padd.bottom,
        text_padding_left = _button_css$text_padd.left,
        text_padding_right = _button_css$text_padd.right,
        text_padding_top = _button_css$text_padd.top,
        enable_gradient = button_css.enable_gradient,
        _button_css$gradient = button_css.gradient,
        gradient = _button_css$gradient === void 0 ? {} : _button_css$gradient,
        custom_font = button_css.custom_font;
      var gradient_direction, gradient_c1, gradient_c2;
      if (enable_gradient) {
        gradient_direction = gradient.direction || "to right";
        gradient_c1 = gradient.colors[0] || COLORS.BLACK;
        gradient_c2 = gradient.colors[1] || COLORS.WHITE;
      }
      var marginLeft = false;
      var marginRight = false;
      if ((_ref2 = button_direction !== "vertical") !== null && _ref2 !== void 0 ? _ref2 : position !== BUTTON_CONTAINER_POSITION.BOTTOM) {
        var _buttons_css;
        var next = ((_buttons_css = buttons_css[index + 1]) === null || _buttons_css === void 0 ? void 0 : _buttons_css.slot) || totalSlots + 1;
        if (position !== BUTTON_CONTAINER_POSITION.TOP && buttons_css.length === 2 && (slot === 2 && next === 3 || slot === 4 && prev === 3 || slot === 3 && (prev === 2 || next === 4))) {
          // If there are only two buttons with one center button(slot 3) then align both the buttons to center.
          // It means buttons 2-3 or 3-4 will always align to the center
          justifyContent = "center";
        } else {
          if (slot - prev > 1) {
            marginLeft = true;
          }
          if (next - slot > 1) {
            marginRight = true;
          }
          if (slot === 3 && position !== BUTTON_CONTAINER_POSITION.TOP) {
            if (buttons_css.length != 2 || prev !== 1) {
              marginLeft = true;
            } else {
              marginLeft = false;
            }
            if (buttons_css.length != 2 || next !== 5) {
              marginRight = true;
            } else {
              marginRight = false;
            }
          }
          if (slot === 2 && position === BUTTON_CONTAINER_POSITION.TOP) {
            marginLeft = true;
            marginRight = true;
          }
        }
        prev = slot;
      }
      if (position === BUTTON_CONTAINER_POSITION.CENTER) {
        marginLeft = true;
        marginRight = true;
      }
      var borderStyles = "";
      if (enable_border) {
        borderStyles = "border:".concat(stroke_width, "px ").concat(button_border_style, " ").concat(stroke_color, ";border-radius: ").concat(radius, "px;");
      }
      var marginStyles = "";
      if (enable_margin) {
        marginStyles = "margin:".concat(margin_top, "px ").concat(margin_right, "px ").concat(margin_bottom, "px ").concat(margin_left, "px;");
      }
      var paddingStyles = "";
      if (enable_padding) {
        paddingStyles = "padding:".concat(padding_top, "px ").concat(padding_right, "px ").concat(padding_bottom, "px ").concat(padding_left, "px;");
      }
      var gradientStyles = "";
      if (enable_gradient) {
        gradientStyles = "background-image:linear-gradient(".concat(gradient_direction, ", ").concat(gradient_c1, ", ").concat(gradient_c2, ");");
      }
      buttons += type !== "stepper" ? "\n        ".concat(custom_font, "\n    div .button-div.").concat(position, "-button-").concat(slot, "{\n      ").concat(type === "wide" ? "width:100%;text-align:center;" : "width:auto", "\n      height:auto;\n      cursor: pointer;\n      background-color: ").concat(bg_color === "#" ? "transparent" : bg_color, ";\n      ").concat(borderStyles, "\n      ").concat(marginStyles, "\n      ").concat(paddingStyles, "\n      ").concat(marginLeft ? "margin-left:auto;" : "", "\n      ").concat(marginRight ? "margin-right:auto;" : "", "\n      ").concat(gradientStyles, "\n    }\n    .").concat(position, "-button-").concat(slot, "{\n      cursor: pointer;\n      color: ").concat(text_color, ";\n      background-color: transparent;\n      font-size: ").concat(size, "px;\n      border:none;\n      font-family: ").concat(font_family, ";\n      font-weight: ").concat(weight, ";\n      font-style: ").concat(style, ";\n      margin: ").concat(text_margin_top, "px ").concat(text_margin_right, "px ").concat(text_margin_bottom, "px ").concat(text_margin_left, "px;\n      padding: ").concat(text_padding_top, "px ").concat(text_padding_right, "px ").concat(text_padding_bottom, "px ").concat(text_padding_left, "px;\n    }\n    ") : "\n    div .button-div.".concat(position, "-button-").concat(slot, "{\n      width:auto;\n      height:auto;\n      cursor: pointer;\n      background-color: transparent;\n      ").concat(marginLeft ? "margin-left:auto;" : "", "\n      ").concat(marginRight ? "margin-right:auto;" : "margin-right:12px;", "\n      ").concat(gradientStyles, "\n    }\n    ").concat(sub_type === CAROUSEL_TYPE.NUMBER ? "div .stepper-".concat(sub_type, "{\n          font-family:").concat(numberedfont.family, ";\n          font-size: ").concat(numberedfont.size, "px;\n          font-style:").concat(numberedfont.style, ";\n          font-width:").concat(numberedfont.width, ";\n          color:").concat(numbered.color, ";\n        }") : "", "\n\n    ").concat(sub_type === CAROUSEL_TYPE.CAROUSAL ? "div .stepper-".concat(sub_type, "{\n        font-size:\"20px\";\n      }") : "", "\n    ");
    });
    return "\n  div .".concat(position, "-buttons-container  {\n    width:100%;\n    display: flex;\n    flex-direction:").concat(button_direction === DIRECTION.VERTICAL && (position === BUTTON_CONTAINER_POSITION.BOTTOM || position === BUTTON_CONTAINER_POSITION.SURVEY_BOTTOM) ? "column" : "row", ";\n    justify-content:").concat(justifyContent, ";\n    align-items:").concat(button_direction === DIRECTION.HORIZONTAL ? "center" : getButtonPosition(button_alignment), ";\n    flex-wrap:wrap;\n  }\n  ").concat(buttons, "\n  ");
  };
  var getButtonsCSS = function getButtonsCSS(buttons_css) {
    var button_position = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "right";
    var button_direction = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DIRECTION.HORIZONTAL;
    var prefix = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "";
    var buttons = "";
    if (buttons_css.length > 0) {
      var _buttons_css$ = buttons_css[0],
        bg_color = _buttons_css$.bg_color,
        text_color = _buttons_css$.text_color,
        size = _buttons_css$.size,
        font_family = _buttons_css$.font_family,
        _buttons_css$$borders = _buttons_css$.borders,
        stroke_color = _buttons_css$$borders.stroke_color,
        radius = _buttons_css$$borders.radius,
        enable_gradient = _buttons_css$.enable_gradient,
        _buttons_css$$gradien = _buttons_css$.gradient,
        gradient = _buttons_css$$gradien === void 0 ? {} : _buttons_css$$gradien;
      var custom_font_button_0 = _setFontFaceAtRule({
        family: font_family
      });
      var gradient_direction, gradient_c1, gradient_c2;
      if (enable_gradient) {
        gradient_direction = gradient.gradient_direction || "to right";
        gradient_c1 = gradient.gradient_c1 || COLORS.BLACK;
        gradient_c2 = gradient.gradient_c2 || COLORS.WHITE;
      }
      buttons = "\n    ".concat(custom_font_button_0[1], "\n    ").concat(prefix, " footer .shepherd-button.button-o {\n      cursor: pointer;\n      background-color: ").concat(bg_color === "#" ? "transparent" : bg_color, ";\n      color: ").concat(text_color, ";font-size: ").concat(size, "px;font-family: ").concat(custom_font_button_0[0], ";\n      font-weight: ").concat(font_family !== "bold" ? "normal" : font_family, ";\n      font-style: ").concat(font_family === "italic" ? "italic" : "unset", ";\n      border: 0px solid ").concat(stroke_color, ";border-radius: ").concat(radius, "px;\n      ").concat(enable_gradient ? "background-image:linear-gradient(".concat(gradient_direction, ", ").concat(gradient_c1, ", ").concat(gradient_c2, ");") : "", "\n      margin-right:").concat(bg_color === "#" ? 0 : "12px", "\n    }\n    ");
    }
    if (buttons_css.length > 1) {
      var _buttons_css$2 = buttons_css[1],
        _bg_color = _buttons_css$2.bg_color,
        _text_color = _buttons_css$2.text_color,
        _size = _buttons_css$2.size,
        _font_family = _buttons_css$2.font_family,
        _buttons_css$2$border = _buttons_css$2.borders,
        _stroke_color = _buttons_css$2$border.stroke_color,
        _radius = _buttons_css$2$border.radius,
        _buttons_css$2$gradie = _buttons_css$2.gradient_config,
        gradient_config = _buttons_css$2$gradie === void 0 ? {} : _buttons_css$2$gradie;
      var custom_font_button_1 = _setFontFaceAtRule({
        family: _font_family
      });
      var _gradient_direction, _gradient_c, _gradient_c2;
      var _enable_gradient = gradient_config.enable_gradient || false;
      if (_enable_gradient) {
        _gradient_direction = gradient_config.gradient_direction || "to right";
        _gradient_c = (gradient_config === null || gradient_config === void 0 ? void 0 : gradient_config.colors[0]) || COLORS.BLACK;
        _gradient_c2 = (gradient_config === null || gradient_config === void 0 ? void 0 : gradient_config.colors[1]) || COLORS.WHITE;
      }
      buttons += "\n    ".concat(custom_font_button_1[1], "\n    ").concat(prefix, " footer .shepherd-button.button-t {\n      cursor: pointer;\n      background-color: ").concat(_bg_color === "#" ? "transparent" : _bg_color, ";\n      color: ").concat(_text_color, ";font-size: ").concat(_size, "px;font-family: ").concat(custom_font_button_1[0], ";\n      font-weight: ").concat(_font_family !== "bold" ? "normal" : _font_family, ";\n      font-style: ").concat(_font_family === "italic" ? "italic" : "unset", ";\n      ").concat(_enable_gradient ? "background-image:linear-gradient(".concat(_gradient_direction, ", ").concat(_gradient_c, ", ").concat(_gradient_c2, ");") : "", "\n      border: 0px solid ").concat(_stroke_color, ";border-radius: ").concat(_radius, "px;\n    }\n    ");
    }
    return "\n  ".concat(prefix, " footer .shepherd-button {\n    display: inline-block;\n    *display: inline;\n    vertical-align: middle;\n    *vertical-align: auto;\n    *zoom: 1;\n    border: 0;border-radius: 3px;cursor: pointer;display: inline;font-family: inherit;\n    font-size: .8em;letter-spacing: .01em;line-height: 18px;margin-right: 12px;\n    padding: 8px 16px;text-transform: none;transition: all .5s ease\n  }\n  ").concat(buttons, "\n  ").concat(prefix, " footer .shepherd-button:last-child {\n  }\n\n  ").concat(prefix, " footer {\n    border-bottom-left-radius: 5px;\n    border-bottom-right-radius: 5px;\n    display: flex;\n    flex-direction:").concat(button_direction === DIRECTION.HORIZONTAL ? "row" : "column", ";\n\n    align-items:center;\n    justify-content: ").concat(button_direction === DIRECTION.HORIZONTAL ? getButtonPosition(button_position) : "space-evenly", ";\n    padding: 0 .8em .8em;\n  }\n  ");
  };
  var generateButtons = function generateButtons() {
    var buttons_config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var ActionHandler = arguments.length > 1 ? arguments[1] : undefined;
    var uuid = arguments.length > 2 ? arguments[2] : undefined;
    var name = arguments.length > 3 ? arguments[3] : undefined;
    var configType = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : "Inline_";
    var rtmInstance = window.ApxorRTM;
    var buttons_array = [];
    var buttons_css = [];
    buttons_config.forEach(function (button_config, index) {
      var _button_config$action, _button_config$action2, _button_config$action3, _button_config$action4, _button_config$action5, _button_config$action6, _button_config$action7, _button_config$action8, _button_config$action9, _button_config$action10, _button_config$action11, _button_config$action12;
      var _action = (_button_config$action = button_config === null || button_config === void 0 || (_button_config$action2 = button_config.action_config) === null || _button_config$action2 === void 0 ? void 0 : _button_config$action2.action) !== null && _button_config$action !== void 0 ? _button_config$action : "end";
      var vMap = (_button_config$action3 = button_config === null || button_config === void 0 || (_button_config$action4 = button_config.action_config) === null || _button_config$action4 === void 0 ? void 0 : _button_config$action4.vmap) !== null && _button_config$action3 !== void 0 ? _button_config$action3 : {};
      var url = (_button_config$action5 = button_config === null || button_config === void 0 || (_button_config$action6 = button_config.action_config) === null || _button_config$action6 === void 0 ? void 0 : _button_config$action6.url) !== null && _button_config$action5 !== void 0 ? _button_config$action5 : "";
      var isExternal = (_button_config$action7 = button_config === null || button_config === void 0 || (_button_config$action8 = button_config.action_config) === null || _button_config$action8 === void 0 ? void 0 : _button_config$action8.is_external) !== null && _button_config$action7 !== void 0 ? _button_config$action7 : true;
      var redirectWithin = (_button_config$action9 = button_config === null || button_config === void 0 || (_button_config$action10 = button_config.action_config) === null || _button_config$action10 === void 0 ? void 0 : _button_config$action10.is_within) !== null && _button_config$action9 !== void 0 ? _button_config$action9 : false;
      var callbackFunction = (_button_config$action11 = button_config === null || button_config === void 0 || (_button_config$action12 = button_config.action_config) === null || _button_config$action12 === void 0 ? void 0 : _button_config$action12.callback_func) !== null && _button_config$action11 !== void 0 ? _button_config$action11 : "";
      _action = _action.toLowerCase();
      resolveDynamicText(button_config.text_config);
      var borders = button_config.borders,
        color = button_config.color,
        _button_config$text_c = button_config.text_config,
        text = _button_config$text_c.text,
        text_color = _button_config$text_c.color,
        size = _button_config$text_c.size,
        style = _button_config$text_c.style,
        font_family = _button_config$text_c.font_family,
        _button_config$gradie = button_config.gradient_config,
        gradient_config = _button_config$gradie === void 0 ? {} : _button_config$gradie;
      var action;
      try {
        switch (_action) {
          case "done":
          case "dismiss":
            action = function action() {
              rtmInstance.logActionEvent(configType + text + "_Clicked", uuid, name);
              ActionHandler.complete(false, "dismiss");
            };
            break;
          case "next":
            action = function action() {
              ActionHandler.complete(false, "dismiss");
              rtmInstance.logActionEvent(configType + text + "_Clicked", uuid, name);
            };
            break;
          case "prev":
            action = function action() {
              ActionHandler.complete(false, "prev");
              rtmInstance.logActionEvent(configType + text + "_Clicked", uuid, name);
            };
            break;
          case "redirect":
            action = function action() {
              rtmInstance.logActionEvent(configType + text + "_Clicked", uuid, name);
              if (redirectWithin || isExternal) {
                window.open(url, redirectWithin ? "_self" : "_blank");
              } else {
                rtmInstance.logClientEvent("REDIRECT", {
                  url: url
                });
              }
              ActionHandler.next(false, "redirect");
            };
            break;
          case "callback":
            action = function action() {
              var functionParts = callbackFunction.split(".");
              var redirectionCallback = window;
              for (var i = 0; i < functionParts.length; ++i) {
                redirectionCallback = redirectionCallback[functionParts[i]];
                if (!redirectionCallback) {
                  return;
                }
              }
              var callBackArguments = evaluateCallBackArguments(vMap);
              redirectionCallback ? redirectionCallback(callBackArguments) : undefined;
              ActionHandler.complete(false, "callback");
              rtmInstance.logActionEvent(configType + text + "_Clicked", uuid, name);
            };
            break;
          case "cancel":
            action = function action() {
              ActionHandler._isCancelled = true;
              ActionHandler.cancel(true, "cancel");
              rtmInstance.logActionEvent(configType + text + "_Clicked", uuid, name);
            };
            break;
          default:
            action = function action() {
              rtmInstance.logActionEvent(configType + text + "_Clicked", uuid, name);
              ActionHandler.cancel(false, "cancel");
            };
        }
      } catch (e) {
        window.ApxorLogger.error("Error setting actions on the buttons:" + e);
      }
      buttons_css.push({
        borders: borders,
        bg_color: color,
        text_color: text_color,
        size: size,
        style: style,
        font_family: font_family,
        gradient_config: gradient_config
      });
      buttons_array.push({
        classes: index === 0 ? "button-o" : "button-t",
        text: text,
        action: action
      });
    });
    return {
      buttons_array: buttons_array,
      buttons_css: buttons_css
    };
  };
  var generateButtonsFromConfig = function generateButtonsFromConfig() {
    var buttons_config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var ActionHandler = arguments.length > 1 ? arguments[1] : undefined;
    var uuid = arguments.length > 2 ? arguments[2] : undefined;
    var name = arguments.length > 3 ? arguments[3] : undefined;
    var configType = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : "Inline_";
    var position = arguments.length > 5 ? arguments[5] : undefined;
    var isWalkthrough = arguments.length > 6 ? arguments[6] : undefined;
    var uis = arguments.length > 7 ? arguments[7] : undefined;
    var ind = arguments.length > 8 ? arguments[8] : undefined;
    var rtmInstance = window.ApxorRTM;
    var buttons_array = [];
    var buttons_css = [];
    buttons_config.sort(function (a, b) {
      return a.slot - b.slot;
    });
    buttons_config.forEach(function (button_config, index) {
      var _action = "end";
      var url = "";
      var isExternal = "";
      var redirectWithin = "";
      var callbackFunction = function callbackFunction() {};
      if (button_config.enable_action) {
        var _action2$is_within, _action2$callback;
        var _action2 = button_config.action;
        _action = _action2.type;
        url = _action2.url;
        isExternal = _action2.is_external;
        redirectWithin = (_action2$is_within = _action2.is_within) !== null && _action2$is_within !== void 0 ? _action2$is_within : false;
        callbackFunction = (_action2$callback = _action2.callback) !== null && _action2$callback !== void 0 ? _action2$callback : function () {};
      }
      var vMap = {};
      if (button_config.enable_text) {
        var _button_config$text$s, _button_config$text;
        vMap = (_button_config$text$s = (_button_config$text = button_config.text) === null || _button_config$text === void 0 || (_button_config$text = _button_config$text.script) === null || _button_config$text === void 0 ? void 0 : _button_config$text.vmap) !== null && _button_config$text$s !== void 0 ? _button_config$text$s : {};
      }
      resolveDynamicText(button_config.text);
      var slot = button_config.slot,
        type = button_config.type,
        sub_type = button_config.sub_type,
        enable_border = button_config.enable_border,
        border = button_config.border,
        color = button_config.color,
        enable_margin = button_config.enable_margin,
        margin = button_config.margin,
        enable_padding = button_config.enable_padding,
        padding = button_config.padding,
        _button_config$text2 = button_config.text,
        text = _button_config$text2.text,
        text_color = _button_config$text2.color,
        _button_config$text2$ = _button_config$text2.font,
        size = _button_config$text2$.size,
        style = _button_config$text2$.style,
        weight = _button_config$text2$.weight,
        text_margin = _button_config$text2.margin,
        text_padding = _button_config$text2.padding,
        _button_config$gradie2 = button_config.gradient,
        gradient = _button_config$gradie2 === void 0 ? {} : _button_config$gradie2,
        enable_gradient = button_config.enable_gradient;
      var action;
      try {
        switch (_action) {
          case "done":
          case "dismiss":
            action = function action() {
              rtmInstance.logActionEvent(configType + text + "_Clicked", uuid, name);
              ActionHandler.complete(false, "dismiss", index);
            };
            break;
          case "submit":
            action = function action() {
              ActionHandler.complete(false, "submit", index);
              rtmInstance.logActionEvent(configType + text + "_Clicked", uuid, name);
            };
            break;
          case "next":
            action = function action() {
              ActionHandler.complete(false, "next", index);
              if (isWalkthrough && ind + 1 < uis.length) {
                ActionHandler.next(uuid, ind + 1);
              }
              rtmInstance.logActionEvent(configType + text + "_Clicked", uuid, name);
            };
            break;
          case "prev":
            action = function action() {
              ActionHandler.complete(false, "prev", index);
              if (isWalkthrough && ind - 1 >= 0) {
                ActionHandler.prev(uuid, ind - 1);
              }
              rtmInstance.logActionEvent(configType + text + "_Clicked", uuid, name);
            };
            break;
          case "skip":
            action = function action() {
              ActionHandler.complete(false, "skip", index);
              rtmInstance.logActionEvent(configType + text + "_Clicked", uuid, name);
            };
            break;
          case "yes":
            action = function action() {
              ActionHandler.complete(false, "yes");
              rtmInstance.logActionEvent(configType + text + "_Clicked", uuid, name);
            };
            break;
          case "no":
            action = function action() {
              ActionHandler.complete(false, "no");
              rtmInstance.logActionEvent(configType + text + "_Clicked", uuid, name);
            };
            break;
          case "redirect":
            action = function action() {
              rtmInstance.logActionEvent(configType + text + "_Clicked", uuid, name);
              if (redirectWithin || isExternal) {
                window.open(url, redirectWithin ? "_self" : "_blank");
              } else {
                rtmInstance.logClientEvent("REDIRECT", {
                  url: url
                });
              }
              ActionHandler.next(false, "redirect", index);
            };
            break;
          case "callback":
            action = function action() {
              var functionParts = callbackFunction.split(".");
              var redirectionCallback = window;
              for (var i = 0; i < functionParts.length; ++i) {
                redirectionCallback = redirectionCallback[functionParts[i]];
                if (!redirectionCallback) {
                  return;
                }
              }
              var callBackArguments = evaluateCallBackArguments(vMap);
              redirectionCallback ? redirectionCallback(callBackArguments) : undefined;
              ActionHandler.complete(false, "callback", index);
              rtmInstance.logActionEvent(configType + text + "_Clicked", uuid, name);
            };
            break;
          case "cancel":
            action = function action() {
              rtmInstance.logActionEvent(configType + text + "_Clicked", uuid, name);
              ActionHandler._isCancelled = true;
              ActionHandler.cancel(true, "cancel", index);
            };
            break;
          default:
            action = function action() {
              rtmInstance.logActionEvent(configType + text + "_Clicked", uuid, name);
              ActionHandler.cancel(false, "cancel", index);
            };
        }
      } catch (e) {
        window.ApxorLogger.error("Error setting actions on the buttons:" + e);
      }
      var custom_font = _setFontFaceAtRule(button_config.text.font);
      var font_family = custom_font[0];
      buttons_css.push({
        slot: slot,
        type: type,
        sub_type: sub_type,
        enable_border: enable_border,
        border: border,
        bg_color: color,
        text_color: text_color,
        size: size,
        style: style,
        weight: weight,
        font_family: font_family,
        text_margin: text_margin,
        text_padding: text_padding,
        enable_margin: enable_margin,
        margin: margin,
        enable_padding: enable_padding,
        padding: padding,
        enable_gradient: enable_gradient,
        gradient: gradient,
        custom_font: custom_font[1]
      });
      buttons_array.push({
        type: "".concat(type ? type : "button"),
        sub_type: "".concat(sub_type ? sub_type : ""),
        classes: "".concat(position, "-button-").concat(slot),
        text: text,
        action: action,
        _action: _action
      });
    });
    return {
      buttons_array: buttons_array,
      buttons_css: buttons_css
    };
  };
  function hexToRgb$1(hex) {
    // Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
    var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
    hex = hex.replace(shorthandRegex, function (m, r, g, b) {
      return r + r + g + g + b + b;
    });
    var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? {
      r: parseInt(result[1], 16),
      g: parseInt(result[2], 16),
      b: parseInt(result[3], 16)
    } : null;
  }
  var createDialog$1 = function createDialog(width, min_height, _ref3) {
    var _ref3$dim_background = _ref3.dim_background,
      dim_background = _ref3$dim_background === void 0 ? true : _ref3$dim_background,
      _ref3$dim_bg_color = _ref3.dim_bg_color,
      dim_bg_color = _ref3$dim_bg_color === void 0 ? "#000000" : _ref3$dim_bg_color,
      _ref3$dim_bg_opacity = _ref3.dim_bg_opacity,
      dim_bg_opacity = _ref3$dim_bg_opacity === void 0 ? 0.87 : _ref3$dim_bg_opacity,
      position = _ref3.position;
    var dialogRoot = document.createElement("div");
    dialogRoot.setAttribute("id", APX_OVERLAY);
    var styleNode = document.createElement("style");
    var justifyContent = "center";
    var alignItems = "center";
    switch (position) {
      case "bottom-left":
        justifyContent = "flex-start";
        alignItems = "flex-end";
        break;
      case "bottom-right":
        justifyContent = "flex-end";
        alignItems = "flex-end";
        break;
      case "top-left":
        justifyContent = "flex-start";
        alignItems = "flex-start";
        break;
      case "top-right":
        justifyContent = "flex-end";
        alignItems = "flex-start";
        break;
    }
    var bg_color = "none";
    if (dim_background) {
      var rgb = hexToRgb$1(dim_bg_color);
      bg_color = "rgb(".concat(rgb.r, ", ").concat(rgb.g, ", ").concat(rgb.b, ", ").concat(dim_bg_opacity, ")");
    }
    styleNode.innerHTML = "\n#apx-oly {\n  width:100%;height:100%;position:fixed;top:0;left:0;background-color:".concat(bg_color, ";\n  display:flex;justify-content:").concat(justifyContent, ";align-items:").concat(alignItems, ";border-radius:3px;z-index:2147483647\n}\n#apx-oly > * {font-family: inherit;box-sizing:unset}\n.apx-dlg-c {\n  width:").concat(width, "px;min-height:").concat(min_height, "%;background:white;z-index:99999999;opacity:0;position:relative;visibility:hidden;\n  transition:all 500ms cubic-bezier(0, -0.37, 0, 2.06);top:-15px;border-radius:3px;margin:20px\n}\n.apx-dlg-c.open {opacity:1;visibility:visible;top:0}\n  ").replaceAll("\n", "").replace(/[\s]{2,999}/g, "");
    var dialogContent = document.createElement("div");
    dialogContent.setAttribute("id", APX_DIALOG_CONTENT);
    dialogContent.classList.add(APX_DIALOG_CONTENT);
    dialogRoot.appendChild(dialogContent);
    dialogRoot.appendChild(styleNode);
    document.body.appendChild(dialogRoot);
    return dialogRoot;
  };
  var getCookie = function getCookie(name) {
    if (window.document) {
      var nameEQ = name + "=";
      var storedCookies = window.document.cookie.split(";");
      for (var i = 0; i < storedCookies.length; i++) {
        var cookie = storedCookies[i];
        while (cookie.charAt(0) === " ") {
          cookie = cookie.substring(1, cookie.length);
        }
        if (cookie.indexOf(nameEQ) === 0) {
          return decodeURIComponent(cookie.substring(nameEQ.length, cookie.length));
        }
      }
    }
    return null;
  };
  var uuid = function uuid(base) {
    return [Math.random, function () {
      return uuid.last ? uuid.last + Math.random() : Math.random();
    }, Math.random, Date.now, Math.random].map(function (fn) {
      return fn().toString(base || 16 + Math.random() * 20).substr(-8);
    }).join("-");
  };
  var hexToRGB = function hexToRGB(hex) {
    var alpha = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.5;
    var r = parseInt(hex.slice(1, 3), 16),
      g = parseInt(hex.slice(3, 5), 16),
      b = parseInt(hex.slice(5, 7), 16);
    if (alpha) {
      return "rgba(" + r + ", " + g + ", " + b + ", " + alpha + ")";
    } else {
      return "rgb(" + r + ", " + g + ", " + b + ")";
    }
  };
  var getAnimationValue = function getAnimationValue(percent) {
    if (percent === 50) {
      return 10;
    } else {
      return 16;
    }
  };
  var translateDir = function translateDir(position, percent) {
    var pos = position.toLowerCase();
    switch (pos) {
      case "top":
      case "top-start":
      case "top-end":
        return "translateY(".concat(getAnimationValue(percent) - 26, "px)");
      case "right":
      case "right-start":
      case "right-end":
        return "translateX(".concat(getAnimationValue(percent), "px)");
      case "bottom":
      case "bottom-start":
      case "bottom-end":
        return "translateY(".concat(getAnimationValue(percent), "px)");
      case "left":
      case "left-start":
      case "left-end":
        return "translateX(".concat(getAnimationValue(percent) - 26, "px)");
    }
  };

  // Checks if the given element is in viewport or not.
  var isElementInViewport = function isElementInViewport(el) {
    var elementOffsetHight = el.offsetHeight;
    var elementOffsetWidth = el.offsetWidth;
    var boundingRect = el.getBoundingClientRect();
    if (boundingRect.left >= -elementOffsetWidth && boundingRect.top >= -elementOffsetHight && boundingRect.right <= (window.innerWidth || document.documentElement.clientWidth) + elementOffsetWidth && boundingRect.bottom <= (window.innerHeight || document.documentElement.clientHeight) + elementOffsetHight) {
      return true;
    } else {
      return false;
    }
  };
  var replaceStringBetweenIndeces = function replaceStringBetweenIndeces(dynamicText, start, end, replaceWith) {
    return dynamicText.substring(0, start) + replaceWith + dynamicText.substring(end);
  };

  //Evaluates the DynamicText
  var evaluateDynamicText = function evaluateDynamicText(config) {
    var userAttributes = Apxor.getController().getUserAttributes();
    var sessionAttributes = Apxor.getController().getSessionAttributes();
    var variableMap = config.script.vmap;
    var dynamicText = config.script.src;
    var indexOfStartBrace = dynamicText.indexOf("{");
    var indexOfEndBrace = dynamicText.indexOf("}");
    var loggedEvents = Apxor.getController().getListOfEventsLogged();
    try {
      // If the text be "Hello {name}"
      // name is a dynamic element in it.
      // While there are dynamic elements in the text. Identify the type of the element and get its value
      while (indexOfStartBrace != -1 && indexOfEndBrace != -1 && indexOfStartBrace < indexOfEndBrace) {
        //Extract the variable name between '{' and '}'
        var variableName = dynamicText.substring(indexOfStartBrace + 1, indexOfEndBrace);
        var attributeType = variableMap[variableName][VARIABLE_TYPE];
        var attributeName = variableMap[variableName][ATTRIBUTE_NAME];
        var defaultValue = variableMap[variableName][DEFAULT_VALUE];
        var attributeValue = "";
        //Depending on the type of the variable, get the value of it.
        if (attributeType === SESSION_ATTRIBUTES) {
          attributeValue = sessionAttributes[attributeName] ? sessionAttributes[attributeName] : defaultValue;
        } else if (attributeType === USER_ATTRIBUTES) {
          attributeValue = userAttributes[attributeName] ? userAttributes[attributeName] : defaultValue;
        } else if (attributeType === APPLICATION_VIEW_ID) {
          if (Apxor.isFlutter()) {
            var helper = Apxor.getApxorFlutterHelper();
            var result = helper.getText(attributeName);
            if (result.r && result.r.st == true) {
              attributeValue = result.r.t;
            } else {
              attributeValue = defaultValue;
            }
          } else {
            //If the variable is a view id type, get the elemnt from the DOM and get its textcontent
            var viewElement = getElementFromSelector(attributeName);
            attributeValue = viewElement === null || viewElement === void 0 ? void 0 : viewElement.textContent;
            if (!attributeValue) {
              attributeValue = (viewElement === null || viewElement === void 0 ? void 0 : viewElement.value) || defaultValue;
            }
          }
        } else if (attributeType === EVENT_TYPE) {
          var _attributeName = variableMap[variableName][ATTRIBUTE_NAME];
          var propertyName = variableMap[variableName][EVENT_PROPERTY_NAME];
          if (loggedEvents[_attributeName] && loggedEvents[_attributeName][propertyName]) {
            attributeValue = loggedEvents[_attributeName][propertyName];
          } else {
            attributeValue = defaultValue;
          }
        }

        // Replace the dynamic text with its actual value.
        dynamicText = replaceStringBetweenIndeces(dynamicText, indexOfStartBrace, indexOfEndBrace + 1, attributeValue);
        indexOfStartBrace = dynamicText.indexOf("{");
        indexOfEndBrace = dynamicText.indexOf("}");
      }
      config.text = dynamicText;
    } catch (e) {
      console.log("Can't evaluate the dynamic text");
    }
  };
  //Evaluates the DynamicScript for CallBack Arguments
  var evaluateCallBackArguments = function evaluateCallBackArguments(vmap) {
    var userAttributes = Apxor.getController().getUserAttributes();
    var sessionAttributes = Apxor.getController().getSessionAttributes();
    var variableMap = vmap;
    var argumentsToBePassed = {};
    var loggedEvents = Apxor.getController().getLoggedEventsList();
    try {
      var variables = Object.keys(variableMap);
      variables.forEach(function (variableName) {
        var variableProperties = variableMap[variableName];
        var attributeType = variableProperties[VARIABLE_TYPE];
        var attributeName = variableProperties[ATTRIBUTE_NAME];
        var defaultValue = variableProperties[DEFAULT_VALUE];
        var attributeValue = "";
        //Depending on the type of the variable, get the value of it.
        if (attributeType === SESSION_ATTRIBUTES) {
          attributeValue = sessionAttributes[attributeName] ? sessionAttributes[attributeName] : defaultValue;
        } else if (attributeType === USER_ATTRIBUTES) {
          attributeValue = userAttributes[attributeName] ? userAttributes[attributeName] : defaultValue;
        } else if (attributeType === APPLICATION_VIEW_ID) {
          //If the variable is a view id type, get the elemnt from the DOM and get its textcontent
          var viewElement = getElementFromSelector(attributeName);
          attributeValue = viewElement === null || viewElement === void 0 ? void 0 : viewElement.textContent;
          if (!attributeValue) {
            attributeValue = (viewElement === null || viewElement === void 0 ? void 0 : viewElement.value) || defaultValue;
          }
        } else if (attributeType === EVENT_TYPE) {
          var _attributeName2 = variableMap[variableName][ATTRIBUTE_NAME];
          var propertyName = variableMap[variableName][EVENT_PROPERTY_NAME];
          if (loggedEvents[_attributeName2] && loggedEvents[_attributeName2][propertyName]) {
            attributeValue = loggedEvents[_attributeName2][propertyName];
          } else {
            attributeValue = defaultValue;
          }
        }
        argumentsToBePassed[variableName] = attributeValue;
      });
      return argumentsToBePassed;
    } catch (e) {
      console.log("Can't evaluate the dynamic text");
    }
  };

  //Evaluates the DynamicScript
  var evaluateDynamicScript = function evaluateDynamicScript(config) {
    var userAttributes = Apxor.getController().getUserAttributes();
    var sessionAttributes = Apxor.getController().getSessionAttributes();
    var variableMap = config.script.vmap;
    var variableString = "";
    var dynamicScript = config.script.src;
    var loggedEvents = Apxor.getController().getListOfEventsLogged();

    //For each of the entries in the vMap, create a JS variable.
    Object.entries(variableMap).forEach(function (_ref4) {
      var _ref5 = _slicedToArray$1(_ref4, 2),
        variableName = _ref5[0],
        variableValue = _ref5[1];
      var attributeType = variableValue[VARIABLE_TYPE];
      var attributeName = variableValue[ATTRIBUTE_NAME];
      var defaultValue = variableValue[DEFAULT_VALUE];
      var attributeValue = "";
      if (attributeType === SESSION_ATTRIBUTES) {
        attributeValue = sessionAttributes[attributeName] ? sessionAttributes[attributeName] : defaultValue;
      } else if (attributeType === USER_ATTRIBUTES) {
        attributeValue = userAttributes[attributeName] ? userAttributes[attributeName] : defaultValue;
      } else if (attributeType === APPLICATION_VIEW_ID) {
        //If the variable is a view id type, get the elemnt from the DOM and get its textcontent
        if (Apxor.isFlutter()) {
          var helper = Apxor.getApxorFlutterHelper();
          var result = helper.getText(attributeName);
          if (result.r && result.r.st == true) {
            attributeValue = result.r.t;
          } else {
            attributeValue = defaultValue;
          }
        } else {
          var viewElement = getElementFromSelector(attributeName);
          attributeValue = viewElement === null || viewElement === void 0 ? void 0 : viewElement.textContent;
          if (!attributeValue) {
            attributeValue = (viewElement === null || viewElement === void 0 ? void 0 : viewElement.value) || defaultValue;
          }
        }
      } else if (attributeType === EVENT_TYPE) {
        var _attributeName3 = variableMap[variableName][ATTRIBUTE_NAME];
        var propertyName = variableMap[variableName][EVENT_PROPERTY_NAME];
        if (loggedEvents[_attributeName3] && loggedEvents[_attributeName3][propertyName]) {
          attributeValue = loggedEvents[_attributeName3][propertyName];
        } else {
          attributeValue = defaultValue;
        }
      }
      variableString = "".concat(variableString, " \n let ").concat(variableName, " = \"").concat(attributeValue, "\";");
    });

    // Append the dynamicScript to the variables and then evaluate them
    var evalString = "".concat(variableString, " \n ").concat(dynamicScript);
    // const evalFunction = new Function(evalString);
    // config.text = evalFunction();

    var asyncEvalFunction = function asyncEvalFunction() {
      var evalFunction = new Function(evalString);
      return evalFunction();
    };
    config.text = asyncEvalFunction();
  };

  /**
   * @function resolveDynamicText
   * @description Resolves the dynamic text if any in the given config.
   * Dynamic text could be from a text evaluation or a script evaluation.
   * @param {JSON} config
   */
  var resolveDynamicText = function resolveDynamicText(config) {
    if ((config === null || config === void 0 ? void 0 : config.text) === DYNAMIC_TEXT) {
      config.script.t === 0 ? evaluateDynamicText(config) : evaluateDynamicScript(config);
    }
  };

  /**
   * @function getStylisedText
   * @description Applies the styles to the text be it title or description.
   * Texts and the corresponding Styles are specified in the segments.
   * @param {string} rawText - Text on which styles should be applied
   * @param {Array} segments - Marks the indexes of the text with the list of styles
   * @param {object} quote - Send this if blockquote must be applied to the entire text
   * @returns
   */
  var getStylisedText = function getStylisedText() {
    var rawText = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
    var segments = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    var quote = arguments.length > 2 ? arguments[2] : undefined;
    var link_config = arguments.length > 3 ? arguments[3] : undefined;
    var stylisedTextElement = document.createElement("span");
    if (segments.length == 0) {
      stylisedTextElement.innerText = addLinksToText(rawText, link_config);
    } else {
      segments.forEach(function (segment) {
        var start = parseInt(segment.start);
        var end = parseInt(segment.end);
        var segmentText = rawText.substring(start, end);
        var styling = "";
        if (segment.color) {
          styling = "".concat(styling, "color:").concat(segment.color, ";");
        }
        if (segment.font_family) {
          styling = "".concat(styling, "font-family:").concat(segment.font_family, ";");
        }
        if (segment.size) {
          styling = "".concat(styling, "font-size:").concat(segment.size, "px;");
        }
        if (segment.style === "italic") {
          styling = "".concat(styling, "font-style:").concat(segment.style, ";");
        }
        if (segment.style === "bold") {
          styling = "".concat(styling, "font-weight:").concat(segment.style, ";");
        }
        if (segment.style === "normal") {
          styling = "".concat(styling, "font-weight:").concat(segment.style, ";");
        }
        if (segment.underline == true) {
          styling = "".concat(styling, "text-decoration:underline;");
        }
        if (segment.strike_through == true) {
          styling = "".concat(styling, "text-decoration:line-through;");
        }
        if (segment.script == "super") {
          styling = "".concat(styling, "vertical-align:super;");
        }
        if (segment.script == "sub") {
          styling = "".concat(styling, "vertical-align:sub;");
        }
        if (segment.bg_color) {
          styling = "".concat(styling, "background-color:").concat(segment.bg_color, ";");
        }
        var segmentTextElement = document.createElement("span");
        segmentTextElement.style = styling;
        segmentTextElement.innerHTML = addLinksToText(segmentText, link_config);
        //`<span style='${styling}'>${segmentText}</span>`;
        stylisedTextElement.appendChild(segmentTextElement);
        //stylisedTextElement = `${stylisedTextElement} ${segmentTextElement}`;
      });
    }

    if (quote !== undefined) {
      var quoteText = document.createElement("blockquote");
      var styling = "";
      if (quote.color) {
        styling = "border-left-color:".concat(quote.color, ";");
      }
      if (quote.width) {
        styling = "".concat(styling, "border-left-width:").concat(quote.width, "px;");
      }
      if (quote.gap) {
        styling = "".concat(styling, "padding:").concat(quote.gap, "px;");
      }
      quoteText.appendChild(stylisedTextElement);
      quoteText.style = styling;
      return quoteText;
    }
    return stylisedTextElement;
  };

  /**
   * @function addLinksToText
   * @description Creates the anchor tag for the text if it is part of the link configuration.
   * @param {string} text
   * @param {Array} link_config
   * @returns
   */
  var addLinksToText = function addLinksToText(text) {
    var link_config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    var anchroElement = text;
    link_config.forEach(function (link) {
      if (link.text === text) {
        anchroElement = "<a style=\"text-decoration: none;\" target=\"_blank\" href=\"".concat(link.url, "\">").concat(text, "</a>");
      }
    });
    return anchroElement;
  };

  /**
   * @function _setFontFaceAtRule
   * @description generates a font face at rule for custom fonts
   * @param {object} fontconfig
   * @returns
   */
  var _setFontFaceAtRule = function _setFontFaceAtRule(font) {
    if (getFontFormatFromCustomFontURL(font.family) === "unknown format") {
      return [font.family, ""];
    }
    var src = font.family;
    var font_family = font.family.split("/").pop().replace(/[^A-Za-z]/g, "");
    var fallbackFont = "sans-serif";
    var font_face = "\n  @font-face {\n    font-family: ".concat(font_family, ";\n    src: url(").concat(src, ") format(").concat(getFontFormatFromCustomFontURL(font.family), ");\n  }");
    return ["".concat(font_family, ", ").concat(fallbackFont), font_face];
  };

  /**
   * @function createTextElement
   * @description Creates a text element for the given text config. It could either be a title or a description.
   * @param {object} config
   * @param {string} currentId
   * @param {string} type - Title or Description type
   * @returns
   */
  var createTextElement = function createTextElement(_ref6, currentId) {
    var _ref6$color = _ref6.color,
      color = _ref6$color === void 0 ? "#000" : _ref6$color,
      _ref6$font_family = _ref6.font_family,
      font_family = _ref6$font_family === void 0 ? "cursive" : _ref6$font_family,
      _ref6$size = _ref6.size,
      size = _ref6$size === void 0 ? 14 : _ref6$size,
      _ref6$style = _ref6.style,
      style = _ref6$style === void 0 ? "bold" : _ref6$style,
      text = _ref6.text,
      segments = _ref6.segments,
      quote = _ref6.quote,
      _ref6$link_config = _ref6.link_config,
      link_config = _ref6$link_config === void 0 ? [] : _ref6$link_config;
    var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "desc";
    var element = document.createElement("span");
    element.setAttribute("id", currentId + "-" + type);
    element.className = "apx-class-".concat(currentId, "-").concat(type);
    var custom_font = _setFontFaceAtRule({
      family: font_family
    });
    var styleTag = document.createElement("style");
    styleTag.innerHTML = "\n    ".concat(custom_font[1], "\n    \n    .apx-class-").concat(currentId, "-").concat(type, " {\n      z-index:99999;\n      color:").concat(color, " !important;\n      font-family:").concat(custom_font[0], " !important;\n      font-size:").concat(size, "px !important;\n      font-weight:").concat(style, " !important;\n      font-style:").concat(style === "normal" || style === "italic" ? style + " !important" : "unset", ";\n      max-width:400px;\n    }\n  ");
    element.appendChild(styleTag);
    // If there are any styles to the text through inline edits, apply them.
    element.appendChild(getStylisedText(text, segments, quote, link_config));
    return element;
  };

  /**
   * @function createNewTextElement
   * @description Creates a text element for the given text config. It could either be a title or a description.
   * @param {object} textConfig
   * @param {string} currentId
   * @param {string} type - Title or Description type
   * @returns
   */
  var createNewTextElement = function createNewTextElement(textConfig, currentId) {
    var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "desc";
    var element = document.createElement("span");
    element.setAttribute("id", currentId + "-" + type);
    element.className = "apx-class-".concat(currentId, "-").concat(type);
    var custom_font = _setFontFaceAtRule(textConfig.font);
    var styleTag = document.createElement("style");
    styleTag.innerHTML = "\n    ".concat(custom_font[1], "\n    .apx-class-").concat(currentId, "-").concat(type, " {\n      z-index:99999;\n      color:").concat(textConfig.color, " !important;\n      font-family:").concat(custom_font[0], " !important;\n      font-size:").concat(textConfig.font.size, "px !important;\n      font-weight:").concat(textConfig.font.weight, " !important;\n      font-style:").concat(textConfig.font.style === "normal" || textConfig.font.style === "italic" ? textConfig.font.style + " !important" : "unset", ";\n    }\n  ");
    // max-width:400px;

    element.appendChild(styleTag);
    // If there are any styles to the text through inline edits, apply them.
    element.appendChild(getStylisedText(textConfig.text, textConfig.segments, textConfig.quote, textConfig.link_config));
    return element;
  };

  /**
   * @function makeid
   * @description Generates a random id of the given length.
   * @param {number} length
   * @returns
   */
  var makeid = function makeid(length) {
    var result = "";
    var characters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
    var charactersLength = characters.length;
    for (var i = 0; i < length; i++) {
      result += characters.charAt(Math.floor(Math.random() * charactersLength));
    }
    return result;
  };

  /**
   * @function getHeightWidthFromResolution
   * @description Calculates the height and width of the element.
   * For portrait screens - width is set to scale*width-of-screen and height is auto adjusted based on resolution.
   * For landscape screens - height is set to scale*height-of-screen and width is auto adjusted based on resolution.
   * @param {JSON} config
   * @param {number} scale
   * @returns {JSON}  width  - Width adjusted to the sclae.
   *                  height - Height adjusted to the scale.
   */
  var getHeightWidthFromResolution = function getHeightWidthFromResolution(config) {
    var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.5;
    var calculateFromHeight = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    var calculatedHeight = 0,
      calculatedWidth = 0;
    try {
      var _config$width = config.width,
        width = _config$width === void 0 ? 360 : _config$width,
        _config$height = config.height,
        height = _config$height === void 0 ? 360 : _config$height;
      var heightMultiplier = height / width;
      var w = window.innerWidth;
      var h = window.innerHeight;
      if (calculateFromHeight) {
        calculatedHeight = h * scale;
        calculatedWidth = calculatedHeight / heightMultiplier;
        if (calculatedWidth > 0.7 * w) {
          calculatedWidth = 0.7 * w;
          calculatedHeight = calculatedWidth * heightMultiplier;
        }
      } else {
        calculatedWidth = w * scale;
        calculatedHeight = calculatedWidth * heightMultiplier;
        if (calculatedHeight > 0.7 * h) {
          calculatedHeight = 0.7 * h;
          calculatedWidth = calculatedHeight / heightMultiplier;
        }
      }
    } catch (e) {
      console.log("Error \n ".concat(e, " \n occured while calculating the height and width"));
    }
    return {
      height: calculatedHeight,
      width: calculatedWidth
    };
  };

  /**
   * @function generateButtonsBlock
   * @description Generates the buttons.
   * @param {string} id
   * @param {string} name
   * @param {string} eventPrefix
   * @param {JSON} buttons_config
   * @param {string} button_position
   * @param {string} button_direction
   * @param {object} actionHandler
   *                 actionHandler.next         - callback for next action
   *                 actionHandler.cancel       - callback for cancel action
   *                 actionHandler.complete     - callback for complete action
   *                 actionHandler._isCancelled - To be set when cancel action is performed
   *                 actionHandler.action       - Indicates what type of action is performed
   *
   * @returns {HTMLElement} buttons container
   */

  var generateButtonsBlock = function generateButtonsBlock(id, name) {
    var stepper = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var eventPrefix = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : EVENT_PREFIX.INAPP;
    var buttons_config = arguments.length > 4 ? arguments[4] : undefined;
    var button_direction = arguments.length > 5 ? arguments[5] : undefined;
    var button_alignment = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : "center";
    var position = arguments.length > 7 ? arguments[7] : undefined;
    var actionHandler = arguments.length > 8 ? arguments[8] : undefined;
    var isWalkthrough = arguments.length > 9 ? arguments[9] : undefined;
    var uis = arguments.length > 10 && arguments[10] !== undefined ? arguments[10] : {};
    var index = arguments.length > 11 ? arguments[11] : undefined;
    var buttons = document.createElement("div");
    buttons.className = "".concat(position, "-buttons-container");
    buttons.style.zIndex = 99999999;
    var _generateButtonsFromC = generateButtonsFromConfig(buttons_config, actionHandler, id, name, eventPrefix, position, isWalkthrough, uis, index),
      buttons_array = _generateButtonsFromC.buttons_array,
      buttons_css = _generateButtonsFromC.buttons_css;
    var buttonsStyle = document.createElement("style");
    buttonsStyle.innerHTML = getButtonsCSSFromConfig(stepper, buttons_css, button_direction, button_alignment, position);
    buttons.appendChild(buttonsStyle);
    buttons_array.forEach(function (button_data) {
      var classes = button_data.classes,
        type = button_data.type,
        sub_type = button_data.sub_type,
        text = button_data.text,
        action = button_data.action,
        _action = button_data._action;
      var buttonDiv = document.createElement("div");
      buttonDiv.setAttribute("id", "apxor-".concat(position, "-").concat(_action, "-button"));
      buttonDiv.className = "button-div " + classes;
      if (type === "stepper") {
        var carousel = document.createElement("div");
        carousel.className = type + "-" + sub_type;
        carousel.innerHTML = setCarousel(sub_type, stepper);
        buttonDiv.appendChild(carousel);
      } else {
        var newButton = document.createElement("button");
        newButton.className = classes;
        newButton.innerHTML = text;
        buttonDiv.appendChild(newButton);
        buttonDiv.onclick = function () {
          return action();
        };
      }
      buttons.appendChild(buttonDiv);
    });
    return buttons;
  };
  var setCarousel = function setCarousel(sub_type) {
    var stepper = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    if (sub_type === CAROUSEL_TYPE.NUMBER && stepper.enable_numbered) {
      var numbered = stepper.numbered;
      if (stepper.index <= stepper.length) {
        if (numbered.style === "number") {
          return "".concat(stepper.index, "/").concat(stepper.length);
        } else if (numbered.style === "number_of") {
          return "".concat(stepper.index, " of ").concat(stepper.length);
        } else if (numbered.style === "step_number") {
          return "Step ".concat(stepper.index, "/").concat(stepper.length);
        } else {
          return "Step ".concat(stepper.index, " of ").concat(stepper.length);
        }
      }
    } else if (sub_type === CAROUSEL_TYPE.CAROUSEL && stepper.enable_pagination) {
      var carousel = stepper.carousel;
      if (stepper.index <= stepper.length) return createCarousel(stepper, carousel);
    } else {
      if (sub_type === "slash") {
        return "".concat(stepper.index, " / ").concat(stepper.length);
      } else if (sub_type === "question_slash") {
        return "".concat(stepper.pagination_text.text, " ").concat(stepper.index, " / ").concat(stepper.length, " ");
      } else if (sub_type === "question_of") {
        return "".concat(stepper.pagination_text.text, " ").concat(stepper.index, " of ").concat(stepper.length, " ");
      } else {
        return "".concat(stepper.index, " of ").concat(stepper.length);
      }
    }
    return "";
  };
  function createCarousel() {
    var stepper = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var carousel = arguments.length > 1 ? arguments[1] : undefined;
    var carouselContainer = document.createElement("div");
    carouselContainer.setAttribute("class", "carousel-container");
    var carouselContainerStyle = document.createElement("style");
    var narrow_width = parseInt(carousel.active_radius) * 2;
    carouselContainerStyle.innerHTML = ".carousel-container{\n    display:flex;\n    flex-direction:row;\n    padding-left:8px;\n    gap:".concat(carousel.spacebetween, ";\n    align-items:center;\n  }\n  .carousel-indicator-inactive{\n  height: ").concat(carousel.inactive_radius, ";\n  width: ").concat(carousel.inactive_radius, ";\n  background-color: ").concat(carousel.inactive_color, ";\n  border-radius: 50%;\n  display: inline-block;\n  }\n  .carousel-indicator-active-default{\n    height: ").concat(carousel.inactive_radius, ";\n    width: ").concat(carousel.inactive_radius, ";\n    background-color: ").concat(carousel.active_color, ";\n    border-radius: 50%;\n    display: inline-block;\n  }\n  .carousel-indicator-active-narrow\n  {\n    height: ").concat(carousel.inactive_radius, ";\n    width: ").concat(narrow_width, "px;\n    border-radius:").concat(carousel.inactive_radius, ";\n    background-color: ").concat(carousel.active_color, ";\n    display: inline-block;\n  }\n  .carousel-indicator-active-circle\n  {\n    height: ").concat(carousel.active_radius, ";\n    width: ").concat(carousel.active_radius, ";\n    background-color: ").concat(carousel.active_color, ";\n    border-radius: 50%;\n    display: inline-block;\n  }\n\n  ");
    carouselContainer.appendChild(carouselContainerStyle);
    for (var stepCount = 0; stepCount <= stepper.length; stepCount++) {
      var carouselIndictor = document.createElement("div");
      stepCount === stepper.index ? carouselIndictor.setAttribute("class", "carousel-indicator-active-".concat(carousel.style)) : carouselIndictor.setAttribute("class", "carousel-indicator-inactive");
      carouselContainer.appendChild(carouselIndictor);
    }
    return carouselContainer.outerHTML.toString();
  }
  var generateFormField = function generateFormField(form_element) {
    var _form_element$name$, _form_element$name, _form_element$placeho, _form_element$placeho2, _form_element$name$2, _form_element$name2, _form_element$placeho3, _form_element$placeho4, _form_element$name3, _form_element$placeho5, _form_element$name4, _form_element$placeho6, _form_element$name5, _form_element$placeho7, _form_element$name6, _form_element$name7, _form_element$placeho8, _form_element$value;
    switch (form_element.type) {
      case "fullname":
        return "\n      <div class=\"mainName\" style=\"padding: 8px; display: flex;gap :8px\" >\n        <div class=\"first\" style=\"width:50%\">\n          ".concat(form_element.name ? "<label for=\"fname\" style=\"line-height:1.5;\">".concat((_form_element$name$ = form_element === null || form_element === void 0 || (_form_element$name = form_element.name) === null || _form_element$name === void 0 ? void 0 : _form_element$name[0]) !== null && _form_element$name$ !== void 0 ? _form_element$name$ : " ", "</label><br />") : "", "\n          <input type=\"text\" id=\"fname\" placeholder=\"").concat((_form_element$placeho = form_element === null || form_element === void 0 || (_form_element$placeho2 = form_element.placeholder) === null || _form_element$placeho2 === void 0 ? void 0 : _form_element$placeho2[0]) !== null && _form_element$placeho !== void 0 ? _form_element$placeho : " ", "\" style=\"width: 90%;border-radius: 5px;padding: 8px;\"/>\n        </div>\n        <div class=\"first\" style=\"width:50%\">\n          ").concat(form_element.name ? "<label for=\"fname\" style=\"line-height:1.5;\">".concat((_form_element$name$2 = form_element === null || form_element === void 0 || (_form_element$name2 = form_element.name) === null || _form_element$name2 === void 0 ? void 0 : _form_element$name2[1]) !== null && _form_element$name$2 !== void 0 ? _form_element$name$2 : " ", "</label><br />") : "", "\n        <input type=\"text\" id=\"lname\" placeholder=\"").concat((_form_element$placeho3 = form_element === null || form_element === void 0 || (_form_element$placeho4 = form_element.placeholder) === null || _form_element$placeho4 === void 0 ? void 0 : _form_element$placeho4[1]) !== null && _form_element$placeho3 !== void 0 ? _form_element$placeho3 : " ", "\" style=\"width: 90%;border-radius: 5px;padding: 8px;\"/>\n        </div>\n      </div>");
      case "name":
        return "\n      <div class=\"mainFullName\" style=\"width:100%;padding: 8px;box-sizing: border-box;\">\n        ".concat(form_element.name ? "<label for=\"name\" style=\"line-height:1.5;\">".concat((_form_element$name3 = form_element === null || form_element === void 0 ? void 0 : form_element.name) !== null && _form_element$name3 !== void 0 ? _form_element$name3 : " ", "</label><br />") : "", "\n        <input type=\"text\" id=\"name\" placeholder=\"").concat((_form_element$placeho5 = form_element === null || form_element === void 0 ? void 0 : form_element.placeholder) !== null && _form_element$placeho5 !== void 0 ? _form_element$placeho5 : " ", "\" style=\"width: 95%;border-radius: 5px;padding: 8px;\"/>\n      </div>");
      case "email":
        return "\n      <div class=\"mainEmail\" style=\"width:100%;padding: 8px;box-sizing: border-box;\">\n      ".concat(form_element.name ? "<label for=\"email\" style=\"line-height:1.5;\">".concat((_form_element$name4 = form_element === null || form_element === void 0 ? void 0 : form_element.name) !== null && _form_element$name4 !== void 0 ? _form_element$name4 : " ", "</label><br />") : "", "\n        <input type=\"email\" id=\"email\" placeholder=\"").concat((_form_element$placeho6 = form_element === null || form_element === void 0 ? void 0 : form_element.placeholder) !== null && _form_element$placeho6 !== void 0 ? _form_element$placeho6 : " ", "\" style=\"width: 95%;border-radius: 5px;padding: 8px;\n      \"/>\n      </div>");
      case "phone":
        return "\n      <div class=\"mainPhoneNumber\" style=\"width:100%;padding: 8px;box-sizing: border-box;\">\n      ".concat(form_element.name ? "<label for=\"phoneNumber\" style=\"line-height:1.5;\">".concat((_form_element$name5 = form_element === null || form_element === void 0 ? void 0 : form_element.name) !== null && _form_element$name5 !== void 0 ? _form_element$name5 : " ", "</label><br />") : "", "<input type=\"tel\" id=\"phoneNumber\" placeholder=\"").concat((_form_element$placeho7 = form_element === null || form_element === void 0 ? void 0 : form_element.placeholder) !== null && _form_element$placeho7 !== void 0 ? _form_element$placeho7 : " ", "\" style=\"width: 95%;border-radius: 5px;padding: 8px;\n      \"/>\n      </div>");
      case "date":
        return "\n        <div class=\"mainDate\" style=\"width:100%;padding: 8px;box-sizing: border-box;\">\n        ".concat(form_element.name ? "<label for=\"date\" style=\"line-height:1.5;\">".concat((_form_element$name6 = form_element === null || form_element === void 0 ? void 0 : form_element.name) !== null && _form_element$name6 !== void 0 ? _form_element$name6 : " ", "</label><br />") : "", "\n          <input type=\"date\" id=\"date\" style=\"width:95%;border-radius:5px;padding:8px;\"/>\n        </div>");
      case "message":
        return "\n      <div class=\"mainTextField\" style=\"width:100%;padding: 8px;box-sizing: border-box;\">\n      ".concat(form_element.name ? "<label for=\"textField\" style=\"line-height:1.5;\">".concat((_form_element$name7 = form_element === null || form_element === void 0 ? void 0 : form_element.name) !== null && _form_element$name7 !== void 0 ? _form_element$name7 : " ", "</label><br />") : "", "\n      <textarea id=\"textField\" placeholder=\"").concat((_form_element$placeho8 = form_element === null || form_element === void 0 ? void 0 : form_element.placeholder) !== null && _form_element$placeho8 !== void 0 ? _form_element$placeho8 : " ", "\" style=\"width: 95%;border-radius: 5px;padding: 8px;\"></textarea>\n      </div>");
      case "button":
        return "\n      <div class=\"buttonClass\" style=\"width:100%;padding: 8px;box-sizing: border-box;\">\n        <input type=\"submit\" value=\"".concat((_form_element$value = form_element === null || form_element === void 0 ? void 0 : form_element.value) !== null && _form_element$value !== void 0 ? _form_element$value : " ", "\" style=\"max-width:99%;width:100%;border-radius:5px;padding:8px;\">\n      </div>\n      ");
      default:
        return;
    }
  };

  /**
   * @function getPIPSVG
   * @description Returns the SVG element of the PIP button.
   * @param {number} width
   * @param {number} height
   * @param {string} color
   * @returns {HTMLElement}
   */
  var getPIPSVG = function getPIPSVG() {
    var width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 24;
    var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 24;
    var color = arguments.length > 2 ? arguments[2] : undefined;
    var pipSVG = "\n  <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"".concat(width, "\" height=\"").concat(height, "\" fill=").concat(color, " class=\"bi bi-pip\" viewBox=\"0 0 16 16\">\n    <path d=\"M0 3.5A1.5 1.5 0 0 1 1.5 2h13A1.5 1.5 0 0 1 16 3.5v9a1.5 1.5 0 0 1-1.5 1.5h-13A1.5 1.5 0 0 1 0 12.5v-9zM1.5 3a.5.5 0 0 0-.5.5v9a.5.5 0 0 0 .5.5h13a.5.5 0 0 0 .5-.5v-9a.5.5 0 0 0-.5-.5h-13z\"/>\n    <path d=\"M8 8.5a.5.5 0 0 1 .5-.5h5a.5.5 0 0 1 .5.5v3a.5.5 0 0 1-.5.5h-5a.5.5 0 0 1-.5-.5v-3z\"/>\n  </svg>");
    return pipSVG;
  };

  /**
   * @function getCloseWithCircleSVG
   * @description Returns the SVG element of the close button with a circle background.
   * @param {number} width
   * @param {number} height
   * @param {string} fillColor
   * @param {string} strokeColor
   * @returns {HTMLElement}
   */
  var getCloseWithCircleSVG = function getCloseWithCircleSVG() {
    var width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 24;
    var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 24;
    var fillColor = arguments.length > 2 ? arguments[2] : undefined;
    var strokeColor = arguments.length > 3 ? arguments[3] : undefined;
    var closeSVG = "<svg viewBox=\"0 0 24 24\" fill=\"none\" width=\"".concat(width, "\" height=\"").concat(height, "\" xmlns=\"http://www.w3.org/2000/svg\">\n  <path d=\"M12 22C17.5228 22 22 17.5228 22 12C22 6.47715 17.5228 2 12 2C6.47715 2 2 6.47715 2 12C2 17.5228 6.47715 22 12 22Z\" fill=\"").concat(fillColor, "\"></path>\n  <path d=\"M13.0594 12.0001L15.3594 9.70011C15.6494 9.41011 15.6494 8.93011 15.3594 8.64011C15.0694 8.35011 14.5894 8.35011 14.2994 8.64011L11.9994 10.9401L9.69937 8.64011C9.40937 8.35011 8.92937 8.35011 8.63938 8.64011C8.34938 8.93011 8.34938 9.41011 8.63938 9.70011L10.9394 12.0001L8.63938 14.3001C8.34938 14.5901 8.34938 15.0701 8.63938 15.3601C8.78938 15.5101 8.97937 15.5801 9.16937 15.5801C9.35937 15.5801 9.54937 15.5101 9.69937 15.3601L11.9994 13.0601L14.2994 15.3601C14.4494 15.5101 14.6394 15.5801 14.8294 15.5801C15.0194 15.5801 15.2094 15.5101 15.3594 15.3601C15.6494 15.0701 15.6494 14.5901 15.3594 14.3001L13.0594 12.0001Z\" fill=\"").concat(strokeColor, "\"></path>\n  </svg>");
    return closeSVG;
  };

  /**
   * @function getCloseWithRectangleSVG
   * @description Returns the SVG element of the close button with a rectangular background.
   * @param {number} width
   * @param {number} height
   * @param {string} fillColor
   * @param {string} strokeColor
   * @returns {HTMLElement}
   */
  var getCloseWithRectangleSVG = function getCloseWithRectangleSVG() {
    var width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 24;
    var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 24;
    var fillColor = arguments.length > 2 ? arguments[2] : undefined;
    var strokeColor = arguments.length > 3 ? arguments[3] : undefined;
    var closeSVG = "\n  <svg viewBox=\"0 0 24 24\" fill=\"currentColor\" style=\"background-color:".concat(fillColor, ";color:").concat(strokeColor, ";\" width=\"").concat(width, "\" height=\"").concat(height, "\">\n    <path d=\"M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z\"></path>\n  </svg>\n  ");
    return closeSVG;
  };
  var getFilledBackArrowSvg = function getFilledBackArrowSvg() {
    var width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 24;
    var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 24;
    var color = arguments.length > 2 ? arguments[2] : undefined;
    var backSVG = "<svg fill=\"".concat(color, "\" height=\"").concat(height, "\" width=\"").concat(width, "\" version=\"1.1\" id=\"Layer_1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" viewBox=\"0 0 512 512\" xml:space=\"preserve\" stroke=\"#c43131\"><g id=\"SVGRepo_bgCarrier\" stroke-width=\"0\"></g><g id=\"SVGRepo_tracerCarrier\" stroke-linecap=\"round\" stroke-linejoin=\"round\"></g><g id=\"SVGRepo_iconCarrier\"> <g> <g> <path d=\"M0,0v512h512V0H0z M384,277.333H179.499l48.917,48.917c8.341,8.341,8.341,21.824,0,30.165 c-4.16,4.16-9.621,6.251-15.083,6.251c-5.461,0-10.923-2.091-15.083-6.251l-85.333-85.333c-1.963-1.963-3.52-4.309-4.608-6.933 c-2.155-5.205-2.155-11.093,0-16.299c1.088-2.624,2.645-4.971,4.608-6.933l85.333-85.333c8.341-8.341,21.824-8.341,30.165,0 s8.341,21.824,0,30.165l-48.917,48.917H384c11.776,0,21.333,9.557,21.333,21.333S395.776,277.333,384,277.333z\"></path> </g> </g> </g></svg>");
    return backSVG;
  };

  /**
   * @function getCloseSVG
   * @description Returns the SVG element of the close button.
   * @param {number} width
   * @param {number} height
   * @param {string} color
   * @returns {HTMLElement}
   */
  var getCloseSVG = function getCloseSVG() {
    var width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 24;
    var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 24;
    var color = arguments.length > 2 ? arguments[2] : undefined;
    var closeSVG = "\n  <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"".concat(width, "\" height=\"").concat(height, "\" fill=").concat(color, " class=\"bi bi-x\" viewBox=\"0 0 24 24\" aria-hidden=\"true\">\n    <path d=\"M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z\"></path>\n  </svg>");
    return closeSVG;
  };
  var getBackSVG = function getBackSVG() {
    var width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 24;
    var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 24;
    var color = arguments.length > 2 ? arguments[2] : undefined;
    var backSVG = "\n  <svg width=\"".concat(width, "\" height=\"").concat(height, "\" viewBox=\"0 0 19 17\" fill=").concat(color, " xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M19 7.4375H3.97961L9.78797 1.49812L8.3125 0L0 8.5L8.3125 17L9.77758 15.5019L3.97961 9.5625H19V7.4375Z\" fill=\"").concat(color, "\"/>\n</svg> ");
    return backSVG;
  };

  /**
   * @function addClickListenerForFlutterElement
   * @description attaches click listener to the rect and if the click is within the rect,closecallback(onclick callback) is called which stops nudge from being shown.
   * @param {element}element -target element
   */
  var addClickListenerForFlutterElement = function addClickListenerForFlutterElement(element, clickCallback) {
    window.addEventListener("resize", window.ApxorRTM.removeAll);
    var rect = element.getBoundingClientRect();
    var clickCallbackWrapper = function clickCallbackWrapper(event) {
      var touchX = event.clientX;
      var touchY = event.clientY;
      if (touchX > rect.left && touchX < rect.right && touchY > rect.top && touchY < rect.bottom) {
        clickCallback();
        document.body.removeEventListener("click", clickCallbackWrapper);
      }
    };
    document.body.addEventListener("click", clickCallbackWrapper);
    return clickCallbackWrapper;
  };

  /**
   * @function getElementPositionFromFlutter
   * @description gets the position of the particular view id given.
   * @param {string} viewId -view Id or path
   */

  var getElementPositionFromFlutter = function getElementPositionFromFlutter(viewId) {
    var helper = Apxor.getApxorFlutterHelper();
    var response = helper.find(viewId);
    return response.r;
  };

  /**
   * @function createTargetView
   * @description creates a dummy target view with given top,left,bottom,right positions on which nudge is shown .
   * @param {Object} viewRect -Bounds of target view
   */
  var createTargetView = function createTargetView(viewRect) {
    if (!viewRect) return null;
    if ((viewRect === null || viewRect === void 0 ? void 0 : viewRect.st) == false) return null;
    if (viewRect.l === 0 && viewRect.t === 0 && viewRect.r === 0 && viewRect.b === 0) return null;
    var divElement = document.createElement("div");
    divElement.style.position = "absolute";
    divElement.style.height = String(viewRect.b - viewRect.t) + "px";
    divElement.style.width = String(viewRect.r - viewRect.l) + "px";
    divElement.style.left = String(viewRect.l) + "px";
    divElement.style.top = String(viewRect.t) + "px";
    divElement.style.zIndex = -99999;
    document.body.appendChild(divElement);
    return divElement;
  };
  /**
   * @function getElementFromSelector
   * @description Finds the element in DOM for a given selector. Selector can be an ID, or any css selector. It can also be an XPath.
   * @param {string} selector
   * @returns {HTMLElement} Returns the HTML element that matches the given selector
   */
  var getElementFromSelector = function getElementFromSelector(selector) {
    var iframe_id = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
    // Given selector can be an ID.
    var element = document.getElementById(selector);
    if (!element) {
      try {
        element = document.querySelector(selector);
      } catch (e) {
        //If there is an exception, it means it is not a valid selector.
        window.ApxorLogger.error("Error finding element in DOM:" + e);
      }
    }
    // If no element is found till now, it means it is neither an ID nor a valid css selector. It could be an XPath.
    if (!element) {
      element = getElementByXPath(selector);
    }

    // If no element is found, it means the selector is not an ID. It could be a css selector
    if (!element && iframe_id.length > 0) {
      var _document$getElementB;
      element = (_document$getElementB = document.getElementById(iframe_id)) === null || _document$getElementB === void 0 || (_document$getElementB = _document$getElementB.contentWindow) === null || _document$getElementB === void 0 || (_document$getElementB = _document$getElementB.document) === null || _document$getElementB === void 0 ? void 0 : _document$getElementB.querySelector(selector);
    }
    return element;
  };

  /**
   * @function isElementCovered
   * @description finds whether the target element is overlapped by any other element
   * @returns {boolean}
   */
  function isElementCovered(element) {
    var rect = element.getBoundingClientRect();
    var x = rect.left + rect.width / 2;
    var y = rect.top + rect.height / 2;
    var elementAtPoint = document.elementFromPoint(x, y);
    return element !== elementAtPoint;
  }

  /** @function getCheckMarkSVG
   * @description Returns the SVG element of the check mark.
   * @param {number} width
   * @param {number} height
   * @param {string} color
   * @returns {HTMLElement}
   */
  var getCheckMarkSVG = function getCheckMarkSVG() {
    var width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 64;
    var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 64;
    var color = arguments.length > 2 ? arguments[2] : undefined;
    var checkMarkSVG = "\n  <svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" viewBox=\"0,0,256,256\" width=".concat(width, " height=").concat(height, " fill-rule=\"nonzero\">\n    <g fill=\"none\" fill-rule=\"nonzero\" stroke=\"none\" stroke-width=\"none\" stroke-linecap=\"butt\" stroke-linejoin=\"miter\" stroke-miterlimit=\"10\" stroke-dasharray=\"\" stroke-dashoffset=\"0\" font-family=\"none\" font-weight=\"none\" font-size=\"none\" text-anchor=\"none\" style=\"mix-blend-mode: normal\">\n      <g transform=\"scale(6.4,6.4)\">\n        <path d=\"M20,38.5c-10.2,0 -18.5,-8.3 -18.5,-18.5c0,-10.2 8.3,-18.5 18.5,-18.5c10.2,0 18.5,8.3 18.5,18.5c0,10.2 -8.3,18.5 -18.5,18.5z\" fill= ").concat(color, " stroke=\"none\" stroke-width=\"1\"/>\n        <path d=\"M20,2c9.9,0 18,8.1 18,18c0,9.9 -8.1,18 -18,18c-9.9,0 -18,-8.1 -18,-18c0,-9.9 8.1,-18 18,-18M20,1c-10.5,0 -19,8.5 -19,19c0,10.5 8.5,19 19,19c10.5,0 19,-8.5 19,-19c0,-10.5 -8.5,-19 -19,-19z\" fill=\"#5e9c76\" stroke=\"none\" stroke-width=\"1\"/>\n        <path d=\"M11.2,20.1l5.8,5.8l13.2,-13.2\" fill=\"none\" stroke=").concat(COLORS.WHITE, " stroke-width=\"3\"/>\n      </g>\n    </g>\n  </svg>");
    return checkMarkSVG;
  };

  /**
   * Device (Only mobile devices)
   * @returns {string}
   */
  var getDevice = function getDevice() {
    var _window = window,
      _window$navigator = _window.navigator,
      _window$navigator2 = _window$navigator === void 0 ? {} : _window$navigator,
      _window$navigator2$us = _window$navigator2.userAgent,
      userAgent = _window$navigator2$us === void 0 ? "" : _window$navigator2$us;
    switch (true) {
      case /Windows Phone/i.test(userAgent) || /WPDesktop/.test(userAgent):
        return "Windows Phone";
      case /iPad/.test(userAgent):
        return "iPad";
      case /iPod/.test(userAgent):
        return "iPod Touch";
      case /iPhone/.test(userAgent):
        return "iPhone";
      case /(BlackBerry|PlayBook|BB10)/i.test(userAgent):
        return "BlackBerry";
      case /Android/.test(userAgent):
        return "Android";
      default:
        return "Desktop";
    }
  };
  var isIOSDevice = function isIOSDevice() {
    var device = getDevice();
    if (device === "iPad" || device === "iPod Touch" || device === "iPhone") {
      return true;
    }
    return false;
  };

  /**
   * @function          getNumberOrDefault
   * @description       Returns the given input as Number. If its not a number returns the default value
   * @param   {any}     input
   * @param   {number}  def
   * @returns {number}
   */
  var getNumberOrDefault = function getNumberOrDefault(input, def) {
    var result = Number(input);
    if (result || result === 0) {
      return result;
    }
    return def;
  };
  var getSlotNumberByPosition = function getSlotNumberByPosition(position) {
    if (position === "left") return 1;else if (position === "center") return 3;else return 5;
  };

  /**
   * @function            getBooleanOrDefault
   * @description         Returns the given boolean. If not returns the def boolean
   * @param   {any}       input
   * @param   {boolean}   def
   * @returns {boolean}
   */
  var getBooleanOrDefault = function getBooleanOrDefault(input, def) {
    var result = Boolean(input);
    if (result) {
      return result;
    }
    return def;
  };

  /**
   * @function            getStringOrDefault
   * @description         Returns the given string. If its empty returns the default string
   * @param   {any}       input
   * @param   {string}    def
   * @returns {string}
   */
  var getStringOrDefault = function getStringOrDefault() {
    var input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
    var def = arguments.length > 1 ? arguments[1] : undefined;
    var result = String(input);
    if (result) {
      return result;
    }
    return def;
  };

  /**
   * @function            getColorOrDefault
   * @description         Returns the given color. If its empty returns the default color
   * @param   {string}    input
   * @param   {string}    def
   * @returns {string}
   */
  var getColorOrDefault = function getColorOrDefault(input, def) {
    if (!input) {
      return def;
    }
    var result = String(input);
    if (result) {
      return result;
    }
    return def;
  };

  /**
   * @function            getArrayOrDefault
   * @description         Returns the given Array. If its empty or not an array returns the default array
   * @param   {any}    input
   * @param   {Array}    def
   * @returns {Array}
   */
  var getArrayOrDefault = function getArrayOrDefault(input, def) {
    if (input && Array.isArray(input)) {
      return input;
    }
    return def;
  };
  var isEmptyObject = function isEmptyObject(obj) {
    if (_typeof$1(obj) !== "object") {
      return true;
    }
    return Object.keys(obj).length === 0;
  };

  /**
   * @function getFontFormatFromCustomFontURL
   * @description Returns the font format type
   * @param {string} url
   * @returns {string}
   */
  var getFontFormatFromCustomFontURL = function getFontFormatFromCustomFontURL(url) {
    var fileExtension = url.split(".").pop();
    var fontFormatMap = {
      woff: "woff",
      woff2: "woff2",
      ttf: "truetype",
      otf: "opentype",
      eot: "embedded-opentype",
      svg: "svg"
    };
    if (Object.hasOwn(fontFormatMap, fileExtension)) {
      return fontFormatMap[fileExtension];
    } else {
      return "unknown format";
    }
  };
  var convertTheDirectionCode = function convertTheDirectionCode() {
    var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
    switch (value) {
      case "H":
        return "horizontal";
      case "V":
        return "vertical";
      default:
        return value;
    }
  };
  var convertThePositionCode = function convertThePositionCode() {
    var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
    switch (value) {
      case "TL":
        return "top-left";
      case "TC":
      case "T":
        return "top-center";
      case "TR":
        return "top-right";
      case "L":
        return "left";
      case "C":
        return "center";
      case "R":
        return "right";
      case "BL":
        return "bottom-left";
      case "BC":
      case "B":
        return "bottom-center";
      case "BR":
        return "bottom-right";
      default:
        return value;
    }
  };

  /* eslint-disable no-unused-vars */
  /* eslint-disable no-useless-escape */
  /* eslint-disable no-empty */
  /* eslint-disable no-unsafe-finally */
  /* eslint-disable no-func-assign */
  /*! shepherd.js 4.0.0-beta.1 */

  function _typeof(obj) {
    if (typeof Symbol === "function" && _typeof$1(Symbol.iterator) === "symbol") {
      _typeof = function _typeof(obj) {
        return _typeof$1(obj);
      };
    } else {
      _typeof = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof$1(obj);
      };
    }
    return _typeof(obj);
  }
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }
  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _extends() {
    _extends = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends.apply(this, arguments);
  }
  function _objectSpread2(target) {
    for (var i = 1; i < arguments.length; i++) {
      if (i % 2) {
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
          ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
            return Object.getOwnPropertyDescriptor(source, sym).enumerable;
          }));
        }
        ownKeys.forEach(function (key) {
          _defineProperty(target, key, source[key]);
        });
      } else {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(arguments[i]));
      }
    }
    return target;
  }
  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }
  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }
  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };
    return _setPrototypeOf(o, p);
  }
  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
  }
  function _possibleConstructorReturn(self, call) {
    if (call && (_typeof$1(call) === "object" || typeof call === "function")) {
      return call;
    }
    return _assertThisInitialized(self);
  }
  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
  }
  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }
  function _iterableToArrayLimit(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;
    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);
        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }
    return _arr;
  }
  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance");
  }

  /**
   * Checks if `value` is classified as an `HTMLElement`.
   * @param {*} value The param to check if it is an HTMLElement
   */
  function isElement$2(value) {
    return value instanceof HTMLElement;
  }
  /**
   * Checks if `value` is classified as a `Function` object.
   * @param {*} value The param to check if it is a function
   */

  function isFunction(value) {
    return typeof value === "function";
  }
  /**
   * Checks if `value` is classified as a `Number` object.
   * @param {*} value The param to check if it is a number
   */

  function isNumber(value) {
    return typeof value === "number";
  }
  /**
   * Checks if `value` is classified as a `String` object.
   * @param {*} value The param to check if it is a string
   */

  function isString(value) {
    return typeof value === "string";
  }
  /**
   * Checks if `value` is undefined.
   * @param {*} value The param to check if it is undefined
   */

  function isUndefined(value) {
    return value === undefined;
  }

  /**!
   * tippy.js v5.0.0-alpha.2
   * (c) 2017-2019 atomiks
   * MIT License
   */
  function _extends$1() {
    _extends$1 = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends$1.apply(this, arguments);
  }
  var isBrowser$1 = typeof window !== "undefined" && typeof document !== "undefined";
  var ua = isBrowser$1 ? navigator.userAgent : "";
  var isIE = /MSIE |Trident\//.test(ua);
  var isUCBrowser = /UCBrowser\//.test(ua);
  var isIOS = isBrowser$1 && /iPhone|iPad|iPod/.test(navigator.platform);
  var defaultProps$1 = {
    allowHTML: true,
    animateFill: false,
    animation: "fade",
    appendTo: function appendTo() {
      return document.body;
    },
    aria: "describedby",
    arrow: true,
    boundary: "scrollParent",
    content: "",
    delay: 0,
    distance: 10,
    duration: [325, 275],
    flip: true,
    flipBehavior: "flip",
    flipOnUpdate: false,
    hideOnClick: true,
    ignoreAttributes: false,
    inertia: false,
    interactive: false,
    interactiveBorder: 2,
    interactiveDebounce: 0,
    lazy: true,
    maxWidth: 350,
    multiple: false,
    offset: 0,
    onCreate: function onCreate() {},
    onHidden: function onHidden() {},
    onHide: function onHide() {},
    onMount: function onMount() {},
    onShow: function onShow() {},
    onShown: function onShown() {},
    onTrigger: function onTrigger() {},
    onUntrigger: function onUntrigger() {},
    placement: "top",
    popperOptions: {},
    role: "tooltip",
    showOnCreate: false,
    sticky: false,
    theme: "",
    touch: true,
    trigger: "mouseenter focus",
    triggerTarget: null,
    updateDuration: 0,
    wait: null,
    zIndex: 9999
  };
  var POPPER_INSTANCE_DEPENDENCIES = ["arrow", "boundary", "distance", "flip", "flipBehavior", "flipOnUpdate", "offset", "placement", "popperOptions"];
  var PASSIVE = {
    passive: true
  };
  var PREVENT_OVERFLOW_PADDING = 5;
  var ROUND_ARROW_INNER_HTML = '<svg viewBox="0 0 18 7" xmlns="http://www.w3.org/2000/svg"><path d="M0 7s2.021-.015 5.253-4.218C6.584 1.051 7.797.007 9 0c1.203-.007 2.416 1.035 3.761 2.782C16.012 7.005 18 7 18 7H0z"/></svg>';
  var IOS_CLASS = "tippy-iOS";
  var POPPER_CLASS = "tippy-popper";
  var TOOLTIP_CLASS = "tippy-tooltip";
  var CONTENT_CLASS$1 = "tippy-content";
  var BACKDROP_CLASS$1 = "tippy-backdrop";
  var ARROW_CLASS$1 = "tippy-arrow";
  var SVG_ARROW_CLASS$1 = "tippy-svg-arrow";
  var POPPER_SELECTOR = "." + POPPER_CLASS;
  var TOOLTIP_SELECTOR = "." + TOOLTIP_CLASS;
  var CONTENT_SELECTOR = "." + CONTENT_CLASS$1;
  var BACKDROP_SELECTOR = "." + BACKDROP_CLASS$1;
  var ARROW_SELECTOR = "." + ARROW_CLASS$1;
  var SVG_ARROW_SELECTOR = "." + SVG_ARROW_CLASS$1;
  var currentInput$1 = {
    isTouch: false
  };
  var lastMouseMoveTime$1 = 0;
  /**
   * When a `touchstart` event is fired, it's assumed the user is using touch
   * input. We'll bind a `mousemove` event listener to listen for mouse input in
   * the future. This way, the `isTouch` property is fully dynamic and will handle
   * hybrid devices that use a mix of touch + mouse input.
   */

  function onDocumentTouchStart$1() {
    if (currentInput$1.isTouch) {
      return;
    }
    currentInput$1.isTouch = true;
    if (isIOS) {
      document.body.classList.add(IOS_CLASS);
    }
    if (window.performance) {
      document.addEventListener("mousemove", onDocumentMouseMove$1);
    }
  }
  /**
   * When two `mousemove` event are fired consecutively within 20ms, it's assumed
   * the user is using mouse input again. `mousemove` can fire on touch devices as
   * well, but very rarely that quickly.
   */

  function onDocumentMouseMove$1() {
    var now = performance.now();
    if (now - lastMouseMoveTime$1 < 20) {
      currentInput$1.isTouch = false;
      document.removeEventListener("mousemove", onDocumentMouseMove$1);
      if (!isIOS) {
        document.body.classList.remove(IOS_CLASS);
      }
    }
    lastMouseMoveTime$1 = now;
  }
  /**
   * When an element is in focus and has a tippy, leaving the tab/window and
   * returning causes it to show again. For mouse users this is unexpected, but
   * for keyboard use it makes sense.
   * TODO: find a better technique to solve this problem
   */

  function onWindowBlur$1() {
    var _document = document,
      activeElement = _document.activeElement;
    var instance = activeElement._tippy;
    if (activeElement && activeElement.blur && instance && !instance.state.isVisible) {
      activeElement.blur();
    }
  }
  /**
   * Adds the needed global event listeners
   */

  function bindGlobalEventListeners$1() {
    document.addEventListener("touchstart", onDocumentTouchStart$1, _extends$1({}, PASSIVE, {
      capture: true
    }));
    window.addEventListener("blur", onWindowBlur$1);
  }
  var keys = Object.keys(defaultProps$1);
  /**
   * Returns an object of optional props from data-tippy-* attributes
   */

  function getDataAttributeProps$1(reference) {
    var props = keys.reduce(function (acc, key) {
      var valueAsString = (reference.getAttribute("data-tippy-" + key) || "").trim();
      if (!valueAsString) {
        return acc;
      }
      if (key === "content") {
        acc[key] = valueAsString;
      } else {
        try {
          acc[key] = JSON.parse(valueAsString);
        } catch (e) {
          acc[key] = valueAsString;
        }
      }
      return acc;
    }, {});
    return props;
  }

  /**
   * Determines if the value is a reference element
   */

  function isReferenceElement$1(value) {
    return !!(value && value._tippy && !value.classList.contains(POPPER_CLASS));
  }
  /**
   * Safe .hasOwnProperty check, for prototype-less objects
   */

  function hasOwnProperty(obj, key) {
    return {}.hasOwnProperty.call(obj, key);
  }
  /**
   * Returns an array of elements based on the value
   */

  function getArrayOfElements$1(value) {
    if (isRealElement(value)) {
      return [value];
    }
    if (value instanceof NodeList) {
      return arrayFrom$1(value);
    }
    if (Array.isArray(value)) {
      return value;
    }
    try {
      return arrayFrom$1(document.querySelectorAll(value));
    } catch (e) {
      return [];
    }
  }
  /**
   * Returns a value at a given index depending on if it's an array or number
   */

  function getValue(value, index, defaultValue) {
    if (Array.isArray(value)) {
      var v = value[index];
      return v == null ? defaultValue : v;
    }
    return value;
  }
  /**
   * Prevents errors from being thrown while accessing nested modifier objects
   * in `popperOptions`
   */

  function getModifier(obj, key) {
    return obj && obj.modifiers && obj.modifiers[key];
  }
  /**
   * Determines if the value is a real element
   */

  function isRealElement(value) {
    return value instanceof Element;
  }
  /**
   * Firefox extensions don't allow setting .innerHTML directly, this will trick
   * it
   */

  function innerHTML$1() {
    return "innerHTML";
  }
  /**
   * Evaluates a function if one, or returns the value
   */

  function invokeWithArgsOrReturn$1(value, args) {
    return typeof value === "function" ? value.apply(null, args) : value;
  }
  /**
   * Sets a popperInstance `flip` modifier's enabled state
   */

  function setFlipModifierEnabled(modifiers, value) {
    modifiers.filter(function (m) {
      return m.name === "flip";
    })[0].enabled = value;
  }
  function setEscapeWithReference(modifiers, value) {
    modifiers.filter(function (m) {
      return m.name === "preventOverflow";
    })[0].escapeWithReference = value;
  }

  /**
   * Returns a new `div` element
   */

  function div$1() {
    return document.createElement("div");
  }
  /**
   * Applies a transition duration to a list of elements
   */

  function setTransitionDuration$1(els, value) {
    els.forEach(function (el) {
      if (el) {
        el.style.transitionDuration = value + "ms";
      }
    });
  }
  /**
   * Sets the visibility state to elements so they can begin to transition
   */

  function setVisibilityState$1(els, state) {
    els.forEach(function (el) {
      if (el) {
        el.setAttribute("data-state", state);
      }
    });
  }
  /**
   * Evaluates the props object by merging data attributes and disabling
   * conflicting props where necessary
   */

  function evaluateProps$1(reference, props) {
    var out = _extends$1({}, props, {
      content: invokeWithArgsOrReturn$1(props.content, [reference])
    }, props.ignoreAttributes ? {} : getDataAttributeProps$1(reference));
    if (out.animateFill) {
      out.arrow = false;
    }
    if (out.arrow || isUCBrowser) {
      out.animateFill = false;
    }
    return out;
  }
  /**
   * Debounce utility. To avoid bloating bundle size, we're only passing 1
   * argument here, a more generic function would pass all arguments. Only
   * `onMouseMove` uses this which takes the event object for now.
   */

  function debounce$2(fn, ms) {
    // Avoid wrapping in `setTimeout` if ms is 0 anyway
    if (ms === 0) {
      return fn;
    }
    var timeout;
    return function (arg) {
      clearTimeout(timeout);
      timeout = setTimeout(function () {
        fn(arg);
      }, ms);
    };
  }
  /**
   * Preserves the original function invocation when another function replaces it
   */

  function preserveInvocation(originalFn, currentFn, args) {
    if (originalFn && originalFn !== currentFn) {
      originalFn.apply(null, args);
    }
  }
  /**
   * Ponyfill for Array.from - converts iterable values to an array
   */

  function arrayFrom$1(value) {
    return [].slice.call(value);
  }
  /**
   * Works like Element.prototype.closest, but uses a callback instead
   */

  function closestCallback(element, callback) {
    while (element) {
      if (callback(element)) {
        return element;
      }
      element = element.parentElement;
    }
    return null;
  }
  /**
   * Determines if an array or string includes a value
   */

  function includes(a, b) {
    return a.indexOf(b) > -1;
  }

  /**
   * Sets the innerHTML of an element
   */

  function setInnerHTML(element, html) {
    element[innerHTML$1()] = isRealElement(html) ? html[innerHTML$1()] : html;
  }
  /**
   * Sets the content of a tooltip
   */

  function setContent$1(contentEl, props) {
    if (isRealElement(props.content)) {
      setInnerHTML(contentEl, "");
      contentEl.appendChild(props.content);
    } else if (typeof props.content !== "function") {
      var key = props.allowHTML ? "innerHTML" : "textContent";
      contentEl[key] = props.content;
    }
  }
  /**
   * Returns the child elements of a popper element
   */

  function getChildren$1(popper) {
    return {
      tooltip: popper.querySelector(TOOLTIP_SELECTOR),
      backdrop: popper.querySelector(BACKDROP_SELECTOR),
      content: popper.querySelector(CONTENT_SELECTOR),
      arrow: popper.querySelector(ARROW_SELECTOR) || popper.querySelector(SVG_ARROW_SELECTOR)
    };
  }
  /**
   * Adds `data-inertia` attribute
   */

  function addInertia(tooltip) {
    tooltip.setAttribute("data-inertia", "");
  }
  /**
   * Removes `data-inertia` attribute
   */

  function removeInertia(tooltip) {
    tooltip.removeAttribute("data-inertia");
  }
  /**
   * Creates an arrow element and returns it
   */

  function createArrowElement$1(arrow) {
    var arrowElement = div$1();
    if (arrow === true) {
      arrowElement.className = ARROW_CLASS$1;
    } else {
      arrowElement.className = SVG_ARROW_CLASS$1;
      if (isRealElement(arrow)) {
        arrowElement.appendChild(arrow);
      } else {
        setInnerHTML(arrowElement, arrow === "round" ? ROUND_ARROW_INNER_HTML : arrow);
      }
    }
    return arrowElement;
  }
  /**
   * Creates a backdrop element and returns it
   */

  function createBackdropElement(isVisible) {
    var backdrop = div$1();
    backdrop.className = BACKDROP_CLASS$1;
    backdrop.setAttribute("data-state", isVisible ? "visible" : "hidden");
    return backdrop;
  }
  /**
   * Adds interactive-related attributes
   */

  function addInteractive(tooltip) {
    tooltip.setAttribute("data-interactive", "");
  }
  /**
   * Removes interactive-related attributes
   */

  function removeInteractive(tooltip) {
    tooltip.removeAttribute("data-interactive");
  }
  /**
   * Add/remove transitionend listener from tooltip
   */

  function updateTransitionEndListener$1(tooltip, action, listener) {
    var eventName = isUCBrowser && document.body.style.webkitTransition !== undefined ? "webkitTransitionEnd" : "transitionend";
    tooltip[action + "EventListener"](eventName, listener);
  }
  /**
   * Returns the popper's placement, ignoring shifting (top-start, etc)
   */

  function getBasePlacement$2(placement) {
    return placement.split("-")[0];
  }
  /**
   * Triggers reflow
   */

  function reflow(popper) {
    void popper.offsetHeight;
  }
  /**
   * Adds/removes theme from tooltip's classList
   */

  function updateTheme(tooltip, action, theme) {
    theme.split(" ").forEach(function (name) {
      if (name) {
        tooltip.classList[action](name + "-theme");
      }
    });
  }
  /**
   * Constructs the popper element and returns it
   */

  function createPopperElement(id, props) {
    var popper = div$1();
    popper.className = POPPER_CLASS;
    popper.style.position = "absolute";
    popper.style.top = "0";
    popper.style.left = "0";
    var tooltip = div$1();
    tooltip.className = TOOLTIP_CLASS;
    tooltip.id = "tippy-" + id;
    tooltip.setAttribute("data-state", "hidden");
    tooltip.setAttribute("tabindex", "-1");
    updateTheme(tooltip, "add", props.theme);
    var content = div$1();
    content.className = CONTENT_CLASS$1;
    content.setAttribute("data-state", "hidden");
    if (props.interactive) {
      addInteractive(tooltip);
    }
    if (props.arrow) {
      tooltip.setAttribute("data-arrow", "");
      tooltip.appendChild(createArrowElement$1(props.arrow));
    }
    if (props.animateFill) {
      tooltip.appendChild(createBackdropElement(false));
      tooltip.setAttribute("data-animatefill", "");
    }
    if (props.inertia) {
      addInertia(tooltip);
    }
    setContent$1(content, props);
    tooltip.appendChild(content);
    popper.appendChild(tooltip);
    updatePopperElement(popper, props, props, false);
    return popper;
  }
  /**
   * Updates the popper element based on the new props
   */

  function updatePopperElement(popper, prevProps, nextProps, isVisible) {
    var _getChildren = getChildren$1(popper),
      tooltip = _getChildren.tooltip,
      content = _getChildren.content,
      backdrop = _getChildren.backdrop,
      arrow = _getChildren.arrow;
    popper.style.zIndex = "" + nextProps.zIndex;
    tooltip.setAttribute("data-animation", nextProps.animation);
    tooltip.style.maxWidth = nextProps.maxWidth + (typeof nextProps.maxWidth === "number" ? "px" : "");
    if (nextProps.role) {
      tooltip.setAttribute("role", nextProps.role);
    } else {
      tooltip.removeAttribute("role");
    }
    if (prevProps.content !== nextProps.content) {
      setContent$1(content, nextProps);
    } // animateFill

    if (!prevProps.animateFill && nextProps.animateFill) {
      tooltip.appendChild(createBackdropElement(isVisible));
      tooltip.setAttribute("data-animatefill", "");
    } else if (prevProps.animateFill && !nextProps.animateFill) {
      tooltip.removeChild(backdrop);
      tooltip.removeAttribute("data-animatefill");
    } // arrow

    if (!prevProps.arrow && nextProps.arrow) {
      // false to true
      tooltip.appendChild(createArrowElement$1(nextProps.arrow));
      tooltip.setAttribute("data-arrow", "");
    } else if (prevProps.arrow && !nextProps.arrow) {
      // true to false
      tooltip.removeChild(arrow);
      tooltip.removeAttribute("data-arrow");
    } else if (prevProps.arrow !== nextProps.arrow) {
      // true to 'round' or vice-versa
      tooltip.removeChild(arrow);
      tooltip.appendChild(createArrowElement$1(nextProps.arrow));
    } // interactive

    if (!prevProps.interactive && nextProps.interactive) {
      addInteractive(tooltip);
    } else if (prevProps.interactive && !nextProps.interactive) {
      removeInteractive(tooltip);
    } // inertia

    if (!prevProps.inertia && nextProps.inertia) {
      addInertia(tooltip);
    } else if (prevProps.inertia && !nextProps.inertia) {
      removeInertia(tooltip);
    } // theme

    if (prevProps.theme !== nextProps.theme) {
      updateTheme(tooltip, "remove", prevProps.theme);
      updateTheme(tooltip, "add", nextProps.theme);
    }
  }
  /**
   * Determines if the mouse cursor is outside of the popper's interactive border
   * region
   */

  function isCursorOutsideInteractiveBorder$1(popperPlacement, popperRect, event, props) {
    if (!popperPlacement) {
      return true;
    }
    var x = event.clientX,
      y = event.clientY;
    var interactiveBorder = props.interactiveBorder,
      distance = props.distance;
    var exceedsTop = popperRect.top - y > (popperPlacement === "top" ? interactiveBorder + distance : interactiveBorder);
    var exceedsBottom = y - popperRect.bottom > (popperPlacement === "bottom" ? interactiveBorder + distance : interactiveBorder);
    var exceedsLeft = popperRect.left - x > (popperPlacement === "left" ? interactiveBorder + distance : interactiveBorder);
    var exceedsRight = x - popperRect.right > (popperPlacement === "right" ? interactiveBorder + distance : interactiveBorder);
    return exceedsTop || exceedsBottom || exceedsLeft || exceedsRight;
  }

  /**!
   * @fileOverview Kickass library to create and place poppers near their reference elements.
   * @version 1.15.0
   * @license
   * Copyright (c) 2016 Federico Zivolo and contributors
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in all
   * copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
   * SOFTWARE.
   */
  var isBrowser$1$1 = typeof window !== "undefined" && typeof document !== "undefined";
  var longerTimeoutBrowsers = ["Edge", "Trident", "Firefox"];
  var timeoutDuration = 0;
  for (var i = 0; i < longerTimeoutBrowsers.length; i += 1) {
    if (isBrowser$1$1 && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {
      timeoutDuration = 1;
      break;
    }
  }
  function microtaskDebounce(fn) {
    var called = false;
    return function () {
      if (called) {
        return;
      }
      called = true;
      window.Promise.resolve().then(function () {
        called = false;
        fn();
      });
    };
  }
  function taskDebounce(fn) {
    var scheduled = false;
    return function () {
      if (!scheduled) {
        scheduled = true;
        setTimeout(function () {
          scheduled = false;
          fn();
        }, timeoutDuration);
      }
    };
  }
  var supportsMicroTasks = isBrowser$1$1 && window.Promise;

  /**
   * Create a debounced version of a method, that's asynchronously deferred
   * but called in the minimum time possible.
   *
   * @method
   * @memberof Popper.Utils
   * @argument {Function} fn
   * @returns {Function}
   */
  var debounce$1$1 = supportsMicroTasks ? microtaskDebounce : taskDebounce;

  /**
   * Check if the given variable is a function
   * @method
   * @memberof Popper.Utils
   * @argument {Any} functionToCheck - variable to check
   * @returns {Boolean} answer to: is a function?
   */
  function isFunction$1(functionToCheck) {
    var getType = {};
    return functionToCheck && getType.toString.call(functionToCheck) === "[object Function]";
  }

  /**
   * Get CSS computed property of the given element
   * @method
   * @memberof Popper.Utils
   * @argument {Eement} element
   * @argument {String} property
   */
  function getStyleComputedProperty(element, property) {
    if (element.nodeType !== 1) {
      return [];
    }
    // NOTE: 1 DOM access here
    var window = element.ownerDocument.defaultView;
    var css = window.getComputedStyle(element, null);
    return property ? css[property] : css;
  }

  /**
   * Returns the parentNode or the host of the element
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element
   * @returns {Element} parent
   */
  function getParentNode$1(element) {
    if (element.nodeName === "HTML") {
      return element;
    }
    return element.parentNode || element.host;
  }

  /**
   * Returns the scrolling parent of the given element
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element
   * @returns {Element} scroll parent
   */
  function getScrollParent$1(element) {
    // Return body, `getScroll` will take care to get the correct `scrollTop` from it
    if (!element) {
      return document.body;
    }
    switch (element.nodeName) {
      case "HTML":
      case "BODY":
        return element.ownerDocument.body;
      case "#document":
        return element.body;
    }

    // Firefox want us to check `-x` and `-y` variations as well

    var _getStyleComputedProp = getStyleComputedProperty(element),
      overflow = _getStyleComputedProp.overflow,
      overflowX = _getStyleComputedProp.overflowX,
      overflowY = _getStyleComputedProp.overflowY;
    if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {
      return element;
    }
    return getScrollParent$1(getParentNode$1(element));
  }
  var isIE11$1 = isBrowser$1$1 && !!(window.MSInputMethodContext && document.documentMode);
  var isIE10 = isBrowser$1$1 && /MSIE 10/.test(navigator.userAgent);

  /**
   * Determines if the browser is Internet Explorer
   * @method
   * @memberof Popper.Utils
   * @param {Number} version to check
   * @returns {Boolean} isIE
   */
  function isIE$1(version) {
    if (version === 11) {
      return isIE11$1;
    }
    if (version === 10) {
      return isIE10;
    }
    return isIE11$1 || isIE10;
  }

  /**
   * Returns the offset parent of the given element
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element
   * @returns {Element} offset parent
   */
  function getOffsetParent$1(element) {
    if (!element) {
      return document.documentElement;
    }
    var noOffsetParent = isIE$1(10) ? document.body : null;

    // NOTE: 1 DOM access here
    var offsetParent = element.offsetParent || null;
    // Skip hidden elements which don't have an offsetParent
    while (offsetParent === noOffsetParent && element.nextElementSibling) {
      offsetParent = (element = element.nextElementSibling).offsetParent;
    }
    var nodeName = offsetParent && offsetParent.nodeName;
    if (!nodeName || nodeName === "BODY" || nodeName === "HTML") {
      return element ? element.ownerDocument.documentElement : document.documentElement;
    }

    // .offsetParent will return the closest TH, TD or TABLE in case
    // no offsetParent is present, I hate this job...
    if (["TH", "TD", "TABLE"].indexOf(offsetParent.nodeName) !== -1 && getStyleComputedProperty(offsetParent, "position") === "static") {
      return getOffsetParent$1(offsetParent);
    }
    return offsetParent;
  }
  function isOffsetContainer(element) {
    var nodeName = element.nodeName;
    if (nodeName === "BODY") {
      return false;
    }
    return nodeName === "HTML" || getOffsetParent$1(element.firstElementChild) === element;
  }

  /**
   * Finds the root node (document, shadowDOM root) of the given element
   * @method
   * @memberof Popper.Utils
   * @argument {Element} node
   * @returns {Element} root node
   */
  function getRoot(node) {
    if (node.parentNode !== null) {
      return getRoot(node.parentNode);
    }
    return node;
  }

  /**
   * Finds the offset parent common to the two provided nodes
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element1
   * @argument {Element} element2
   * @returns {Element} common offset parent
   */
  function findCommonOffsetParent(element1, element2) {
    // This check is needed to avoid errors in case one of the elements isn't defined for any reason
    if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {
      return document.documentElement;
    }

    // Here we make sure to give as "start" the element that comes first in the DOM
    var order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;
    var start = order ? element1 : element2;
    var end = order ? element2 : element1;

    // Get common ancestor container
    var range = document.createRange();
    range.setStart(start, 0);
    range.setEnd(end, 0);
    var commonAncestorContainer = range.commonAncestorContainer;

    // Both nodes are inside #document

    if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start.contains(end)) {
      if (isOffsetContainer(commonAncestorContainer)) {
        return commonAncestorContainer;
      }
      return getOffsetParent$1(commonAncestorContainer);
    }

    // one of the nodes is inside shadowDOM, find which one
    var element1root = getRoot(element1);
    if (element1root.host) {
      return findCommonOffsetParent(element1root.host, element2);
    } else {
      return findCommonOffsetParent(element1, getRoot(element2).host);
    }
  }

  /**
   * Gets the scroll value of the given element in the given side (top and left)
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element
   * @argument {String} side `top` or `left`
   * @returns {number} amount of scrolled pixels
   */
  function getScroll(element) {
    var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "top";
    var upperSide = side === "top" ? "scrollTop" : "scrollLeft";
    var nodeName = element.nodeName;
    if (nodeName === "BODY" || nodeName === "HTML") {
      var html = element.ownerDocument.documentElement;
      var scrollingElement = element.ownerDocument.scrollingElement || html;
      return scrollingElement[upperSide];
    }
    return element[upperSide];
  }

  /*
   * Sum or subtract the element scroll values (left and top) from a given rect object
   * @method
   * @memberof Popper.Utils
   * @param {Object} rect - Rect object you want to change
   * @param {HTMLElement} element - The element from the function reads the scroll values
   * @param {Boolean} subtract - set to true if you want to subtract the scroll values
   * @return {Object} rect - The modifier rect object
   */
  function includeScroll(rect, element) {
    var subtract = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    var scrollTop = getScroll(element, "top");
    var scrollLeft = getScroll(element, "left");
    var modifier = subtract ? -1 : 1;
    rect.top += scrollTop * modifier;
    rect.bottom += scrollTop * modifier;
    rect.left += scrollLeft * modifier;
    rect.right += scrollLeft * modifier;
    return rect;
  }

  /*
   * Helper to detect borders of a given element
   * @method
   * @memberof Popper.Utils
   * @param {CSSStyleDeclaration} styles
   * Result of `getStyleComputedProperty` on the given element
   * @param {String} axis - `x` or `y`
   * @return {number} borders - The borders size of the given axis
   */

  function getBordersSize(styles, axis) {
    var sideA = axis === "x" ? "Left" : "Top";
    var sideB = sideA === "Left" ? "Right" : "Bottom";
    return parseFloat(styles["border" + sideA + "Width"], 10) + parseFloat(styles["border" + sideB + "Width"], 10);
  }
  function getSize(axis, body, html, computedStyle) {
    return Math.max(body["offset" + axis], body["scroll" + axis], html["client" + axis], html["offset" + axis], html["scroll" + axis], isIE$1(10) ? parseInt(html["offset" + axis]) + parseInt(computedStyle["margin" + (axis === "Height" ? "Top" : "Left")]) + parseInt(computedStyle["margin" + (axis === "Height" ? "Bottom" : "Right")]) : 0);
  }
  function getWindowSizes(document) {
    var body = document.body;
    var html = document.documentElement;
    var computedStyle = isIE$1(10) && getComputedStyle(html);
    return {
      height: getSize("Height", body, html, computedStyle),
      width: getSize("Width", body, html, computedStyle)
    };
  }
  var classCallCheck = function classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  };
  var createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();
  var defineProperty = function defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  };
  var _extends$2 = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };

  /**
   * Given element offsets, generate an output similar to getBoundingClientRect
   * @method
   * @memberof Popper.Utils
   * @argument {Object} offsets
   * @returns {Object} ClientRect like output
   */
  function getClientRect(offsets) {
    return _extends$2({}, offsets, {
      right: offsets.left + offsets.width,
      bottom: offsets.top + offsets.height
    });
  }

  /**
   * Get bounding client rect of given element
   * @method
   * @memberof Popper.Utils
   * @param {HTMLElement} element
   * @return {Object} client rect
   */
  function getBoundingClientRect$1(element) {
    var rect = {};

    // IE10 10 FIX: Please, don't ask, the element isn't
    // considered in DOM in some circumstances...
    // This isn't reproducible in IE10 compatibility mode of IE11
    try {
      if (isIE$1(10)) {
        rect = element.getBoundingClientRect();
        var scrollTop = getScroll(element, "top");
        var scrollLeft = getScroll(element, "left");
        rect.top += scrollTop;
        rect.left += scrollLeft;
        rect.bottom += scrollTop;
        rect.right += scrollLeft;
      } else {
        rect = element.getBoundingClientRect();
      }
    } catch (e) {}
    var result = {
      left: rect.left,
      top: rect.top,
      width: rect.right - rect.left,
      height: rect.bottom - rect.top
    };

    // subtract scrollbar size from sizes
    var sizes = element.nodeName === "HTML" ? getWindowSizes(element.ownerDocument) : {};
    var width = sizes.width || element.clientWidth || result.right - result.left;
    var height = sizes.height || element.clientHeight || result.bottom - result.top;
    var horizScrollbar = element.offsetWidth - width;
    var vertScrollbar = element.offsetHeight - height;

    // if an hypothetical scrollbar is detected, we must be sure it's not a `border`
    // we make this check conditional for performance reasons
    if (horizScrollbar || vertScrollbar) {
      var styles = getStyleComputedProperty(element);
      horizScrollbar -= getBordersSize(styles, "x");
      vertScrollbar -= getBordersSize(styles, "y");
      result.width -= horizScrollbar;
      result.height -= vertScrollbar;
    }
    return getClientRect(result);
  }
  function getOffsetRectRelativeToArbitraryNode(children, parent) {
    var fixedPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    var isIE10 = isIE$1(10);
    var isHTML = parent.nodeName === "HTML";
    var childrenRect = getBoundingClientRect$1(children);
    var parentRect = getBoundingClientRect$1(parent);
    var scrollParent = getScrollParent$1(children);
    var styles = getStyleComputedProperty(parent);
    var borderTopWidth = parseFloat(styles.borderTopWidth, 10);
    var borderLeftWidth = parseFloat(styles.borderLeftWidth, 10);

    // In cases where the parent is fixed, we must ignore negative scroll in offset calc
    if (fixedPosition && isHTML) {
      parentRect.top = Math.max(parentRect.top, 0);
      parentRect.left = Math.max(parentRect.left, 0);
    }
    var offsets = getClientRect({
      top: childrenRect.top - parentRect.top - borderTopWidth,
      left: childrenRect.left - parentRect.left - borderLeftWidth,
      width: childrenRect.width,
      height: childrenRect.height
    });
    offsets.marginTop = 0;
    offsets.marginLeft = 0;

    // Subtract margins of documentElement in case it's being used as parent
    // we do this only on HTML because it's the only element that behaves
    // differently when margins are applied to it. The margins are included in
    // the box of the documentElement, in the other cases not.
    if (!isIE10 && isHTML) {
      var marginTop = parseFloat(styles.marginTop, 10);
      var marginLeft = parseFloat(styles.marginLeft, 10);
      offsets.top -= borderTopWidth - marginTop;
      offsets.bottom -= borderTopWidth - marginTop;
      offsets.left -= borderLeftWidth - marginLeft;
      offsets.right -= borderLeftWidth - marginLeft;

      // Attach marginTop and marginLeft because in some circumstances we may need them
      offsets.marginTop = marginTop;
      offsets.marginLeft = marginLeft;
    }
    if (isIE10 && !fixedPosition ? parent.contains(scrollParent) : parent === scrollParent && scrollParent.nodeName !== "BODY") {
      offsets = includeScroll(offsets, parent);
    }
    return offsets;
  }
  function getViewportOffsetRectRelativeToArtbitraryNode(element) {
    var excludeScroll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var html = element.ownerDocument.documentElement;
    var relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);
    var width = Math.max(html.clientWidth, window.innerWidth || 0);
    var height = Math.max(html.clientHeight, window.innerHeight || 0);
    var scrollTop = !excludeScroll ? getScroll(html) : 0;
    var scrollLeft = !excludeScroll ? getScroll(html, "left") : 0;
    var offset = {
      top: scrollTop - relativeOffset.top + relativeOffset.marginTop,
      left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,
      width: width,
      height: height
    };
    return getClientRect(offset);
  }

  /**
   * Check if the given element is fixed or is inside a fixed parent
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element
   * @argument {Element} customContainer
   * @returns {Boolean} answer to "isFixed?"
   */
  function isFixed(element) {
    var nodeName = element.nodeName;
    if (nodeName === "BODY" || nodeName === "HTML") {
      return false;
    }
    if (getStyleComputedProperty(element, "position") === "fixed") {
      return true;
    }
    var parentNode = getParentNode$1(element);
    if (!parentNode) {
      return false;
    }
    return isFixed(parentNode);
  }

  /**
   * Finds the first parent of an element that has a transformed property defined
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element
   * @returns {Element} first transformed parent or documentElement
   */

  function getFixedPositionOffsetParent(element) {
    // This check is needed to avoid errors in case one of the elements isn't defined for any reason
    if (!element || !element.parentElement || isIE$1()) {
      return document.documentElement;
    }
    var el = element.parentElement;
    while (el && getStyleComputedProperty(el, "transform") === "none") {
      el = el.parentElement;
    }
    return el || document.documentElement;
  }

  /**
   * Computed the boundaries limits and return them
   * @method
   * @memberof Popper.Utils
   * @param {HTMLElement} popper
   * @param {HTMLElement} reference
   * @param {number} padding
   * @param {HTMLElement} boundariesElement - Element used to define the boundaries
   * @param {Boolean} fixedPosition - Is in fixed position mode
   * @returns {Object} Coordinates of the boundaries
   */
  function getBoundaries(popper, reference, padding, boundariesElement) {
    var fixedPosition = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;

    // NOTE: 1 DOM access here

    var boundaries = {
      top: 0,
      left: 0
    };
    var offsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, reference);

    // Handle viewport case
    if (boundariesElement === "viewport") {
      boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);
    } else {
      // Handle other cases based on DOM element used as boundaries
      var boundariesNode = void 0;
      if (boundariesElement === "scrollParent") {
        boundariesNode = getScrollParent$1(getParentNode$1(reference));
        if (boundariesNode.nodeName === "BODY") {
          boundariesNode = popper.ownerDocument.documentElement;
        }
      } else if (boundariesElement === "window") {
        boundariesNode = popper.ownerDocument.documentElement;
      } else {
        boundariesNode = boundariesElement;
      }
      var offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent, fixedPosition);

      // In case of HTML, we need a different computation
      if (boundariesNode.nodeName === "HTML" && !isFixed(offsetParent)) {
        var _getWindowSizes = getWindowSizes(popper.ownerDocument),
          height = _getWindowSizes.height,
          width = _getWindowSizes.width;
        boundaries.top += offsets.top - offsets.marginTop;
        boundaries.bottom = height + offsets.top;
        boundaries.left += offsets.left - offsets.marginLeft;
        boundaries.right = width + offsets.left;
      } else {
        // for all the other DOM elements, this one is good
        boundaries = offsets;
      }
    }

    // Add paddings
    padding = padding || 0;
    var isPaddingNumber = typeof padding === "number";
    boundaries.left += isPaddingNumber ? padding : padding.left || 0;
    boundaries.top += isPaddingNumber ? padding : padding.top || 0;
    boundaries.right -= isPaddingNumber ? padding : padding.right || 0;
    boundaries.bottom -= isPaddingNumber ? padding : padding.bottom || 0;
    return boundaries;
  }
  function getArea(_ref) {
    var width = _ref.width,
      height = _ref.height;
    return width * height;
  }

  /**
   * Utility used to transform the `auto` placement to the placement with more
   * available space.
   * @method
   * @memberof Popper.Utils
   * @argument {Object} data - The data object generated by update method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The data object, properly modified
   */
  function computeAutoPlacement$1(placement, refRect, popper, reference, boundariesElement) {
    var padding = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
    if (placement.indexOf("auto") === -1) {
      return placement;
    }
    var boundaries = getBoundaries(popper, reference, padding, boundariesElement);
    var rects = {
      top: {
        width: boundaries.width,
        height: refRect.top - boundaries.top
      },
      right: {
        width: boundaries.right - refRect.right,
        height: boundaries.height
      },
      bottom: {
        width: boundaries.width,
        height: boundaries.bottom - refRect.bottom
      },
      left: {
        width: refRect.left - boundaries.left,
        height: boundaries.height
      }
    };
    var sortedAreas = Object.keys(rects).map(function (key) {
      return _extends$2({
        key: key
      }, rects[key], {
        area: getArea(rects[key])
      });
    }).sort(function (a, b) {
      return b.area - a.area;
    });
    var filteredAreas = sortedAreas.filter(function (_ref2) {
      var width = _ref2.width,
        height = _ref2.height;
      return width >= popper.clientWidth && height >= popper.clientHeight;
    });
    var computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key;
    var variation = placement.split("-")[1];
    return computedPlacement + (variation ? "-" + variation : "");
  }

  /**
   * Get offsets to the reference element
   * @method
   * @memberof Popper.Utils
   * @param {Object} state
   * @param {Element} popper - the popper element
   * @param {Element} reference - the reference element (the popper will be relative to this)
   * @param {Element} fixedPosition - is in fixed position mode
   * @returns {Object} An object containing the offsets which will be applied to the popper
   */
  function getReferenceOffsets(state, popper, reference) {
    var fixedPosition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
    var commonOffsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, reference);
    return getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent, fixedPosition);
  }

  /**
   * Get the outer sizes of the given element (offset size + margins)
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element
   * @returns {Object} object containing width and height properties
   */
  function getOuterSizes(element) {
    var window = element.ownerDocument.defaultView;
    var styles = window.getComputedStyle(element);
    var x = parseFloat(styles.marginTop || 0) + parseFloat(styles.marginBottom || 0);
    var y = parseFloat(styles.marginLeft || 0) + parseFloat(styles.marginRight || 0);
    var result = {
      width: element.offsetWidth + y,
      height: element.offsetHeight + x
    };
    return result;
  }

  /**
   * Get the opposite placement of the given one
   * @method
   * @memberof Popper.Utils
   * @argument {String} placement
   * @returns {String} flipped placement
   */
  function getOppositePlacement$1(placement) {
    var hash = {
      left: "right",
      right: "left",
      bottom: "top",
      top: "bottom"
    };
    return placement.replace(/left|right|bottom|top/g, function (matched) {
      return hash[matched];
    });
  }

  /**
   * Get offsets to the popper
   * @method
   * @memberof Popper.Utils
   * @param {Object} position - CSS position the Popper will get applied
   * @param {HTMLElement} popper - the popper element
   * @param {Object} referenceOffsets - the reference offsets (the popper will be relative to this)
   * @param {String} placement - one of the valid placement options
   * @returns {Object} popperOffsets - An object containing the offsets which will be applied to the popper
   */
  function getPopperOffsets(popper, referenceOffsets, placement) {
    placement = placement.split("-")[0];

    // Get popper node sizes
    var popperRect = getOuterSizes(popper);

    // Add position, width and height to our offsets object
    var popperOffsets = {
      width: popperRect.width,
      height: popperRect.height
    };

    // depending by the popper placement we have to compute its offsets slightly differently
    var isHoriz = ["right", "left"].indexOf(placement) !== -1;
    var mainSide = isHoriz ? "top" : "left";
    var secondarySide = isHoriz ? "left" : "top";
    var measurement = isHoriz ? "height" : "width";
    var secondaryMeasurement = !isHoriz ? "height" : "width";
    popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2;
    if (placement === secondarySide) {
      popperOffsets[secondarySide] = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement];
    } else {
      popperOffsets[secondarySide] = referenceOffsets[getOppositePlacement$1(secondarySide)];
    }
    return popperOffsets;
  }

  /**
   * Mimics the `find` method of Array
   * @method
   * @memberof Popper.Utils
   * @argument {Array} arr
   * @argument prop
   * @argument value
   * @returns index or -1
   */
  function find(arr, check) {
    // use native find if supported
    if (Array.prototype.find) {
      return arr.find(check);
    }

    // use `filter` to obtain the same behavior of `find`
    return arr.filter(check)[0];
  }

  /**
   * Return the index of the matching object
   * @method
   * @memberof Popper.Utils
   * @argument {Array} arr
   * @argument prop
   * @argument value
   * @returns index or -1
   */
  function findIndex(arr, prop, value) {
    // use native findIndex if supported
    if (Array.prototype.findIndex) {
      return arr.findIndex(function (cur) {
        return cur[prop] === value;
      });
    }

    // use `find` + `indexOf` if `findIndex` isn't supported
    var match = find(arr, function (obj) {
      return obj[prop] === value;
    });
    return arr.indexOf(match);
  }

  /**
   * Loop trough the list of modifiers and run them in order,
   * each of them will then edit the data object.
   * @method
   * @memberof Popper.Utils
   * @param {dataObject} data
   * @param {Array} modifiers
   * @param {String} ends - Optional modifier name used as stopper
   * @returns {dataObject}
   */
  function runModifiers(modifiers, data, ends) {
    var modifiersToRun = ends === undefined ? modifiers : modifiers.slice(0, findIndex(modifiers, "name", ends));
    modifiersToRun.forEach(function (modifier) {
      if (modifier["function"]) {
        // eslint-disable-line dot-notation
        console.warn("`modifier.function` is deprecated, use `modifier.fn`!");
      }
      var fn = modifier["function"] || modifier.fn; // eslint-disable-line dot-notation
      if (modifier.enabled && isFunction$1(fn)) {
        // Add properties to offsets to make them a complete clientRect object
        // we do this before each modifier to make sure the previous one doesn't
        // mess with these values
        data.offsets.popper = getClientRect(data.offsets.popper);
        data.offsets.reference = getClientRect(data.offsets.reference);
        data = fn(data, modifier);
      }
    });
    return data;
  }

  /**
   * Updates the position of the popper, computing the new offsets and applying
   * the new style.<br />
   * Prefer `scheduleUpdate` over `update` because of performance reasons.
   * @method
   * @memberof Popper
   */
  function update() {
    // if popper is destroyed, don't perform any further update
    if (this.state.isDestroyed) {
      return;
    }
    var data = {
      instance: this,
      styles: {},
      arrowStyles: {},
      attributes: {},
      flipped: false,
      offsets: {}
    };

    // compute reference element offsets
    data.offsets.reference = getReferenceOffsets(this.state, this.popper, this.reference, this.options.positionFixed);

    // compute auto placement, store placement inside the data object,
    // modifiers will be able to edit `placement` if needed
    // and refer to originalPlacement to know the original value
    data.placement = computeAutoPlacement$1(this.options.placement, data.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding);

    // store the computed placement inside `originalPlacement`
    data.originalPlacement = data.placement;
    data.positionFixed = this.options.positionFixed;

    // compute the popper offsets
    data.offsets.popper = getPopperOffsets(this.popper, data.offsets.reference, data.placement);
    data.offsets.popper.position = this.options.positionFixed ? "fixed" : "absolute";

    // run the modifiers
    data = runModifiers(this.modifiers, data);

    // the first `update` will call `onCreate` callback
    // the other ones will call `onUpdate` callback
    if (!this.state.isCreated) {
      this.state.isCreated = true;
      this.options.onCreate(data);
    } else {
      this.options.onUpdate(data);
    }
  }

  /**
   * Helper used to know if the given modifier is enabled.
   * @method
   * @memberof Popper.Utils
   * @returns {Boolean}
   */
  function isModifierEnabled(modifiers, modifierName) {
    return modifiers.some(function (_ref) {
      var name = _ref.name,
        enabled = _ref.enabled;
      return enabled && name === modifierName;
    });
  }

  /**
   * Get the prefixed supported property name
   * @method
   * @memberof Popper.Utils
   * @argument {String} property (camelCase)
   * @returns {String} prefixed property (camelCase or PascalCase, depending on the vendor prefix)
   */
  function getSupportedPropertyName(property) {
    var prefixes = [false, "ms", "Webkit", "Moz", "O"];
    var upperProp = property.charAt(0).toUpperCase() + property.slice(1);
    for (var i = 0; i < prefixes.length; i++) {
      var prefix = prefixes[i];
      var toCheck = prefix ? "" + prefix + upperProp : property;
      if (typeof document.body.style[toCheck] !== "undefined") {
        return toCheck;
      }
    }
    return null;
  }

  /**
   * Destroys the popper.
   * @method
   * @memberof Popper
   */
  function destroy() {
    this.state.isDestroyed = true;

    // touch DOM only if `applyStyle` modifier is enabled
    if (isModifierEnabled(this.modifiers, "applyStyle")) {
      this.popper.removeAttribute("x-placement");
      this.popper.style.position = "";
      this.popper.style.top = "";
      this.popper.style.left = "";
      this.popper.style.right = "";
      this.popper.style.bottom = "";
      this.popper.style.willChange = "";
      this.popper.style[getSupportedPropertyName("transform")] = "";
    }
    this.disableEventListeners();

    // remove the popper if user explicity asked for the deletion on destroy
    // do not use `remove` because IE11 doesn't support it
    if (this.options.removeOnDestroy) {
      this.popper.parentNode.removeChild(this.popper);
    }
    return this;
  }

  /**
   * Get the window associated with the element
   * @argument {Element} element
   * @returns {Window}
   */
  function getWindow$1(element) {
    var ownerDocument = element.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView : window;
  }
  function attachToScrollParents(scrollParent, event, callback, scrollParents) {
    var isBody = scrollParent.nodeName === "BODY";
    var target = isBody ? scrollParent.ownerDocument.defaultView : scrollParent;
    target.addEventListener(event, callback, {
      passive: true
    });
    if (!isBody) {
      attachToScrollParents(getScrollParent$1(target.parentNode), event, callback, scrollParents);
    }
    scrollParents.push(target);
  }

  /**
   * Setup needed event listeners used to update the popper position
   * @method
   * @memberof Popper.Utils
   * @private
   */
  function setupEventListeners(reference, options, state, updateBound) {
    // Resize event listener on window
    state.updateBound = updateBound;
    getWindow$1(reference).addEventListener("resize", state.updateBound, {
      passive: true
    });

    // Scroll event listener on scroll parents
    var scrollElement = getScrollParent$1(reference);
    attachToScrollParents(scrollElement, "scroll", state.updateBound, state.scrollParents);
    state.scrollElement = scrollElement;
    state.eventsEnabled = true;
    return state;
  }

  /**
   * It will add resize/scroll events and start recalculating
   * position of the popper element when they are triggered.
   * @method
   * @memberof Popper
   */
  function enableEventListeners() {
    if (!this.state.eventsEnabled) {
      this.state = setupEventListeners(this.reference, this.options, this.state, this.scheduleUpdate);
    }
  }

  /**
   * Remove event listeners used to update the popper position
   * @method
   * @memberof Popper.Utils
   * @private
   */
  function removeEventListeners(reference, state) {
    // Remove resize event listener on window
    getWindow$1(reference).removeEventListener("resize", state.updateBound);

    // Remove scroll event listener on scroll parents
    state.scrollParents.forEach(function (target) {
      target.removeEventListener("scroll", state.updateBound);
    });

    // Reset state
    state.updateBound = null;
    state.scrollParents = [];
    state.scrollElement = null;
    state.eventsEnabled = false;
    return state;
  }

  /**
   * It will remove resize/scroll events and won't recalculate popper position
   * when they are triggered. It also won't trigger `onUpdate` callback anymore,
   * unless you call `update` method manually.
   * @method
   * @memberof Popper
   */
  function disableEventListeners() {
    if (this.state.eventsEnabled) {
      cancelAnimationFrame(this.scheduleUpdate);
      this.state = removeEventListeners(this.reference, this.state);
    }
  }

  /**
   * Tells if a given input is a number
   * @method
   * @memberof Popper.Utils
   * @param {*} input to check
   * @return {Boolean}
   */
  function isNumeric(n) {
    return n !== "" && !isNaN(parseFloat(n)) && isFinite(n);
  }

  /**
   * Set the style to the given popper
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element - Element to apply the style to
   * @argument {Object} styles
   * Object with a list of properties and values which will be applied to the element
   */
  function setStyles(element, styles) {
    Object.keys(styles).forEach(function (prop) {
      var unit = "";
      // add unit if the value is numeric and is one of the following
      if (["width", "height", "top", "right", "bottom", "left"].indexOf(prop) !== -1 && isNumeric(styles[prop])) {
        unit = "px";
      }
      element.style[prop] = styles[prop] + unit;
    });
  }

  /**
   * Set the attributes to the given popper
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element - Element to apply the attributes to
   * @argument {Object} styles
   * Object with a list of properties and values which will be applied to the element
   */
  function setAttributes$1(element, attributes) {
    Object.keys(attributes).forEach(function (prop) {
      var value = attributes[prop];
      if (value !== false) {
        element.setAttribute(prop, attributes[prop]);
      } else {
        element.removeAttribute(prop);
      }
    });
  }

  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by `update` method
   * @argument {Object} data.styles - List of style properties - values to apply to popper element
   * @argument {Object} data.attributes - List of attribute properties - values to apply to popper element
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The same data object
   */
  function applyStyle(data) {
    // any property present in `data.styles` will be applied to the popper,
    // in this way we can make the 3rd party modifiers add custom styles to it
    // Be aware, modifiers could override the properties defined in the previous
    // lines of this modifier!
    setStyles(data.instance.popper, data.styles);

    // any property present in `data.attributes` will be applied to the popper,
    // they will be set as HTML attributes of the element
    setAttributes$1(data.instance.popper, data.attributes);

    // if arrowElement is defined and arrowStyles has some properties
    if (data.arrowElement && Object.keys(data.arrowStyles).length) {
      setStyles(data.arrowElement, data.arrowStyles);
    }
    return data;
  }

  /**
   * Set the x-placement attribute before everything else because it could be used
   * to add margins to the popper margins needs to be calculated to get the
   * correct popper offsets.
   * @method
   * @memberof Popper.modifiers
   * @param {HTMLElement} reference - The reference element used to position the popper
   * @param {HTMLElement} popper - The HTML element used as popper
   * @param {Object} options - Popper.js options
   */
  function applyStyleOnLoad(reference, popper, options, modifierOptions, state) {
    // compute reference element offsets
    var referenceOffsets = getReferenceOffsets(state, popper, reference, options.positionFixed);

    // compute auto placement, store placement inside the data object,
    // modifiers will be able to edit `placement` if needed
    // and refer to originalPlacement to know the original value
    var placement = computeAutoPlacement$1(options.placement, referenceOffsets, popper, reference, options.modifiers.flip.boundariesElement, options.modifiers.flip.padding);
    popper.setAttribute("x-placement", placement);

    // Apply `position` to popper before anything else because
    // without the position applied we can't guarantee correct computations
    setStyles(popper, {
      position: options.positionFixed ? "fixed" : "absolute"
    });
    return options;
  }

  /**
   * @function
   * @memberof Popper.Utils
   * @argument {Object} data - The data object generated by `update` method
   * @argument {Boolean} shouldRound - If the offsets should be rounded at all
   * @returns {Object} The popper's position offsets rounded
   *
   * The tale of pixel-perfect positioning. It's still not 100% perfect, but as
   * good as it can be within reason.
   * Discussion here: https://github.com/FezVrasta/popper.js/pull/715
   *
   * Low DPI screens cause a popper to be blurry if not using full pixels (Safari
   * as well on High DPI screens).
   *
   * Firefox prefers no rounding for positioning and does not have blurriness on
   * high DPI screens.
   *
   * Only horizontal placement and left/right values need to be considered.
   */
  function getRoundedOffsets(data, shouldRound) {
    var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;
    var round = Math.round,
      floor = Math.floor;
    var noRound = function noRound(v) {
      return v;
    };
    var referenceWidth = round(reference.width);
    var popperWidth = round(popper.width);
    var isVertical = ["left", "right"].indexOf(data.placement) !== -1;
    var isVariation = data.placement.indexOf("-") !== -1;
    var sameWidthParity = referenceWidth % 2 === popperWidth % 2;
    var bothOddWidth = referenceWidth % 2 === 1 && popperWidth % 2 === 1;
    var horizontalToInteger = !shouldRound ? noRound : isVertical || isVariation || sameWidthParity ? round : floor;
    var verticalToInteger = !shouldRound ? noRound : round;
    return {
      left: horizontalToInteger(bothOddWidth && !isVariation && shouldRound ? popper.left - 1 : popper.left),
      top: verticalToInteger(popper.top),
      bottom: verticalToInteger(popper.bottom),
      right: horizontalToInteger(popper.right)
    };
  }
  var isFirefox = isBrowser$1$1 && /Firefox/i.test(navigator.userAgent);

  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by `update` method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The data object, properly modified
   */
  function computeStyle(data, options) {
    var x = options.x,
      y = options.y;
    var popper = data.offsets.popper;

    // Remove this legacy support in Popper.js v2

    var legacyGpuAccelerationOption = find(data.instance.modifiers, function (modifier) {
      return modifier.name === "applyStyle";
    }).gpuAcceleration;
    if (legacyGpuAccelerationOption !== undefined) {
      console.warn("WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!");
    }
    var gpuAcceleration = legacyGpuAccelerationOption !== undefined ? legacyGpuAccelerationOption : options.gpuAcceleration;
    var offsetParent = getOffsetParent$1(data.instance.popper);
    var offsetParentRect = getBoundingClientRect$1(offsetParent);

    // Styles
    var styles = {
      position: popper.position
    };
    var offsets = getRoundedOffsets(data, window.devicePixelRatio < 2 || !isFirefox);
    var sideA = x === "bottom" ? "top" : "bottom";
    var sideB = y === "right" ? "left" : "right";

    // if gpuAcceleration is set to `true` and transform is supported,
    //  we use `translate3d` to apply the position to the popper we
    // automatically use the supported prefixed version if needed
    var prefixedProperty = getSupportedPropertyName("transform");

    // now, let's make a step back and look at this code closely (wtf?)
    // If the content of the popper grows once it's been positioned, it
    // may happen that the popper gets misplaced because of the new content
    // overflowing its reference element
    // To avoid this problem, we provide two options (x and y), which allow
    // the consumer to define the offset origin.
    // If we position a popper on top of a reference element, we can set
    // `x` to `top` to make the popper grow towards its top instead of
    // its bottom.
    var left = void 0,
      top = void 0;
    if (sideA === "bottom") {
      // when offsetParent is <html> the positioning is relative to the bottom of the screen (excluding the scrollbar)
      // and not the bottom of the html element
      if (offsetParent.nodeName === "HTML") {
        top = -offsetParent.clientHeight + offsets.bottom;
      } else {
        top = -offsetParentRect.height + offsets.bottom;
      }
    } else {
      top = offsets.top;
    }
    if (sideB === "right") {
      if (offsetParent.nodeName === "HTML") {
        left = -offsetParent.clientWidth + offsets.right;
      } else {
        left = -offsetParentRect.width + offsets.right;
      }
    } else {
      left = offsets.left;
    }
    if (gpuAcceleration && prefixedProperty) {
      styles[prefixedProperty] = "translate3d(" + left + "px, " + top + "px, 0)";
      styles[sideA] = 0;
      styles[sideB] = 0;
      styles.willChange = "transform";
    } else {
      // othwerise, we use the standard `top`, `left`, `bottom` and `right` properties
      var invertTop = sideA === "bottom" ? -1 : 1;
      var invertLeft = sideB === "right" ? -1 : 1;
      styles[sideA] = top * invertTop;
      styles[sideB] = left * invertLeft;
      styles.willChange = sideA + ", " + sideB;
    }

    // Attributes
    var attributes = {
      "x-placement": data.placement
    };

    // Update `data` attributes, styles and arrowStyles
    data.attributes = _extends$2({}, attributes, data.attributes);
    data.styles = _extends$2({}, styles, data.styles);
    data.arrowStyles = _extends$2({}, data.offsets.arrow, data.arrowStyles);
    return data;
  }

  /**
   * Helper used to know if the given modifier depends from another one.<br />
   * It checks if the needed modifier is listed and enabled.
   * @method
   * @memberof Popper.Utils
   * @param {Array} modifiers - list of modifiers
   * @param {String} requestingName - name of requesting modifier
   * @param {String} requestedName - name of requested modifier
   * @returns {Boolean}
   */
  function isModifierRequired(modifiers, requestingName, requestedName) {
    var requesting = find(modifiers, function (_ref) {
      var name = _ref.name;
      return name === requestingName;
    });
    var isRequired = !!requesting && modifiers.some(function (modifier) {
      return modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order;
    });
    if (!isRequired) {
      var _requesting = "`" + requestingName + "`";
      var requested = "`" + requestedName + "`";
      console.warn(requested + " modifier is required by " + _requesting + " modifier in order to work, be sure to include it before " + _requesting + "!");
    }
    return isRequired;
  }

  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by update method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The data object, properly modified
   */
  function arrow$2(data, options) {
    var _data$offsets$arrow;

    // arrow depends on keepTogether in order to work
    if (!isModifierRequired(data.instance.modifiers, "arrow", "keepTogether")) {
      return data;
    }
    var arrowElement = options.element;

    // if arrowElement is a string, suppose it's a CSS selector
    if (typeof arrowElement === "string") {
      arrowElement = data.instance.popper.querySelector(arrowElement);

      // if arrowElement is not found, don't run the modifier
      if (!arrowElement) {
        return data;
      }
    } else {
      // if the arrowElement isn't a query selector we must check that the
      // provided DOM node is child of its popper node
      if (!data.instance.popper.contains(arrowElement)) {
        console.warn("WARNING: `arrow.element` must be child of its popper element!");
        return data;
      }
    }
    var placement = data.placement.split("-")[0];
    var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;
    var isVertical = ["left", "right"].indexOf(placement) !== -1;
    var len = isVertical ? "height" : "width";
    var sideCapitalized = isVertical ? "Top" : "Left";
    var side = sideCapitalized.toLowerCase();
    var altSide = isVertical ? "left" : "top";
    var opSide = isVertical ? "bottom" : "right";
    var arrowElementSize = getOuterSizes(arrowElement)[len];

    //
    // extends keepTogether behavior making sure the popper and its
    // reference have enough pixels in conjunction
    //

    // top/left side
    if (reference[opSide] - arrowElementSize < popper[side]) {
      data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElementSize);
    }
    // bottom/right side
    if (reference[side] + arrowElementSize > popper[opSide]) {
      data.offsets.popper[side] += reference[side] + arrowElementSize - popper[opSide];
    }
    data.offsets.popper = getClientRect(data.offsets.popper);

    // compute center of the popper
    var center = reference[side] + reference[len] / 2 - arrowElementSize / 2;

    // Compute the sideValue using the updated popper offsets
    // take popper margin in account because we don't have this info available
    var css = getStyleComputedProperty(data.instance.popper);
    var popperMarginSide = parseFloat(css["margin" + sideCapitalized], 10);
    var popperBorderSide = parseFloat(css["border" + sideCapitalized + "Width"], 10);
    var sideValue = center - data.offsets.popper[side] - popperMarginSide - popperBorderSide;

    // prevent arrowElement from being placed not contiguously to its popper
    sideValue = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0);
    data.arrowElement = arrowElement;
    data.offsets.arrow = (_data$offsets$arrow = {}, defineProperty(_data$offsets$arrow, side, Math.round(sideValue)), defineProperty(_data$offsets$arrow, altSide, ""), _data$offsets$arrow);
    return data;
  }

  /**
   * Get the opposite placement variation of the given one
   * @method
   * @memberof Popper.Utils
   * @argument {String} placement variation
   * @returns {String} flipped placement variation
   */
  function getOppositeVariation(variation) {
    if (variation === "end") {
      return "start";
    } else if (variation === "start") {
      return "end";
    }
    return variation;
  }

  /**
   * List of accepted placements to use as values of the `placement` option.<br />
   * Valid placements are:
   * - `auto`
   * - `top`
   * - `right`
   * - `bottom`
   * - `left`
   *
   * Each placement can have a variation from this list:
   * - `-start`
   * - `-end`
   *
   * Variations are interpreted easily if you think of them as the left to right
   * written languages. Horizontally (`top` and `bottom`), `start` is left and `end`
   * is right.<br />
   * Vertically (`left` and `right`), `start` is top and `end` is bottom.
   *
   * Some valid examples are:
   * - `top-end` (on top of reference, right aligned)
   * - `right-start` (on right of reference, top aligned)
   * - `bottom` (on bottom, centered)
   * - `auto-end` (on the side with more space available, alignment depends by placement)
   *
   * @static
   * @type {Array}
   * @enum {String}
   * @readonly
   * @method placements
   * @memberof Popper
   */
  var placements$1 = ["auto-start", "auto", "auto-end", "top-start", "top", "top-end", "right-start", "right", "right-end", "bottom-end", "bottom", "bottom-start", "left-end", "left", "left-start"];

  // Get rid of `auto` `auto-start` and `auto-end`
  var validPlacements = placements$1.slice(3);

  /**
   * Given an initial placement, returns all the subsequent placements
   * clockwise (or counter-clockwise).
   *
   * @method
   * @memberof Popper.Utils
   * @argument {String} placement - A valid placement (it accepts variations)
   * @argument {Boolean} counter - Set to true to walk the placements counterclockwise
   * @returns {Array} placements including their variations
   */
  function clockwise(placement) {
    var counter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var index = validPlacements.indexOf(placement);
    var arr = validPlacements.slice(index + 1).concat(validPlacements.slice(0, index));
    return counter ? arr.reverse() : arr;
  }
  var BEHAVIORS = {
    FLIP: "flip",
    CLOCKWISE: "clockwise",
    COUNTERCLOCKWISE: "counterclockwise"
  };

  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by update method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The data object, properly modified
   */
  function flip$2(data, options) {
    // if `inner` modifier is enabled, we can't use the `flip` modifier
    if (isModifierEnabled(data.instance.modifiers, "inner")) {
      return data;
    }
    if (data.flipped && data.placement === data.originalPlacement) {
      // seems like flip is trying to loop, probably there's not enough space on any of the flippable sides
      return data;
    }
    var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, options.boundariesElement, data.positionFixed);
    var placement = data.placement.split("-")[0];
    var placementOpposite = getOppositePlacement$1(placement);
    var variation = data.placement.split("-")[1] || "";
    var flipOrder = [];
    switch (options.behavior) {
      case BEHAVIORS.FLIP:
        flipOrder = [placement, placementOpposite];
        break;
      case BEHAVIORS.CLOCKWISE:
        flipOrder = clockwise(placement);
        break;
      case BEHAVIORS.COUNTERCLOCKWISE:
        flipOrder = clockwise(placement, true);
        break;
      default:
        flipOrder = options.behavior;
    }
    flipOrder.forEach(function (step, index) {
      if (placement !== step || flipOrder.length === index + 1) {
        return data;
      }
      placement = data.placement.split("-")[0];
      placementOpposite = getOppositePlacement$1(placement);
      var popperOffsets = data.offsets.popper;
      var refOffsets = data.offsets.reference;

      // using floor because the reference offsets may contain decimals we are not going to consider here
      var floor = Math.floor;
      var overlapsRef = placement === "left" && floor(popperOffsets.right) > floor(refOffsets.left) || placement === "right" && floor(popperOffsets.left) < floor(refOffsets.right) || placement === "top" && floor(popperOffsets.bottom) > floor(refOffsets.top) || placement === "bottom" && floor(popperOffsets.top) < floor(refOffsets.bottom);
      var overflowsLeft = floor(popperOffsets.left) < floor(boundaries.left);
      var overflowsRight = floor(popperOffsets.right) > floor(boundaries.right);
      var overflowsTop = floor(popperOffsets.top) < floor(boundaries.top);
      var overflowsBottom = floor(popperOffsets.bottom) > floor(boundaries.bottom);
      var overflowsBoundaries = placement === "left" && overflowsLeft || placement === "right" && overflowsRight || placement === "top" && overflowsTop || placement === "bottom" && overflowsBottom;

      // flip the variation if required
      var isVertical = ["top", "bottom"].indexOf(placement) !== -1;

      // flips variation if reference element overflows boundaries
      var flippedVariationByRef = !!options.flipVariations && (isVertical && variation === "start" && overflowsLeft || isVertical && variation === "end" && overflowsRight || !isVertical && variation === "start" && overflowsTop || !isVertical && variation === "end" && overflowsBottom);

      // flips variation if popper content overflows boundaries
      var flippedVariationByContent = !!options.flipVariationsByContent && (isVertical && variation === "start" && overflowsRight || isVertical && variation === "end" && overflowsLeft || !isVertical && variation === "start" && overflowsBottom || !isVertical && variation === "end" && overflowsTop);
      var flippedVariation = flippedVariationByRef || flippedVariationByContent;
      if (overlapsRef || overflowsBoundaries || flippedVariation) {
        // this boolean to detect any flip loop
        data.flipped = true;
        if (overlapsRef || overflowsBoundaries) {
          placement = flipOrder[index + 1];
        }
        if (flippedVariation) {
          variation = getOppositeVariation(variation);
        }
        data.placement = placement + (variation ? "-" + variation : "");

        // this object contains `position`, we want to preserve it along with
        // any additional property we may add in the future
        data.offsets.popper = _extends$2({}, data.offsets.popper, getPopperOffsets(data.instance.popper, data.offsets.reference, data.placement));
        data = runModifiers(data.instance.modifiers, data, "flip");
      }
    });
    return data;
  }

  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by update method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The data object, properly modified
   */
  function keepTogether(data) {
    var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;
    var placement = data.placement.split("-")[0];
    var floor = Math.floor;
    var isVertical = ["top", "bottom"].indexOf(placement) !== -1;
    var side = isVertical ? "right" : "bottom";
    var opSide = isVertical ? "left" : "top";
    var measurement = isVertical ? "width" : "height";
    if (popper[side] < floor(reference[opSide])) {
      data.offsets.popper[opSide] = floor(reference[opSide]) - popper[measurement];
    }
    if (popper[opSide] > floor(reference[side])) {
      data.offsets.popper[opSide] = floor(reference[side]);
    }
    return data;
  }

  /**
   * Converts a string containing value + unit into a px value number
   * @function
   * @memberof {modifiers~offset}
   * @private
   * @argument {String} str - Value + unit string
   * @argument {String} measurement - `height` or `width`
   * @argument {Object} popperOffsets
   * @argument {Object} referenceOffsets
   * @returns {Number|String}
   * Value in pixels, or original string if no values were extracted
   */
  function toValue(str, measurement, popperOffsets, referenceOffsets) {
    // separate value from unit
    var split = str.match(/((?:\-|\+)?\d*\.?\d*)(.*)/);
    var value = +split[1];
    var unit = split[2];

    // If it's not a number it's an operator, I guess
    if (!value) {
      return str;
    }
    if (unit.indexOf("%") === 0) {
      var element = void 0;
      switch (unit) {
        case "%p":
          element = popperOffsets;
          break;
        case "%":
        case "%r":
        default:
          element = referenceOffsets;
      }
      var rect = getClientRect(element);
      return rect[measurement] / 100 * value;
    } else if (unit === "vh" || unit === "vw") {
      // if is a vh or vw, we calculate the size based on the viewport
      var size = void 0;
      if (unit === "vh") {
        size = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
      } else {
        size = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
      }
      return size / 100 * value;
    } else {
      // if is an explicit pixel unit, we get rid of the unit and keep the value
      // if is an implicit unit, it's px, and we return just the value
      return value;
    }
  }

  /**
   * Parse an `offset` string to extrapolate `x` and `y` numeric offsets.
   * @function
   * @memberof {modifiers~offset}
   * @private
   * @argument {String} offset
   * @argument {Object} popperOffsets
   * @argument {Object} referenceOffsets
   * @argument {String} basePlacement
   * @returns {Array} a two cells array with x and y offsets in numbers
   */
  function parseOffset(offset, popperOffsets, referenceOffsets, basePlacement) {
    var offsets = [0, 0];

    // Use height if placement is left or right and index is 0 otherwise use width
    // in this way the first offset will use an axis and the second one
    // will use the other one
    var useHeight = ["right", "left"].indexOf(basePlacement) !== -1;

    // Split the offset string to obtain a list of values and operands
    // The regex addresses values with the plus or minus sign in front (+10, -20, etc)
    var fragments = offset.split(/(\+|\-)/).map(function (frag) {
      return frag.trim();
    });

    // Detect if the offset string contains a pair of values or a single one
    // they could be separated by comma or space
    var divider = fragments.indexOf(find(fragments, function (frag) {
      return frag.search(/,|\s/) !== -1;
    }));
    if (fragments[divider] && fragments[divider].indexOf(",") === -1) {
      console.warn("Offsets separated by white space(s) are deprecated, use a comma (,) instead.");
    }

    // If divider is found, we divide the list of values and operands to divide
    // them by ofset X and Y.
    var splitRegex = /\s*,\s*|\s+/;
    var ops = divider !== -1 ? [fragments.slice(0, divider).concat([fragments[divider].split(splitRegex)[0]]), [fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider + 1))] : [fragments];

    // Convert the values with units to absolute pixels to allow our computations
    ops = ops.map(function (op, index) {
      // Most of the units rely on the orientation of the popper
      var measurement = (index === 1 ? !useHeight : useHeight) ? "height" : "width";
      var mergeWithPrevious = false;
      return op
      // This aggregates any `+` or `-` sign that aren't considered operators
      // e.g.: 10 + +5 => [10, +, +5]
      .reduce(function (a, b) {
        if (a[a.length - 1] === "" && ["+", "-"].indexOf(b) !== -1) {
          a[a.length - 1] = b;
          mergeWithPrevious = true;
          return a;
        } else if (mergeWithPrevious) {
          a[a.length - 1] += b;
          mergeWithPrevious = false;
          return a;
        } else {
          return a.concat(b);
        }
      }, [])
      // Here we convert the string values into number values (in px)
      .map(function (str) {
        return toValue(str, measurement, popperOffsets, referenceOffsets);
      });
    });

    // Loop trough the offsets arrays and execute the operations
    ops.forEach(function (op, index) {
      op.forEach(function (frag, index2) {
        if (isNumeric(frag)) {
          offsets[index] += frag * (op[index2 - 1] === "-" ? -1 : 1);
        }
      });
    });
    return offsets;
  }

  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by update method
   * @argument {Object} options - Modifiers configuration and options
   * @argument {Number|String} options.offset=0
   * The offset value as described in the modifier description
   * @returns {Object} The data object, properly modified
   */
  function offset$2(data, _ref) {
    var offset = _ref.offset;
    var placement = data.placement,
      _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;
    var basePlacement = placement.split("-")[0];
    var offsets = void 0;
    if (isNumeric(+offset)) {
      offsets = [+offset, 0];
    } else {
      offsets = parseOffset(offset, popper, reference, basePlacement);
    }
    if (basePlacement === "left") {
      popper.top += offsets[0];
      popper.left -= offsets[1];
    } else if (basePlacement === "right") {
      popper.top += offsets[0];
      popper.left += offsets[1];
    } else if (basePlacement === "top") {
      popper.left += offsets[0];
      popper.top -= offsets[1];
    } else if (basePlacement === "bottom") {
      popper.left += offsets[0];
      popper.top += offsets[1];
    }
    data.popper = popper;
    return data;
  }

  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by `update` method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The data object, properly modified
   */
  function preventOverflow$2(data, options) {
    var boundariesElement = options.boundariesElement || getOffsetParent$1(data.instance.popper);

    // If offsetParent is the reference element, we really want to
    // go one step up and use the next offsetParent as reference to
    // avoid to make this modifier completely useless and look like broken
    if (data.instance.reference === boundariesElement) {
      boundariesElement = getOffsetParent$1(boundariesElement);
    }

    // NOTE: DOM access here
    // resets the popper's position so that the document size can be calculated excluding
    // the size of the popper element itself
    var transformProp = getSupportedPropertyName("transform");
    var popperStyles = data.instance.popper.style; // assignment to help minification
    var top = popperStyles.top,
      left = popperStyles.left,
      transform = popperStyles[transformProp];
    popperStyles.top = "";
    popperStyles.left = "";
    popperStyles[transformProp] = "";
    var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, boundariesElement, data.positionFixed);

    // NOTE: DOM access here
    // restores the original style properties after the offsets have been computed
    popperStyles.top = top;
    popperStyles.left = left;
    popperStyles[transformProp] = transform;
    options.boundaries = boundaries;
    var order = options.priority;
    var popper = data.offsets.popper;
    var check = {
      primary: function primary(placement) {
        var value = popper[placement];
        if (popper[placement] < boundaries[placement] && !options.escapeWithReference) {
          value = Math.max(popper[placement], boundaries[placement]);
        }
        return defineProperty({}, placement, value);
      },
      secondary: function secondary(placement) {
        var mainSide = placement === "right" ? "left" : "top";
        var value = popper[mainSide];
        if (popper[placement] > boundaries[placement] && !options.escapeWithReference) {
          value = Math.min(popper[mainSide], boundaries[placement] - (placement === "right" ? popper.width : popper.height));
        }
        return defineProperty({}, mainSide, value);
      }
    };
    order.forEach(function (placement) {
      var side = ["left", "top"].indexOf(placement) !== -1 ? "primary" : "secondary";
      popper = _extends$2({}, popper, check[side](placement));
    });
    data.offsets.popper = popper;
    return data;
  }

  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by `update` method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The data object, properly modified
   */
  function shift(data) {
    var placement = data.placement;
    var basePlacement = placement.split("-")[0];
    var shiftvariation = placement.split("-")[1];

    // if shift shiftvariation is specified, run the modifier
    if (shiftvariation) {
      var _data$offsets = data.offsets,
        reference = _data$offsets.reference,
        popper = _data$offsets.popper;
      var isVertical = ["bottom", "top"].indexOf(basePlacement) !== -1;
      var side = isVertical ? "left" : "top";
      var measurement = isVertical ? "width" : "height";
      var shiftOffsets = {
        start: defineProperty({}, side, reference[side]),
        end: defineProperty({}, side, reference[side] + reference[measurement] - popper[measurement])
      };
      data.offsets.popper = _extends$2({}, popper, shiftOffsets[shiftvariation]);
    }
    return data;
  }

  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by update method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The data object, properly modified
   */
  function hide$2(data) {
    if (!isModifierRequired(data.instance.modifiers, "hide", "preventOverflow")) {
      return data;
    }
    var refRect = data.offsets.reference;
    var bound = find(data.instance.modifiers, function (modifier) {
      return modifier.name === "preventOverflow";
    }).boundaries;
    if (refRect.bottom < bound.top || refRect.left > bound.right || refRect.top > bound.bottom || refRect.right < bound.left) {
      // Avoid unnecessary DOM access if visibility hasn't changed
      if (data.hide === true) {
        return data;
      }
      data.hide = true;
      data.attributes["x-out-of-boundaries"] = "";
    } else {
      // Avoid unnecessary DOM access if visibility hasn't changed
      if (data.hide === false) {
        return data;
      }
      data.hide = false;
      data.attributes["x-out-of-boundaries"] = false;
    }
    return data;
  }

  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by `update` method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The data object, properly modified
   */
  function inner(data) {
    var placement = data.placement;
    var basePlacement = placement.split("-")[0];
    var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;
    var isHoriz = ["left", "right"].indexOf(basePlacement) !== -1;
    var subtractLength = ["top", "left"].indexOf(basePlacement) === -1;
    popper[isHoriz ? "left" : "top"] = reference[basePlacement] - (subtractLength ? popper[isHoriz ? "width" : "height"] : 0);
    data.placement = getOppositePlacement$1(placement);
    data.offsets.popper = getClientRect(popper);
    return data;
  }

  /**
   * Modifier function, each modifier can have a function of this type assigned
   * to its `fn` property.<br />
   * These functions will be called on each update, this means that you must
   * make sure they are performant enough to avoid performance bottlenecks.
   *
   * @function ModifierFn
   * @argument {dataObject} data - The data object generated by `update` method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {dataObject} The data object, properly modified
   */

  /**
   * Modifiers are plugins used to alter the behavior of your poppers.<br />
   * Popper.js uses a set of 9 modifiers to provide all the basic functionalities
   * needed by the library.
   *
   * Usually you don't want to override the `order`, `fn` and `onLoad` props.
   * All the other properties are configurations that could be tweaked.
   * @namespace modifiers
   */
  var modifiers = {
    /**
     * Modifier used to shift the popper on the start or end of its reference
     * element.<br />
     * It will read the variation of the `placement` property.<br />
     * It can be one either `-end` or `-start`.
     * @memberof modifiers
     * @inner
     */
    shift: {
      /** @prop {number} order=100 - Index used to define the order of execution */
      order: 100,
      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
      enabled: true,
      /** @prop {ModifierFn} */
      fn: shift
    },
    /**
     * The `offset` modifier can shift your popper on both its axis.
     *
     * It accepts the following units:
     * - `px` or unit-less, interpreted as pixels
     * - `%` or `%r`, percentage relative to the length of the reference element
     * - `%p`, percentage relative to the length of the popper element
     * - `vw`, CSS viewport width unit
     * - `vh`, CSS viewport height unit
     *
     * For length is intended the main axis relative to the placement of the popper.<br />
     * This means that if the placement is `top` or `bottom`, the length will be the
     * `width`. In case of `left` or `right`, it will be the `height`.
     *
     * You can provide a single value (as `Number` or `String`), or a pair of values
     * as `String` divided by a comma or one (or more) white spaces.<br />
     * The latter is a deprecated method because it leads to confusion and will be
     * removed in v2.<br />
     * Additionally, it accepts additions and subtractions between different units.
     * Note that multiplications and divisions aren't supported.
     *
     * Valid examples are:
     * ```
     * 10
     * '10%'
     * '10, 10'
     * '10%, 10'
     * '10 + 10%'
     * '10 - 5vh + 3%'
     * '-10px + 5vh, 5px - 6%'
     * ```
     * > **NB**: If you desire to apply offsets to your poppers in a way that may make them overlap
     * > with their reference element, unfortunately, you will have to disable the `flip` modifier.
     * > You can read more on this at this [issue](https://github.com/FezVrasta/popper.js/issues/373).
     *
     * @memberof modifiers
     * @inner
     */
    offset: {
      /** @prop {number} order=200 - Index used to define the order of execution */
      order: 200,
      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
      enabled: true,
      /** @prop {ModifierFn} */
      fn: offset$2,
      /** @prop {Number|String} offset=0
       * The offset value as described in the modifier description
       */
      offset: 0
    },
    /**
     * Modifier used to prevent the popper from being positioned outside the boundary.
     *
     * A scenario exists where the reference itself is not within the boundaries.<br />
     * We can say it has "escaped the boundaries"  or just "escaped".<br />
     * In this case we need to decide whether the popper should either:
     *
     * - detach from the reference and remain "trapped" in the boundaries, or
     * - if it should ignore the boundary and "escape with its reference"
     *
     * When `escapeWithReference` is set to`true` and reference is completely
     * outside its boundaries, the popper will overflow (or completely leave)
     * the boundaries in order to remain attached to the edge of the reference.
     *
     * @memberof modifiers
     * @inner
     */
    preventOverflow: {
      /** @prop {number} order=300 - Index used to define the order of execution */
      order: 300,
      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
      enabled: true,
      /** @prop {ModifierFn} */
      fn: preventOverflow$2,
      /**
       * @prop {Array} [priority=['left','right','top','bottom']]
       * Popper will try to prevent overflow following these priorities by default,
       * then, it could overflow on the left and on top of the `boundariesElement`
       */
      priority: ["left", "right", "top", "bottom"],
      /**
       * @prop {number} padding=5
       * Amount of pixel used to define a minimum distance between the boundaries
       * and the popper. This makes sure the popper always has a little padding
       * between the edges of its container
       */
      padding: 5,
      /**
       * @prop {String|HTMLElement} boundariesElement='scrollParent'
       * Boundaries used by the modifier. Can be `scrollParent`, `window`,
       * `viewport` or any DOM element.
       */
      boundariesElement: "scrollParent"
    },
    /**
     * Modifier used to make sure the reference and its popper stay near each other
     * without leaving any gap between the two. Especially useful when the arrow is
     * enabled and you want to ensure that it points to its reference element.
     * It cares only about the first axis. You can still have poppers with margin
     * between the popper and its reference element.
     * @memberof modifiers
     * @inner
     */
    keepTogether: {
      /** @prop {number} order=400 - Index used to define the order of execution */
      order: 400,
      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
      enabled: true,
      /** @prop {ModifierFn} */
      fn: keepTogether
    },
    /**
     * This modifier is used to move the `arrowElement` of the popper to make
     * sure it is positioned between the reference element and its popper element.
     * It will read the outer size of the `arrowElement` node to detect how many
     * pixels of conjunction are needed.
     *
     * It has no effect if no `arrowElement` is provided.
     * @memberof modifiers
     * @inner
     */
    arrow: {
      /** @prop {number} order=500 - Index used to define the order of execution */
      order: 500,
      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
      enabled: true,
      /** @prop {ModifierFn} */
      fn: arrow$2,
      /** @prop {String|HTMLElement} element='[x-arrow]' - Selector or node used as arrow */
      element: "[x-arrow]"
    },
    /**
     * Modifier used to flip the popper's placement when it starts to overlap its
     * reference element.
     *
     * Requires the `preventOverflow` modifier before it in order to work.
     *
     * **NOTE:** this modifier will interrupt the current update cycle and will
     * restart it if it detects the need to flip the placement.
     * @memberof modifiers
     * @inner
     */
    flip: {
      /** @prop {number} order=600 - Index used to define the order of execution */
      order: 600,
      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
      enabled: true,
      /** @prop {ModifierFn} */
      fn: flip$2,
      /**
       * @prop {String|Array} behavior='flip'
       * The behavior used to change the popper's placement. It can be one of
       * `flip`, `clockwise`, `counterclockwise` or an array with a list of valid
       * placements (with optional variations)
       */
      behavior: "flip",
      /**
       * @prop {number} padding=5
       * The popper will flip if it hits the edges of the `boundariesElement`
       */
      padding: 5,
      /**
       * @prop {String|HTMLElement} boundariesElement='viewport'
       * The element which will define the boundaries of the popper position.
       * The popper will never be placed outside of the defined boundaries
       * (except if `keepTogether` is enabled)
       */
      boundariesElement: "viewport",
      /**
       * @prop {Boolean} flipVariations=false
       * The popper will switch placement variation between `-start` and `-end` when
       * the reference element overlaps its boundaries.
       *
       * The original placement should have a set variation.
       */
      flipVariations: false,
      /**
       * @prop {Boolean} flipVariationsByContent=false
       * The popper will switch placement variation between `-start` and `-end` when
       * the popper element overlaps its reference boundaries.
       *
       * The original placement should have a set variation.
       */
      flipVariationsByContent: false
    },
    /**
     * Modifier used to make the popper flow toward the inner of the reference element.
     * By default, when this modifier is disabled, the popper will be placed outside
     * the reference element.
     * @memberof modifiers
     * @inner
     */
    inner: {
      /** @prop {number} order=700 - Index used to define the order of execution */
      order: 700,
      /** @prop {Boolean} enabled=false - Whether the modifier is enabled or not */
      enabled: false,
      /** @prop {ModifierFn} */
      fn: inner
    },
    /**
     * Modifier used to hide the popper when its reference element is outside of the
     * popper boundaries. It will set a `x-out-of-boundaries` attribute which can
     * be used to hide with a CSS selector the popper when its reference is
     * out of boundaries.
     *
     * Requires the `preventOverflow` modifier before it in order to work.
     * @memberof modifiers
     * @inner
     */
    hide: {
      /** @prop {number} order=800 - Index used to define the order of execution */
      order: 800,
      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
      enabled: true,
      /** @prop {ModifierFn} */
      fn: hide$2
    },
    /**
     * Computes the style that will be applied to the popper element to gets
     * properly positioned.
     *
     * Note that this modifier will not touch the DOM, it just prepares the styles
     * so that `applyStyle` modifier can apply it. This separation is useful
     * in case you need to replace `applyStyle` with a custom implementation.
     *
     * This modifier has `850` as `order` value to maintain backward compatibility
     * with previous versions of Popper.js. Expect the modifiers ordering method
     * to change in future major versions of the library.
     *
     * @memberof modifiers
     * @inner
     */
    computeStyle: {
      /** @prop {number} order=850 - Index used to define the order of execution */
      order: 850,
      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
      enabled: true,
      /** @prop {ModifierFn} */
      fn: computeStyle,
      /**
       * @prop {Boolean} gpuAcceleration=true
       * If true, it uses the CSS 3D transformation to position the popper.
       * Otherwise, it will use the `top` and `left` properties
       */
      gpuAcceleration: true,
      /**
       * @prop {string} [x='bottom']
       * Where to anchor the X axis (`bottom` or `top`). AKA X offset origin.
       * Change this if your popper should grow in a direction different from `bottom`
       */
      x: "bottom",
      /**
       * @prop {string} [x='left']
       * Where to anchor the Y axis (`left` or `right`). AKA Y offset origin.
       * Change this if your popper should grow in a direction different from `right`
       */
      y: "right"
    },
    /**
     * Applies the computed styles to the popper element.
     *
     * All the DOM manipulations are limited to this modifier. This is useful in case
     * you want to integrate Popper.js inside a framework or view library and you
     * want to delegate all the DOM manipulations to it.
     *
     * Note that if you disable this modifier, you must make sure the popper element
     * has its position set to `absolute` before Popper.js can do its work!
     *
     * Just disable this modifier and define your own to achieve the desired effect.
     *
     * @memberof modifiers
     * @inner
     */
    applyStyle: {
      /** @prop {number} order=900 - Index used to define the order of execution */
      order: 900,
      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
      enabled: true,
      /** @prop {ModifierFn} */
      fn: applyStyle,
      /** @prop {Function} */
      onLoad: applyStyleOnLoad,
      /**
       * @deprecated since version 1.10.0, the property moved to `computeStyle` modifier
       * @prop {Boolean} gpuAcceleration=true
       * If true, it uses the CSS 3D transformation to position the popper.
       * Otherwise, it will use the `top` and `left` properties
       */
      gpuAcceleration: undefined
    }
  };

  /**
   * The `dataObject` is an object containing all the information used by Popper.js.
   * This object is passed to modifiers and to the `onCreate` and `onUpdate` callbacks.
   * @name dataObject
   * @property {Object} data.instance The Popper.js instance
   * @property {String} data.placement Placement applied to popper
   * @property {String} data.originalPlacement Placement originally defined on init
   * @property {Boolean} data.flipped True if popper has been flipped by flip modifier
   * @property {Boolean} data.hide True if the reference element is out of boundaries, useful to know when to hide the popper
   * @property {HTMLElement} data.arrowElement Node used as arrow by arrow modifier
   * @property {Object} data.styles Any CSS property defined here will be applied to the popper. It expects the JavaScript nomenclature (eg. `marginBottom`)
   * @property {Object} data.arrowStyles Any CSS property defined here will be applied to the popper arrow. It expects the JavaScript nomenclature (eg. `marginBottom`)
   * @property {Object} data.boundaries Offsets of the popper boundaries
   * @property {Object} data.offsets The measurements of popper, reference and arrow elements
   * @property {Object} data.offsets.popper `top`, `left`, `width`, `height` values
   * @property {Object} data.offsets.reference `top`, `left`, `width`, `height` values
   * @property {Object} data.offsets.arrow] `top` and `left` offsets, only one of them will be different from 0
   */

  /**
   * Default options provided to Popper.js constructor.<br />
   * These can be overridden using the `options` argument of Popper.js.<br />
   * To override an option, simply pass an object with the same
   * structure of the `options` object, as the 3rd argument. For example:
   * ```
   * new Popper(ref, pop, {
   *   modifiers: {
   *     preventOverflow: { enabled: false }
   *   }
   * })
   * ```
   * @type {Object}
   * @static
   * @memberof Popper
   */
  var Defaults = {
    /**
     * Popper's placement.
     * @prop {Popper.placements} placement='bottom'
     */
    placement: "bottom",
    /**
     * Set this to true if you want popper to position it self in 'fixed' mode
     * @prop {Boolean} positionFixed=false
     */
    positionFixed: false,
    /**
     * Whether events (resize, scroll) are initially enabled.
     * @prop {Boolean} eventsEnabled=true
     */
    eventsEnabled: true,
    /**
     * Set to true if you want to automatically remove the popper when
     * you call the `destroy` method.
     * @prop {Boolean} removeOnDestroy=false
     */
    removeOnDestroy: false,
    /**
     * Callback called when the popper is created.<br />
     * By default, it is set to no-op.<br />
     * Access Popper.js instance with `data.instance`.
     * @prop {onCreate}
     */
    onCreate: function onCreate() {},
    /**
     * Callback called when the popper is updated. This callback is not called
     * on the initialization/creation of the popper, but only on subsequent
     * updates.<br />
     * By default, it is set to no-op.<br />
     * Access Popper.js instance with `data.instance`.
     * @prop {onUpdate}
     */
    onUpdate: function onUpdate() {},
    /**
     * List of modifiers used to modify the offsets before they are applied to the popper.
     * They provide most of the functionalities of Popper.js.
     * @prop {modifiers}
     */
    modifiers: modifiers
  };

  /**
   * @callback onCreate
   * @param {dataObject} data
   */

  /**
   * @callback onUpdate
   * @param {dataObject} data
   */

  // Utils
  // Methods
  var Popper = function () {
    /**
     * Creates a new Popper.js instance.
     * @class Popper
     * @param {Element|referenceObject} reference - The reference element used to position the popper
     * @param {Element} popper - The HTML / XML element used as the popper
     * @param {Object} options - Your custom options to override the ones defined in [Defaults](#defaults)
     * @return {Object} instance - The generated Popper.js instance
     */
    function Popper(reference, popper) {
      var _this = this;
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      classCallCheck(this, Popper);
      this.scheduleUpdate = function () {
        return requestAnimationFrame(_this.update);
      };

      // make update() debounced, so that it only runs at most once-per-tick
      this.update = debounce$1$1(this.update.bind(this));

      // with {} we create a new object with the options inside it
      this.options = _extends$2({}, Popper.Defaults, options);

      // init state
      this.state = {
        isDestroyed: false,
        isCreated: false,
        scrollParents: []
      };

      // get reference and popper elements (allow jQuery wrappers)
      this.reference = reference && reference.jquery ? reference[0] : reference;
      this.popper = popper && popper.jquery ? popper[0] : popper;

      // Deep merge modifiers options
      this.options.modifiers = {};
      Object.keys(_extends$2({}, Popper.Defaults.modifiers, options.modifiers)).forEach(function (name) {
        _this.options.modifiers[name] = _extends$2({}, Popper.Defaults.modifiers[name] || {}, options.modifiers ? options.modifiers[name] : {});
      });

      // Refactoring modifiers' list (Object => Array)
      this.modifiers = Object.keys(this.options.modifiers).map(function (name) {
        return _extends$2({
          name: name
        }, _this.options.modifiers[name]);
      })
      // sort the modifiers by order
      .sort(function (a, b) {
        return a.order - b.order;
      });

      // modifiers have the ability to execute arbitrary code when Popper.js get inited
      // such code is executed in the same order of its modifier
      // they could add new properties to their options configuration
      // BE AWARE: don't add options to `options.modifiers.name` but to `modifierOptions`!
      this.modifiers.forEach(function (modifierOptions) {
        if (modifierOptions.enabled && isFunction$1(modifierOptions.onLoad)) {
          modifierOptions.onLoad(_this.reference, _this.popper, _this.options, modifierOptions, _this.state);
        }
      });

      // fire the first update to position the popper in the right place
      this.update();
      var eventsEnabled = this.options.eventsEnabled;
      if (eventsEnabled) {
        // setup event listeners, they will take care of update the position in specific situations
        this.enableEventListeners();
      }
      this.state.eventsEnabled = eventsEnabled;
    }

    // We can't use class properties because they don't get listed in the
    // class prototype and break stuff like Sinon stubs

    createClass(Popper, [{
      key: "update",
      value: function update$$1() {
        return update.call(this);
      }
    }, {
      key: "destroy",
      value: function destroy$$1() {
        return destroy.call(this);
      }
    }, {
      key: "enableEventListeners",
      value: function enableEventListeners$$1() {
        return enableEventListeners.call(this);
      }
    }, {
      key: "disableEventListeners",
      value: function disableEventListeners$$1() {
        return disableEventListeners.call(this);
      }

      /**
       * Schedules an update. It will run on the next UI update available.
       * @method scheduleUpdate
       * @memberof Popper
       */

      /**
       * Collection of utilities useful when writing custom modifiers.
       * Starting from version 1.7, this method is available only if you
       * include `popper-utils.js` before `popper.js`.
       *
       * **DEPRECATION**: This way to access PopperUtils is deprecated
       * and will be removed in v2! Use the PopperUtils module directly instead.
       * Due to the high instability of the methods contained in Utils, we can't
       * guarantee them to follow semver. Use them at your own risk!
       * @static
       * @private
       * @type {Object}
       * @deprecated since version 1.8
       * @member Utils
       * @memberof Popper
       */
    }]);

    return Popper;
  }();

  /**
   * The `referenceObject` is an object that provides an interface compatible with Popper.js
   * and lets you use it as replacement of a real DOM node.<br />
   * You can use this method to position a popper relatively to a set of coordinates
   * in case you don't have a DOM node to use as reference.
   *
   * ```
   * new Popper(referenceObject, popperNode);
   * ```
   *
   * NB: This feature isn't supported in Internet Explorer 10.
   * @name referenceObject
   * @property {Function} data.getBoundingClientRect
   * A function that returns a set of coordinates compatible with the native `getBoundingClientRect` method.
   * @property {number} data.clientWidth
   * An ES6 getter that will return the width of the virtual reference element.
   * @property {number} data.clientHeight
   * An ES6 getter that will return the height of the virtual reference element.
   */

  Popper.Utils = (typeof window !== "undefined" ? window : global).PopperUtils;
  Popper.placements = placements$1;
  Popper.Defaults = Defaults;

  /**!
   * tippy.js v5.0.0-alpha.2
   * (c) 2017-2019 atomiks
   * MIT License
   */

  var version = "5.0.0-alpha.2";
  var idCounter$1 = 1; // Workaround for IE11's lack of new MouseEvent constructor

  var mouseMoveListeners$1 = [];
  /**
   * Creates and returns a Tippy object. We're using a closure pattern instead of
   * a class so that the exposed object API is clean without private members
   * prefixed with `_`.
   */

  function createTippy$1(reference, collectionProps) {
    var props = evaluateProps$1(reference, collectionProps); // If the reference shouldn't have multiple tippys, return null early

    if (!props.multiple && reference._tippy) {
      return null;
    }
    /* =======================  Private members  ======================= */

    var lastTriggerEventType;
    var showTimeout;
    var hideTimeout;
    var scheduleHideAnimationFrame;
    var isBeingDestroyed = false;
    var hasMountCallbackRun = false;
    var didHideDueToDocumentMouseDown = false;
    var normalizedPlacement;
    var currentMountCallback;
    var currentTransitionEndListener;
    var listeners = [];
    var debouncedOnMouseMove = debounce$2(onMouseMove, props.interactiveDebounce);
    /* =======================  Public members  ======================= */

    var id = idCounter$1++;
    var popper = createPopperElement(id, props);
    var popperChildren = getChildren$1(popper);
    var popperInstance = null; // These two elements are static

    var tooltip = popperChildren.tooltip,
      content = popperChildren.content;
    var state = {
      // The current real placement (`data-placement` attribute)
      currentPlacement: props.placement,
      // Does the instance have a pending timeout for show()?
      isScheduledToShow: false,
      // Is the instance currently enabled?
      isEnabled: true,
      // Is the tippy currently showing and not transitioning out?
      isVisible: false,
      // Has the instance been destroyed?
      isDestroyed: false,
      // Is the tippy currently mounted to the DOM?
      isMounted: false,
      // Has the tippy finished transitioning in?
      isShown: false
    };
    var instance = {
      // properties
      id: id,
      reference: reference,
      popper: popper,
      popperChildren: popperChildren,
      popperInstance: popperInstance,
      props: props,
      state: state,
      // methods
      clearDelayTimeouts: clearDelayTimeouts,
      setProps: setProps,
      setContent: setContent,
      show: show,
      hide: hide,
      enable: enable,
      disable: disable,
      destroy: destroy
    };
    /* ==================== Initial instance mutations =================== */

    reference._tippy = instance;
    popper._tippy = instance;
    addTriggersToEventListenersTarget();
    if (!props.lazy) {
      createPopperInstance();
    }
    if (props.showOnCreate) {
      scheduleShow();
    } // Prevent a tippy with a delay from hiding if the cursor left then returned
    // before it started hiding

    popper.addEventListener("mouseenter", function () {
      if (instance.props.interactive && instance.state.isVisible && lastTriggerEventType === "mouseenter") {
        instance.clearDelayTimeouts();
      }
    });
    popper.addEventListener("mouseleave", function () {
      if (instance.props.interactive && lastTriggerEventType === "mouseenter") {
        document.addEventListener("mousemove", debouncedOnMouseMove);
      }
    });
    props.onCreate(instance);
    return instance;
    /* =======================  Private methods  ======================= */

    function getIsVerticalPlacement() {
      return includes(["top", "bottom"], getBasePlacement$2(instance.state.currentPlacement));
    }
    function getIsOppositePlacement() {
      return includes(["bottom", "right"], getBasePlacement$2(instance.state.currentPlacement));
    }
    function getNormalizedTouchSettings() {
      var touch = instance.props.touch;
      return Array.isArray(touch) ? touch : [touch, 0];
    }
    function getIsCustomTouchBehavior() {
      return getNormalizedTouchSettings()[0] === "hold";
    }
    function getTransitionableElements() {
      return [tooltip, content, instance.popperChildren.backdrop];
    }
    function getEventListenersTarget() {
      return instance.props.triggerTarget || reference;
    }
    function cleanupInteractiveMouseListeners() {
      document.body.removeEventListener("mouseleave", scheduleHide);
      document.removeEventListener("mousemove", debouncedOnMouseMove);
      mouseMoveListeners$1 = mouseMoveListeners$1.filter(function (listener) {
        return listener !== debouncedOnMouseMove;
      });
    }
    function onDocumentMouseDown(event) {
      // Clicked on interactive popper
      if (instance.props.interactive && popper.contains(event.target)) {
        return;
      } // Clicked on the event listeners target

      if (getEventListenersTarget().contains(event.target)) {
        if (currentInput$1.isTouch) {
          return;
        }
        if (instance.state.isVisible && includes(instance.props.trigger, "click")) {
          return;
        }
      }
      if (instance.props.hideOnClick === true) {
        instance.clearDelayTimeouts();
        instance.hide(); // `mousedown` event is fired right before `focus`. This lets a tippy with
        // `focus` trigger know that it should not show

        didHideDueToDocumentMouseDown = true;
        setTimeout(function () {
          didHideDueToDocumentMouseDown = false;
        }); // The listener gets added in `scheduleShow()`, but this may be hiding it
        // before it shows, and hide()'s early bail-out behavior can prevent it
        // from being cleaned up

        if (!instance.state.isMounted) {
          removeDocumentMouseDownListener();
        }
      }
    }
    function addDocumentMouseDownListener() {
      document.addEventListener("mousedown", onDocumentMouseDown, true);
    }
    function removeDocumentMouseDownListener() {
      document.removeEventListener("mousedown", onDocumentMouseDown, true);
    }
    function makeSticky() {
      setTransitionDuration$1([popper], isIE ? 0 : instance.props.updateDuration);
      function updatePosition() {
        instance.popperInstance.scheduleUpdate();
        if (instance.state.isMounted) {
          requestAnimationFrame(updatePosition);
        } else {
          setTransitionDuration$1([popper], 0);
        }
      }
      updatePosition();
    }
    function onTransitionedOut(duration, callback) {
      onTransitionEnd(duration, function () {
        if (!instance.state.isVisible && popper.parentNode && popper.parentNode.contains(popper)) {
          callback();
        }
      });
    }
    function onTransitionedIn(duration, callback) {
      onTransitionEnd(duration, callback);
    }
    function onTransitionEnd(duration, callback) {
      /**
       * Listener added as the `transitionend` handler
       */
      function listener(event) {
        if (event.target === tooltip) {
          updateTransitionEndListener$1(tooltip, "remove", listener);
          callback();
        }
      } // Make callback synchronous if duration is 0
      // `transitionend` won't fire otherwise

      if (duration === 0) {
        return callback();
      }
      updateTransitionEndListener$1(tooltip, "remove", currentTransitionEndListener);
      updateTransitionEndListener$1(tooltip, "add", listener);
      currentTransitionEndListener = listener;
    }
    function on(eventType, handler, options) {
      if (options === void 0) {
        options = false;
      }
      getEventListenersTarget().addEventListener(eventType, handler, options);
      listeners.push({
        eventType: eventType,
        handler: handler,
        options: options
      });
    }
    function addTriggersToEventListenersTarget() {
      if (getIsCustomTouchBehavior()) {
        on("touchstart", onTrigger, PASSIVE);
        on("touchend", onMouseLeave, PASSIVE);
      } // `click` for keyboard. Mouse uses `mousedown` (onDocumentMouseDown)

      if (!includes(instance.props.trigger, "click")) {
        on("click", function () {
          if (!currentInput$1.isTouch && instance.props.hideOnClick === true) {
            instance.hide();
          }
        });
      }
      instance.props.trigger.trim().split(" ").forEach(function (eventType) {
        if (eventType === "manual") {
          return;
        }
        on(eventType, onTrigger);
        switch (eventType) {
          case "mouseenter":
            on("mouseleave", onMouseLeave);
            break;
          case "focus":
            on(isIE ? "focusout" : "blur", onBlur);
            break;
        }
      });
    }
    function removeTriggersFromEventListenersTarget() {
      listeners.forEach(function (_ref) {
        var eventType = _ref.eventType,
          handler = _ref.handler,
          options = _ref.options;
        getEventListenersTarget().removeEventListener(eventType, handler, options);
      });
      listeners = [];
    }
    function onTrigger(event) {
      if (didHideDueToDocumentMouseDown || !instance.state.isEnabled || isEventListenerStopped(event)) {
        return;
      }
      if (!instance.state.isVisible) {
        lastTriggerEventType = event.type;
        if (event instanceof MouseEvent) {
          // If scrolling, `mouseenter` events can be fired if the cursor lands
          // over a new target, but `mousemove` events don't get fired. This
          // causes interactive tooltips to get stuck open until the cursor is
          // moved
          mouseMoveListeners$1.forEach(function (listener) {
            return listener(event);
          });
        }
      } // Toggle show/hide when clicking click-triggered tooltips

      if (event.type === "click" && instance.props.hideOnClick !== false && instance.state.isVisible) {
        scheduleHide(event);
      } else {
        var _getNormalizedTouchSe = getNormalizedTouchSettings(),
          value = _getNormalizedTouchSe[0],
          duration = _getNormalizedTouchSe[1];
        if (currentInput$1.isTouch && value === "hold" && duration) {
          // We can hijack the show timeout here, it will be cleared by
          // `scheduleHide()` when necessary
          showTimeout = setTimeout(function () {
            scheduleShow(event);
          }, duration);
        } else {
          scheduleShow(event);
        }
      }
    }
    function onMouseMove(event) {
      var isCursorOverReferenceOrPopper = closestCallback(event.target, function (el) {
        return el === reference || el === popper;
      });
      if (isCursorOverReferenceOrPopper) {
        return;
      }
      if (isCursorOutsideInteractiveBorder$1(getBasePlacement$2(instance.state.currentPlacement), popper.getBoundingClientRect(), event, instance.props)) {
        cleanupInteractiveMouseListeners();
        scheduleHide(event);
      }
    }
    function onMouseLeave(event) {
      if (isEventListenerStopped(event)) {
        return;
      }
      if (instance.props.interactive) {
        document.body.addEventListener("mouseleave", scheduleHide);
        document.addEventListener("mousemove", debouncedOnMouseMove);
        mouseMoveListeners$1.push(debouncedOnMouseMove);
        return;
      }
      scheduleHide(event);
    }
    function onBlur(event) {
      if (event.target !== getEventListenersTarget()) {
        return;
      } // If focus was moved to within the popper

      if (instance.props.interactive && event.relatedTarget && popper.contains(event.relatedTarget)) {
        return;
      }
      scheduleHide(event);
    }
    function isEventListenerStopped(event) {
      var supportsTouch = ("ontouchstart" in window);
      var isTouchEvent = includes(event.type, "touch");
      var isCustomTouch = getIsCustomTouchBehavior();
      return supportsTouch && currentInput$1.isTouch && isCustomTouch && !isTouchEvent || currentInput$1.isTouch && !isCustomTouch && isTouchEvent;
    }
    function createPopperInstance() {
      var _instance$props = instance.props,
        popperOptions = _instance$props.popperOptions,
        placement = _instance$props.placement;
      var arrow = instance.popperChildren.arrow;
      var preventOverflowModifier = getModifier(popperOptions, "preventOverflow"); // Due to the virtual offsets normalization when using `followCursor`, we
      // need to use the opposite placement

      var shift = instance.state.currentPlacement.split("-")[1];
      normalizedPlacement = instance.props.followCursor && shift ? placement.replace(shift, shift === "start" ? "end" : "start") : placement;
      function applyMutations(data) {
        instance.state.currentPlacement = data.placement;
        if (instance.props.flip && !instance.props.flipOnUpdate) {
          if (data.flipped) {
            instance.popperInstance.options.placement = data.placement;
          }
          setFlipModifierEnabled(instance.popperInstance.modifiers, false);
        }
        if (instance.props.escapeWithReference) {
          setEscapeWithReference(instance.popperInstance.modifiers, true);
        }
        tooltip.setAttribute("data-placement", instance.state.currentPlacement);
        if (data.attributes["x-out-of-boundaries"] !== false) {
          tooltip.setAttribute("data-out-of-boundaries", "");
        } else {
          tooltip.removeAttribute("data-out-of-boundaries");
        } // Apply the `distance` prop

        var basePlacement = getBasePlacement$2(instance.state.currentPlacement);
        var tooltipStyles = tooltip.style;
        tooltipStyles.top = "0";
        tooltipStyles.left = "0";
        tooltipStyles[getIsVerticalPlacement() ? "top" : "left"] = (getIsOppositePlacement() ? 1 : -1) * instance.props.distance + "px";
        var padding = preventOverflowModifier && preventOverflowModifier.padding !== undefined ? preventOverflowModifier.padding : PREVENT_OVERFLOW_PADDING;
        var isPaddingNumber = typeof padding === "number";
        var computedPadding = _extends$1({
          top: isPaddingNumber ? padding : padding.top,
          bottom: isPaddingNumber ? padding : padding.bottom,
          left: isPaddingNumber ? padding : padding.left,
          right: isPaddingNumber ? padding : padding.right
        }, !isPaddingNumber && padding);
        computedPadding[basePlacement] = isPaddingNumber ? padding + instance.props.distance : (padding[basePlacement] || 0) + instance.props.distance;
        instance.popperInstance.modifiers.filter(function (m) {
          return m.name === "preventOverflow";
        })[0].padding = computedPadding;
      }
      var config = _extends$1({
        eventsEnabled: false,
        placement: normalizedPlacement
      }, popperOptions, {
        modifiers: _extends$1({}, popperOptions ? popperOptions.modifiers : {}, {
          preventOverflow: _extends$1({
            boundariesElement: instance.props.boundary,
            padding: PREVENT_OVERFLOW_PADDING
          }, preventOverflowModifier),
          arrow: _extends$1({
            element: arrow,
            enabled: !!arrow
          }, getModifier(popperOptions, "arrow")),
          flip: _extends$1({
            enabled: instance.props.flip,
            // The tooltip is offset by 10px from the popper in CSS,
            // we need to account for its distance
            padding: instance.props.distance + PREVENT_OVERFLOW_PADDING,
            behavior: instance.props.flipBehavior
          }, getModifier(popperOptions, "flip")),
          offset: _extends$1({
            offset: instance.props.offset
          }, getModifier(popperOptions, "offset"))
        }),
        onCreate: function onCreate(data) {
          applyMutations(data);
          preserveInvocation(popperOptions && popperOptions.onCreate, config.onCreate, [data]);
          runMountCallback();
        },
        onUpdate: function onUpdate(data) {
          applyMutations(data);
          preserveInvocation(popperOptions && popperOptions.onUpdate, config.onUpdate, [data]);
          runMountCallback();
        }
      });
      instance.popperInstance = new Popper(reference, popper, config);
    }
    function runMountCallback() {
      if (!hasMountCallbackRun && currentMountCallback) {
        hasMountCallbackRun = true;
        reflow(popper);
        currentMountCallback();
      }
    }
    function mount() {
      // The mounting callback (`currentMountCallback`) is only run due to a
      // popperInstance update/create
      hasMountCallbackRun = false;
      var appendTo = instance.props.appendTo;
      var parentNode = appendTo === "parent" ? reference.parentNode : invokeWithArgsOrReturn$1(appendTo, [reference]); // The popper element needs to exist on the DOM before its position can be
      // updated as Popper.js needs to read its dimensions

      if (!parentNode.contains(popper)) {
        parentNode.appendChild(popper);
      }
      if (instance.popperInstance) {
        setFlipModifierEnabled(instance.popperInstance.modifiers, instance.props.flip);
        instance.popperInstance.enableEventListeners(); // Mounting callback invoked in `onUpdate`

        instance.popperInstance.scheduleUpdate();
      } else {
        // Mounting callback invoked in `onCreate`
        createPopperInstance();
        instance.popperInstance.enableEventListeners();
      }
    }
    function scheduleShow(event) {
      instance.clearDelayTimeouts();
      instance.state.isScheduledToShow = true;
      if (!instance.popperInstance) {
        createPopperInstance();
      }
      if (event) {
        instance.props.onTrigger(instance, event);
      }
      if (instance.props.wait) {
        return instance.props.wait(instance, event);
      }
      addDocumentMouseDownListener();
      var delay = getValue(instance.props.delay, 0, defaultProps$1.delay);
      if (delay) {
        showTimeout = setTimeout(function () {
          instance.show();
        }, delay);
      } else {
        instance.show();
      }
    }
    function scheduleHide(event) {
      instance.clearDelayTimeouts();
      instance.props.onUntrigger(instance, event);
      if (!instance.state.isVisible) {
        removeDocumentMouseDownListener();
        return;
      }
      instance.state.isScheduledToShow = false;
      var delay = getValue(instance.props.delay, 1, defaultProps$1.delay);
      if (delay) {
        hideTimeout = setTimeout(function () {
          if (instance.state.isVisible) {
            instance.hide();
          }
        }, delay);
      } else {
        // Fixes a `transitionend` problem when it fires 1 frame too
        // late sometimes, we don't want hide() to be called.
        scheduleHideAnimationFrame = requestAnimationFrame(function () {
          instance.hide();
        });
      }
    }
    /* =======================  Public methods  ======================= */

    function enable() {
      instance.state.isEnabled = true;
    }
    function disable() {
      instance.state.isEnabled = false;
    }
    function clearDelayTimeouts() {
      clearTimeout(showTimeout);
      clearTimeout(hideTimeout);
      cancelAnimationFrame(scheduleHideAnimationFrame);
    }
    function setProps(partialProps) {
      if (instance.state.isDestroyed) {
        return;
      }
      removeTriggersFromEventListenersTarget();
      var prevProps = instance.props;
      var nextProps = evaluateProps$1(reference, _extends$1({}, instance.props, partialProps, {
        ignoreAttributes: true
      }));
      nextProps.ignoreAttributes = hasOwnProperty(partialProps, "ignoreAttributes") ? partialProps.ignoreAttributes || false : prevProps.ignoreAttributes;
      instance.props = nextProps;
      addTriggersToEventListenersTarget();
      cleanupInteractiveMouseListeners();
      debouncedOnMouseMove = debounce$2(onMouseMove, nextProps.interactiveDebounce);
      updatePopperElement(popper, prevProps, nextProps, instance.state.isVisible);
      instance.popperChildren = getChildren$1(popper);
      if (instance.popperInstance) {
        if (POPPER_INSTANCE_DEPENDENCIES.some(function (prop) {
          return hasOwnProperty(partialProps, prop) && partialProps[prop] !== prevProps[prop];
        })) {
          instance.popperInstance.destroy();
          createPopperInstance();
          if (instance.state.isVisible) {
            instance.popperInstance.enableEventListeners();
          }
        } else {
          instance.popperInstance.update();
        }
      }
    }
    function setContent(content) {
      instance.setProps({
        content: content
      });
    }
    function show(duration, shouldPreventPopperTransition) {
      if (duration === void 0) {
        duration = getValue(instance.props.duration, 0, defaultProps$1.duration[1]);
      }
      if (shouldPreventPopperTransition === void 0) {
        shouldPreventPopperTransition = true;
      }
      var isAlreadyVisible = instance.state.isVisible;
      var isDestroyed = instance.state.isDestroyed;
      var isDisabled = !instance.state.isEnabled;
      var isTouchAndTouchDisabled = currentInput$1.isTouch && !instance.props.touch;
      if (isAlreadyVisible || isDestroyed || isDisabled || isTouchAndTouchDisabled) {
        return;
      } // Normalize `disabled` behavior across browsers.
      // Firefox allows events on disabled elements, but Chrome doesn't.
      // Using a wrapper element (i.e. <span>) is recommended.

      if (getEventListenersTarget().hasAttribute("disabled")) {
        return;
      }
      if (instance.props.onShow(instance) === false) {
        return;
      }
      addDocumentMouseDownListener();
      popper.style.visibility = "visible";
      instance.state.isVisible = true; // Prevent a transition of the popper from its previous position and of the
      // elements at a different placement.

      var transitionableElements = getTransitionableElements();
      setTransitionDuration$1(shouldPreventPopperTransition ? transitionableElements.concat(popper) : transitionableElements, 0);
      currentMountCallback = function currentMountCallback() {
        if (!instance.state.isVisible) {
          return;
        } // Double update will apply correct mutations

        instance.popperInstance.update();
        instance.props.onMount(instance);
        instance.state.isMounted = true; // The content should fade in after the backdrop has mostly filled the
        // tooltip element. `clip-path` is the other alternative but is not well-
        // supported and is buggy on some devices.

        content.style.transitionDelay = instance.popperChildren.backdrop ? Math.round(duration / 12) + "ms" : "";
        if (instance.props.sticky) {
          makeSticky();
        }
        setTransitionDuration$1([popper], instance.props.updateDuration);
        setTransitionDuration$1(transitionableElements, duration);
        setVisibilityState$1(transitionableElements, "visible");
        onTransitionedIn(duration, function () {
          if (instance.props.aria) {
            getEventListenersTarget().setAttribute("aria-" + instance.props.aria, tooltip.id);
          }
          instance.props.onShown(instance);
          instance.state.isShown = true;
        });
      };
      mount();
    }
    function hide(duration) {
      if (duration === void 0) {
        duration = getValue(instance.props.duration, 1, defaultProps$1.duration[1]);
      }
      var isAlreadyHidden = !instance.state.isVisible && !isBeingDestroyed;
      var isDestroyed = instance.state.isDestroyed;
      var isDisabled = !instance.state.isEnabled && !isBeingDestroyed;
      if (isAlreadyHidden || isDestroyed || isDisabled) {
        return;
      }
      if (instance.props.onHide(instance) === false && !isBeingDestroyed) {
        return;
      }
      removeDocumentMouseDownListener();
      popper.style.visibility = "hidden";
      instance.state.isVisible = false;
      instance.state.isShown = false;
      var transitionableElements = getTransitionableElements();
      setTransitionDuration$1(transitionableElements, duration);
      setVisibilityState$1(transitionableElements, "hidden");
      onTransitionedOut(duration, function () {
        if (instance.props.aria) {
          getEventListenersTarget().removeAttribute("aria-" + instance.props.aria);
        }
        instance.popperInstance.disableEventListeners();
        instance.popperInstance.options.placement = normalizedPlacement;
        popper.parentNode.removeChild(popper);
        instance.props.onHidden(instance);
        instance.state.isMounted = false;
      });
    }
    function destroy() {
      if (instance.state.isDestroyed) {
        return;
      }
      isBeingDestroyed = true;
      instance.hide(0);
      removeTriggersFromEventListenersTarget();
      delete reference._tippy;
      if (instance.popperInstance) {
        instance.popperInstance.destroy();
      }
      isBeingDestroyed = false;
      instance.state.isDestroyed = true;
    }
  }

  /**
   * Exported module
   */
  function tippy$1(targets, optionalProps) {
    bindGlobalEventListeners$1();
    var props = _extends$1({}, defaultProps$1, optionalProps);
    var elements = getArrayOfElements$1(targets);
    var instances = elements.reduce(function (acc, reference) {
      var instance = reference && createTippy$1(reference, props);
      if (instance) {
        acc.push(instance);
      }
      return acc;
    }, []);
    return isRealElement(targets) ? instances[0] : instances;
  }
  tippy$1.version = version;
  tippy$1.defaultProps = defaultProps$1;
  tippy$1.currentInput = currentInput$1;
  /**
   * Mutates the defaultProps object by setting the props specified
   */

  tippy$1.setDefaultProps = function (partialProps) {
    Object.keys(partialProps).forEach(function (key) {
      // @ts-ignore
      defaultProps$1[key] = partialProps[key];
    });
  };
  /**
   * Hides all visible poppers on the document
   */

  tippy$1.hideAll = function (_temp) {
    var _ref = _temp === void 0 ? {} : _temp,
      excludedReferenceOrInstance = _ref.exclude,
      duration = _ref.duration;
    arrayFrom$1(document.querySelectorAll(POPPER_SELECTOR)).forEach(function (popper) {
      var instance = popper._tippy;
      if (instance) {
        var isExcluded = false;
        if (excludedReferenceOrInstance) {
          isExcluded = isReferenceElement$1(excludedReferenceOrInstance) ? instance.reference === excludedReferenceOrInstance : popper === excludedReferenceOrInstance.popper;
        }
        if (!isExcluded) {
          instance.hide(duration);
        }
      }
    });
  };
  /**
   * Auto-init tooltips for elements with a `data-tippy="..."` attribute
   */

  function autoInit() {
    arrayFrom$1(document.querySelectorAll("[data-tippy]")).forEach(function (el) {
      var content = el.getAttribute("data-tippy");
      if (content) {
        tippy$1(el, {
          content: content
        });
      }
    });
  }
  if (isBrowser$1) {
    setTimeout(autoInit);
  }

  /**!
   * tippy.js v5.0.0-alpha.2
   * (c) 2017-2019 atomiks
   * MIT License
   */

  var css = ".tippy-tooltip[data-animation=fade][data-state=hidden]{opacity:0}.tippy-iOS{cursor:pointer!important;-webkit-tap-highlight-color:transparent}.tippy-popper{pointer-events:none;max-width:calc(100% - 8px);transition-timing-function:cubic-bezier(.165,.84,.44,1)}.tippy-tooltip{position:relative;color:#fff;border-radius:.25rem;font-size:.875rem;line-height:1.4;background-color:#333;overflow:hidden;transition-property:visibility,opacity,transform;outline:0}.tippy-tooltip[data-placement^=top] .tippy-arrow{border-width:8px 8px 0;border-top-color:#333;margin:0 3px;transform-origin:50% 0;bottom:-8px}.tippy-tooltip[data-placement^=bottom] .tippy-arrow{border-width:0 8px 8px;border-bottom-color:#333;margin:0 3px;transform-origin:50% 7px;top:-8px}.tippy-tooltip[data-placement^=left] .tippy-arrow{border-width:8px 0 8px 8px;border-left-color:#333;margin:3px 0;transform-origin:0 50%;right:-8px}.tippy-tooltip[data-placement^=right] .tippy-arrow{border-width:8px 8px 8px 0;border-right-color:#333;margin:3px 0;transform-origin:7px 50%;left:-8px}.tippy-tooltip[data-arrow]{overflow:visible}.tippy-tooltip[data-animatefill]{background-color:transparent!important}.tippy-tooltip[data-interactive]{pointer-events:auto}.tippy-tooltip[data-inertia][data-state=visible]{transition-timing-function:cubic-bezier(.54,1.5,.38,1.11)}.tippy-tooltip[data-inertia][data-state=hidden]{transition-timing-function:ease}.tippy-arrow{border-color:transparent;border-style:solid;position:absolute}.tippy-arrow[data-state=hidden]{opacity:0}.tippy-content{padding:.3125rem .5625rem}";

  /**
   * Injects a string of CSS styles to a style node in <head>
   */

  function injectCSS(css) {
    if (isBrowser$1) {
      var style = document.createElement("style");
      style.textContent = css;
      style.setAttribute("data-tippy-stylesheet", "");
      var head = document.head;
      var firstStyleOrLinkTag = head.querySelector("style,link");
      if (firstStyleOrLinkTag) {
        head.insertBefore(style, firstStyleOrLinkTag);
      } else {
        head.appendChild(style);
      }
    }
  }
  injectCSS(css);
  var missingTippy = "Using the attachment feature of Shepherd requires the Tippy.js library";
  var addShepherdClass = _createClassModifier("shepherd");
  var addHasTitleClass = _createClassModifier("shepherd-has-title");
  var centeredStylePopperModifier = {
    computeStyle: {
      enabled: true,
      fn: function fn(data) {
        data.styles = _extends({}, data.styles, {
          left: "50%",
          top: "50%",
          transform: "translate(-50%, -50%)"
        });
        return data;
      }
    },
    addShepherdClass: addShepherdClass
  }; // Used to compose settings for tippyOptions.popperOptions (https://atomiks.github.io/tippyjs/#popper-options-option)

  var defaultPopperOptions = {
    positionFixed: true,
    modifiers: {
      addShepherdClass: addShepherdClass
    }
  };
  /**
   * TODO rewrite the way items are being added to use more performant documentFragment code
   * @param html
   * @return {HTMLElement} The element created from the passed HTML string
   */

  function createFromHTML(html) {
    var el = document.createElement("div");
    el.innerHTML = html;
    return el.children[0];
  }
  /**
   * Returns a function, that, as long as it continues to be invoked, will not
   * be triggered. The function will be called after it stops being called for
   * N milliseconds. If `immediate` is passed, trigger the function on the
   * leading edge, instead of the trailing.
   * @param {Function} func The function to invoke
   * @param {Number} wait The time to wait in ms
   * @param {Boolean} immediate If true, the function will be invoked immediately
   * @return {Function}
   */

  function debounce$2$1(func, wait, immediate) {
    var timeout;
    return function () {
      var context = this;
      var args = arguments;
      var later = function later() {
        timeout = null;
        if (!immediate) {
          func.apply(context, args);
        }
      };
      var callNow = immediate && !timeout;
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
      if (callNow) {
        func.apply(context, args);
      }
    };
  }
  /**
   * Creates a slice of `arr` with n elements dropped from the beginning.
   * @param {Array} arr
   * @param {Number} n
   * @return {*}
   */

  function drop(arr) {
    var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    if (Array.isArray(arr)) {
      return arr.slice(n);
    }
    return [];
  }
  /**
   * Determines options for the tooltip and initializes
   * `this.tooltip` as a Tippy.js instance.
   */

  function setupTooltip() {
    if (isUndefined(tippy$1)) {
      throw new Error(missingTippy);
    }
    if (this.tooltip) {
      this.tooltip.destroy();
    }
    var attachToOpts = this.parseAttachTo();
    this.tooltip = _makeTippyInstance.call(this, attachToOpts);
    this.target = attachToOpts.element || document.body;
    this.el.classList.add("shepherd-element");
  }
  /**
   * Checks if options.attachTo.element is a string, and if so, tries to find the element
   * @returns {({} & {element, on}) | ({})}
   * `element` is a qualified HTML Element
   * `on` is a string position value
   */

  function parseAttachTo() {
    var options = this.options.attachTo || {};
    var returnOpts = _extends({}, options);
    if (isString(options.element)) {
      // Can't override the element in user opts reference because we can't
      // guarantee that the element will exist in the future.
      try {
        returnOpts.element = document.querySelector(options.element);
      } catch (e) {
        // TODO
      }
      if (!returnOpts.element) {
        console.error("The element for this Shepherd step was not found ".concat(options.element));
      }
    }
    return returnOpts;
  }
  /**
   * Create a popper modifier for adding the passed className to the popper
   * @param {string} className The class to add to the popper
   * @return {{fn(*): *, enabled: boolean}|*}
   * @private
   */

  function _createClassModifier(className) {
    return {
      enabled: true,
      fn: function fn(data) {
        data.instance.popper.classList.add(className);
        return data;
      }
    };
  }
  /**
   * Generates a `Tippy` instance from a set of base `attachTo` options
   *
   * @return {tippy} The final tippy instance
   * @private
   */

  function _makeTippyInstance(attachToOptions) {
    if (!attachToOptions.element) {
      return _makeCenteredTippy.call(this);
    }
    var tippyOptions = _makeAttachedTippyOptions.call(this, attachToOptions);
    return tippy$1(attachToOptions.element, tippyOptions);
  }
  /**
   * Generates the hash of options that will be passed to `Tippy` instances
   * target an element in the DOM.
   *
   * @param {Object} attachToOptions The local `attachTo` options
   * @return {Object} The final tippy options  object
   * @private
   */

  function _makeAttachedTippyOptions(attachToOptions) {
    var resultingTippyOptions = {
      content: this.el,
      flipOnUpdate: true,
      placement: attachToOptions.on || "right"
    };
    _extends(resultingTippyOptions, this.options.tippyOptions);
    if (this.options.title) {
      _extends(defaultPopperOptions.modifiers, {
        addHasTitleClass: addHasTitleClass
      });
    }
    if (this.options.tippyOptions && this.options.tippyOptions.popperOptions) {
      _extends(defaultPopperOptions, this.options.tippyOptions.popperOptions);
    }
    resultingTippyOptions.popperOptions = defaultPopperOptions;
    return resultingTippyOptions;
  }
  /**
   * Generates a `Tippy` instance for a tooltip that doesn't have a
   * target element in the DOM -- and thus is positioned in the center
   * of the view
   *
   * @return {tippy} The final tippy instance
   * @private
   */

  function _makeCenteredTippy() {
    var tippyOptions = _objectSpread2({
      content: this.el,
      placement: "top"
    }, this.options.tippyOptions);
    tippyOptions.arrow = false;
    tippyOptions.popperOptions = tippyOptions.popperOptions || {};
    if (this.options.title) {
      _extends(defaultPopperOptions.modifiers, {
        addHasTitleClass: addHasTitleClass
      });
    }
    var finalPopperOptions = _extends({}, defaultPopperOptions, tippyOptions.popperOptions, {
      modifiers: _extends(centeredStylePopperModifier, tippyOptions.popperOptions.modifiers)
    });
    tippyOptions.popperOptions = finalPopperOptions;
    return tippy$1(document.body, tippyOptions);
  }
  var Evented = /*#__PURE__*/
  function () {
    function Evented() {
      _classCallCheck(this, Evented);
    }
    _createClass(Evented, [{
      key: "on",
      value: function on(event, handler, ctx) {
        var once = arguments.length <= 3 || arguments[3] === undefined ? false : arguments[3];
        if (isUndefined(this.bindings)) {
          this.bindings = {};
        }
        if (isUndefined(this.bindings[event])) {
          this.bindings[event] = [];
        }
        this.bindings[event].push({
          handler: handler,
          ctx: ctx,
          once: once
        });
      }
    }, {
      key: "once",
      value: function once(event, handler, ctx) {
        this.on(event, handler, ctx, true);
      }
    }, {
      key: "off",
      value: function off(event, handler) {
        var _this = this;
        if (isUndefined(this.bindings) || isUndefined(this.bindings[event])) {
          return false;
        }
        if (isUndefined(handler)) {
          delete this.bindings[event];
        } else {
          this.bindings[event].forEach(function (binding, index) {
            if (binding.handler === handler) {
              _this.bindings[event].splice(index, 1);
            }
          });
        }
      }
    }, {
      key: "trigger",
      value: function trigger(event) {
        var _this2 = this;
        if (!isUndefined(this.bindings) && this.bindings[event]) {
          var args = drop(Array.prototype.slice.call(arguments));
          this.bindings[event].forEach(function (binding, index) {
            var ctx = binding.ctx,
              handler = binding.handler,
              once = binding.once;
            var context = ctx || _this2;
            handler.apply(context, args);
            if (once) {
              _this2.bindings[event].splice(index, 1);
            }
          });
        }
      }
    }]);
    return Evented;
  }();

  /**
   * Sets up the handler to determine if we should advance the tour
   * @param selector
   * @return {Function}
   * @private
   */

  function _setupAdvanceOnHandler(selector) {
    var _this = this;
    return function (event) {
      if (_this.isOpen()) {
        var targetIsEl = _this.el && event.target === _this.el;
        var targetIsSelector = !isUndefined(selector) && event.target.matches(selector);
        if (targetIsSelector || targetIsEl) {
          _this.tour.next();
        }
      }
    };
  }
  /**
   * Bind the event handler for advanceOn
   */

  function bindAdvance() {
    // An empty selector matches the step element
    var _ref = this.options.advanceOn || {},
      event = _ref.event,
      selector = _ref.selector;
    if (event) {
      var handler = _setupAdvanceOnHandler.call(this, selector); // TODO: this should also bind/unbind on show/hide

      var el;
      try {
        el = document.querySelector(selector);
      } catch (e) {
        // TODO
      }
      if (!isUndefined(selector) && !el) {
        return console.error("No element was found for the selector supplied to advanceOn: ".concat(selector));
      } else if (el) {
        el.addEventListener(event, handler);
        this.on("destroy", function () {
          return el.removeEventListener(event, handler);
        });
      } else {
        document.body.addEventListener(event, handler, true);
        this.on("destroy", function () {
          return document.body.removeEventListener(event, handler, true);
        });
      }
    } else {
      return console.error("advanceOn was defined, but no event name was passed.");
    }
  }
  /**
   * Bind events to the buttons for next, back, etc
   * @param {Object} cfg An object containing the config options for the button
   * @param {HTMLElement} el The element for the button
   */

  function bindButtonEvents(cfg, el) {
    var _this2 = this;
    cfg.events = cfg.events || {};
    if (!isUndefined(cfg.action)) {
      // Including both a click event and an action is not supported
      cfg.events.click = cfg.action;
    }
    if (cfg.events) {
      Object.entries(cfg.events).forEach(function (_ref2) {
        var _ref3 = _slicedToArray(_ref2, 2),
          event = _ref3[0],
          handler = _ref3[1];
        if (isString(handler)) {
          var page = handler;
          handler = function handler() {
            return _this2.tour.show(page);
          };
        }
        el.dataset.buttonEvent = true;
        el.addEventListener(event, handler); // Cleanup event listeners on destroy

        _this2.on("destroy", function () {
          el.removeAttribute("data-button-event");
          el.removeEventListener(event, handler);
        });
      });
    }
  }
  /**
   * Add a click listener to the cancel link that cancels the tour
   * @param {HTMLElement} link The cancel link element
   */

  function bindCancelLink(link) {
    var _this3 = this;
    link.addEventListener("click", function (e) {
      e.preventDefault();
      _this3.cancel();
    });
  }
  /**
   * Take an array of strings and look up methods by name, then bind them to `this`
   * @param {String[]} methods The names of methods to bind
   */

  function bindMethods(methods) {
    var _this4 = this;
    methods.map(function (method) {
      _this4[method] = _this4[method].bind(_this4);
    });
  }
  if (!Element.prototype.matches) {
    Element.prototype.matches = Element.prototype.matchesSelector || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
  }
  function createCommonjsModule(fn, module) {
    return module = {
      exports: {}
    }, fn(module, module.exports), module.exports;
  }
  var smoothscroll = createCommonjsModule(function (module, exports) {
    /* smoothscroll v0.4.4 - 2019 - Dustan Kasten, Jeremias Menichelli - MIT License */
    (function () {
      // polyfill
      function polyfill() {
        // aliases
        var w = window;
        var d = document;

        // return if scroll behavior is supported and polyfill is not forced
        if ("scrollBehavior" in d.documentElement.style && w.__forceSmoothScrollPolyfill__ !== true) {
          return;
        }

        // globals
        var Element = w.HTMLElement || w.Element;
        var SCROLL_TIME = 468;

        // object gathering original scroll methods
        var original = {
          scroll: w.scroll || w.scrollTo,
          scrollBy: w.scrollBy,
          elementScroll: Element.prototype.scroll || scrollElement,
          scrollIntoView: Element.prototype.scrollIntoView
        };

        // define timing method
        var now = w.performance && w.performance.now ? w.performance.now.bind(w.performance) : Date.now;

        /**
         * indicates if a the current browser is made by Microsoft
         * @method isMicrosoftBrowser
         * @param {String} userAgent
         * @returns {Boolean}
         */
        function isMicrosoftBrowser(userAgent) {
          var userAgentPatterns = ["MSIE ", "Trident/", "Edge/"];
          return new RegExp(userAgentPatterns.join("|")).test(userAgent);
        }

        /*
         * IE has rounding bug rounding down clientHeight and clientWidth and
         * rounding up scrollHeight and scrollWidth causing false positives
         * on hasScrollableSpace
         */
        var ROUNDING_TOLERANCE = isMicrosoftBrowser(w.navigator.userAgent) ? 1 : 0;

        /**
         * changes scroll position inside an element
         * @method scrollElement
         * @param {Number} x
         * @param {Number} y
         * @returns {undefined}
         */
        function scrollElement(x, y) {
          this.scrollLeft = x;
          this.scrollTop = y;
        }

        /**
         * returns result of applying ease math function to a number
         * @method ease
         * @param {Number} k
         * @returns {Number}
         */
        function ease(k) {
          return 0.5 * (1 - Math.cos(Math.PI * k));
        }

        /**
         * indicates if a smooth behavior should be applied
         * @method shouldBailOut
         * @param {Number|Object} firstArg
         * @returns {Boolean}
         */
        function shouldBailOut(firstArg) {
          if (firstArg === null || _typeof$1(firstArg) !== "object" || firstArg.behavior === undefined || firstArg.behavior === "auto" || firstArg.behavior === "instant") {
            // first argument is not an object/null
            // or behavior is auto, instant or undefined
            return true;
          }
          if (_typeof$1(firstArg) === "object" && firstArg.behavior === "smooth") {
            // first argument is an object and behavior is smooth
            return false;
          }

          // throw error when behavior is not supported
          throw new TypeError("behavior member of ScrollOptions " + firstArg.behavior + " is not a valid value for enumeration ScrollBehavior.");
        }

        /**
         * indicates if an element has scrollable space in the provided axis
         * @method hasScrollableSpace
         * @param {Node} el
         * @param {String} axis
         * @returns {Boolean}
         */
        function hasScrollableSpace(el, axis) {
          if (axis === "Y") {
            return el.clientHeight + ROUNDING_TOLERANCE < el.scrollHeight;
          }
          if (axis === "X") {
            return el.clientWidth + ROUNDING_TOLERANCE < el.scrollWidth;
          }
        }

        /**
         * indicates if an element has a scrollable overflow property in the axis
         * @method canOverflow
         * @param {Node} el
         * @param {String} axis
         * @returns {Boolean}
         */
        function canOverflow(el, axis) {
          var overflowValue = w.getComputedStyle(el, null)["overflow" + axis];
          return overflowValue === "auto" || overflowValue === "scroll";
        }

        /**
         * indicates if an element can be scrolled in either axis
         * @method isScrollable
         * @param {Node} el
         * @param {String} axis
         * @returns {Boolean}
         */
        function isScrollable(el) {
          var isScrollableY = hasScrollableSpace(el, "Y") && canOverflow(el, "Y");
          var isScrollableX = hasScrollableSpace(el, "X") && canOverflow(el, "X");
          return isScrollableY || isScrollableX;
        }

        /**
         * finds scrollable parent of an element
         * @method findScrollableParent
         * @param {Node} el
         * @returns {Node} el
         */
        function findScrollableParent(el) {
          while (el !== d.body && isScrollable(el) === false) {
            el = el.parentNode || el.host;
          }
          return el;
        }

        /**
         * self invoked function that, given a context, steps through scrolling
         * @method step
         * @param {Object} context
         * @returns {undefined}
         */
        function step(context) {
          var time = now();
          var value;
          var currentX;
          var currentY;
          var elapsed = (time - context.startTime) / SCROLL_TIME;

          // avoid elapsed times higher than one
          elapsed = elapsed > 1 ? 1 : elapsed;

          // apply easing to elapsed time
          value = ease(elapsed);
          currentX = context.startX + (context.x - context.startX) * value;
          currentY = context.startY + (context.y - context.startY) * value;
          context.method.call(context.scrollable, currentX, currentY);

          // scroll more if we have not reached our destination
          if (currentX !== context.x || currentY !== context.y) {
            w.requestAnimationFrame(step.bind(w, context));
          }
        }

        /**
         * scrolls window or element with a smooth behavior
         * @method smoothScroll
         * @param {Object|Node} el
         * @param {Number} x
         * @param {Number} y
         * @returns {undefined}
         */
        function smoothScroll(el, x, y) {
          var scrollable;
          var startX;
          var startY;
          var method;
          var startTime = now();

          // define scroll context
          if (el === d.body) {
            scrollable = w;
            startX = w.scrollX || w.pageXOffset;
            startY = w.scrollY || w.pageYOffset;
            method = original.scroll;
          } else {
            scrollable = el;
            startX = el.scrollLeft;
            startY = el.scrollTop;
            method = scrollElement;
          }

          // scroll looping over a frame
          step({
            scrollable: scrollable,
            method: method,
            startTime: startTime,
            startX: startX,
            startY: startY,
            x: x,
            y: y
          });
        }

        // ORIGINAL METHODS OVERRIDES
        // w.scroll and w.scrollTo
        w.scroll = w.scrollTo = function () {
          // avoid action when no arguments are passed
          if (arguments[0] === undefined) {
            return;
          }

          // avoid smooth behavior if not required
          if (shouldBailOut(arguments[0]) === true) {
            original.scroll.call(w, arguments[0].left !== undefined ? arguments[0].left : _typeof$1(arguments[0]) !== "object" ? arguments[0] : w.scrollX || w.pageXOffset,
            // use top prop, second argument if present or fallback to scrollY
            arguments[0].top !== undefined ? arguments[0].top : arguments[1] !== undefined ? arguments[1] : w.scrollY || w.pageYOffset);
            return;
          }

          // LET THE SMOOTHNESS BEGIN!
          smoothScroll.call(w, d.body, arguments[0].left !== undefined ? ~~arguments[0].left : w.scrollX || w.pageXOffset, arguments[0].top !== undefined ? ~~arguments[0].top : w.scrollY || w.pageYOffset);
        };

        // w.scrollBy
        w.scrollBy = function () {
          // avoid action when no arguments are passed
          if (arguments[0] === undefined) {
            return;
          }

          // avoid smooth behavior if not required
          if (shouldBailOut(arguments[0])) {
            original.scrollBy.call(w, arguments[0].left !== undefined ? arguments[0].left : _typeof$1(arguments[0]) !== "object" ? arguments[0] : 0, arguments[0].top !== undefined ? arguments[0].top : arguments[1] !== undefined ? arguments[1] : 0);
            return;
          }

          // LET THE SMOOTHNESS BEGIN!
          smoothScroll.call(w, d.body, ~~arguments[0].left + (w.scrollX || w.pageXOffset), ~~arguments[0].top + (w.scrollY || w.pageYOffset));
        };

        // Element.prototype.scroll and Element.prototype.scrollTo
        Element.prototype.scroll = Element.prototype.scrollTo = function () {
          // avoid action when no arguments are passed
          if (arguments[0] === undefined) {
            return;
          }

          // avoid smooth behavior if not required
          if (shouldBailOut(arguments[0]) === true) {
            // if one number is passed, throw error to match Firefox implementation
            if (typeof arguments[0] === "number" && arguments[1] === undefined) {
              throw new SyntaxError("Value could not be converted");
            }
            original.elementScroll.call(this,
            // use left prop, first number argument or fallback to scrollLeft
            arguments[0].left !== undefined ? ~~arguments[0].left : _typeof$1(arguments[0]) !== "object" ? ~~arguments[0] : this.scrollLeft,
            // use top prop, second argument or fallback to scrollTop
            arguments[0].top !== undefined ? ~~arguments[0].top : arguments[1] !== undefined ? ~~arguments[1] : this.scrollTop);
            return;
          }
          var left = arguments[0].left;
          var top = arguments[0].top;

          // LET THE SMOOTHNESS BEGIN!
          smoothScroll.call(this, this, typeof left === "undefined" ? this.scrollLeft : ~~left, typeof top === "undefined" ? this.scrollTop : ~~top);
        };

        // Element.prototype.scrollBy
        Element.prototype.scrollBy = function () {
          // avoid action when no arguments are passed
          if (arguments[0] === undefined) {
            return;
          }

          // avoid smooth behavior if not required
          if (shouldBailOut(arguments[0]) === true) {
            original.elementScroll.call(this, arguments[0].left !== undefined ? ~~arguments[0].left + this.scrollLeft : ~~arguments[0] + this.scrollLeft, arguments[0].top !== undefined ? ~~arguments[0].top + this.scrollTop : ~~arguments[1] + this.scrollTop);
            return;
          }
          this.scroll({
            left: ~~arguments[0].left + this.scrollLeft,
            top: ~~arguments[0].top + this.scrollTop,
            behavior: arguments[0].behavior
          });
        };

        // Element.prototype.scrollIntoView
        Element.prototype.scrollIntoView = function () {
          // avoid smooth behavior if not required
          if (shouldBailOut(arguments[0]) === true) {
            original.scrollIntoView.call(this, arguments[0] === undefined ? true : arguments[0]);
            return;
          }

          // LET THE SMOOTHNESS BEGIN!
          var scrollableParent = findScrollableParent(this);
          var parentRects = scrollableParent.getBoundingClientRect();
          var clientRects = this.getBoundingClientRect();
          if (scrollableParent !== d.body) {
            // reveal element inside parent
            smoothScroll.call(this, scrollableParent, scrollableParent.scrollLeft + clientRects.left - parentRects.left, scrollableParent.scrollTop + clientRects.top - parentRects.top);

            // reveal parent in viewport unless is fixed
            if (w.getComputedStyle(scrollableParent).position !== "fixed") {
              w.scrollBy({
                left: parentRects.left,
                top: parentRects.top,
                behavior: "smooth"
              });
            }
          } else {
            // reveal element in viewport
            w.scrollBy({
              left: clientRects.left,
              top: clientRects.top,
              behavior: "smooth"
            });
          }
        };
      }
      {
        // commonjs
        module.exports = {
          polyfill: polyfill
        };
      }
    })();
  });
  smoothscroll.polyfill;
  smoothscroll.polyfill();
  /**
   * Creates incremented ID for each newly created step
   *
   * @private
   * @return {Number} The unique id for the step
   */

  var uniqueId = function () {
    var id = 0;
    return function () {
      return ++id;
    };
  }();
  /**
   * A class representing steps to be added to a tour.
   * @extends {Evented}
   */

  var Step = /*#__PURE__*/
  function (_Evented) {
    _inherits(Step, _Evented);

    /**
     * Create a step
     * @param {Tour} tour The tour for the step
     * @param {Object} options The options for the step
     * @param {Object} options.attachTo What element the step should be attached to on the page.
     * It should be an object with the properties `element` and `on`, where `element` is an element selector string
     * or a DOM element and `on` is the optional direction to place the Tippy tooltip.
     *
     * ```js
     * const new Step(tour, {
     *   attachTo: { element: '.some .selector-path', on: 'left' },
     *   ...moreOptions
     * })'
     * ```
     *
     * If you dont specify an attachTo the element will appear in the middle of the screen.
     * If you omit the `on` portion of `attachTo`, the element will still be highlighted, but the tooltip will appear
     * in the middle of the screen, without an arrow pointing to the target.
     * @param {HTMLElement|string} options.attachTo.element
     * @param {string} options.attachTo.on
     * @param {Object} options.advanceOn An action on the page which should advance shepherd to the next step.
     * It should be an object with a string `selector` and an `event` name
     * ```js
     * const new Step(tour, {
     *   advanceOn: { selector: '.some .selector-path', event: 'click' },
     *   ...moreOptions
     * })'
     * ```
     * `event` doesnt have to be an event inside the tour, it can be any event fired on any element on the page.
     * You can also always manually advance the Tour by calling `myTour.next()`.
     * @param {function} options.beforeShowPromise A function that returns a promise.
     * When the promise resolves, the rest of the `show` code for the step will execute.
     * @param {Object[]} options.buttons An array of buttons to add to the step. These will be rendered in a
     * footer below the main body text.
     * @param {function} options.buttons.button.action A function executed when the button is clicked on
     * @param {string} options.buttons.button.classes Extra classes to apply to the `<a>`
     * @param {Object} options.buttons.button.events A hash of events to bind onto the button, for example
     * `{'mouseover': function(){}}`. Adding a `click` event to events when you already have an `action` specified is not supported.
     * You can use events to skip steps or navigate to specific steps, with something like:
     * ```js
     * events: {
     *   click: function() {
     *     return Shepherd.activeTour.show('some_step_name');
     *   }
     * }
     * ```
     * @param {string} options.buttons.button.text The HTML text of the button
     * @param {string} options.classes A string of extra classes to add to the step's content element.
     * @param {string} options.highlightClass An extra class to apply to the `attachTo` element when it is
     * highlighted (that is, when its step is active). You can then target that selector in your CSS.
     * @param {Object} options.tippyOptions Extra [options to pass to tippy.js]{@link https://atomiks.github.io/tippyjs/#all-options}
     * @param {boolean|Object} options.scrollTo Should the element be scrolled to when this step is shown? If true, uses the default `scrollIntoView`,
     * if an object, passes that object as the params to `scrollIntoView` i.e. `{behavior: 'smooth', block: 'center'}`
     * @param {function} options.scrollToHandler A function that lets you override the default scrollTo behavior and
     * define a custom action to do the scrolling, and possibly other logic.
     * @param {boolean} options.showCancelLink Should a cancel  be shown in the header of the step?
     * @param {function} options.showOn A function that, when it returns `true`, will show the step.
     * If it returns false, the step will be skipped.
     * @param {string} options.text The text in the body of the step. It can be one of four types:
     * ```
     * - HTML string
     * - Array of HTML strings
     * - `HTMLElement` object
     * - `Function` to be executed when the step is built. It must return one of the three options above.
     * ```
     * @param {string} options.title The step's title. It becomes an `h3` at the top of the step.
     * @param {Object} options.when You can define `show`, `hide`, etc events inside `when`. For example:
     * ```js
     * when: {
     *   show: function() {
     *     window.scrollTo(0, 0);
     *   }
     * }
     * ```
     * @param {Number} options.modalOverlayOpeningPadding An amount of padding to add around the modal overlay opening
     * @return {Step} The newly created Step instance
     */
    function Step(tour, options) {
      var _this;
      _classCallCheck(this, Step);
      _this = _possibleConstructorReturn(this, _getPrototypeOf(Step).call(this, tour, options));
      _this.tour = tour;
      bindMethods.call(_assertThisInitialized(_this), ["_show", "cancel", "complete", "destroy", "hide", "isOpen", "scrollTo", "setupElements", "show"]);
      _this.setOptions(options);
      _this.bindAdvance = bindAdvance.bind(_assertThisInitialized(_this));
      _this.bindButtonEvents = bindButtonEvents.bind(_assertThisInitialized(_this));
      _this.bindCancelLink = bindCancelLink.bind(_assertThisInitialized(_this));
      _this.setupTooltip = setupTooltip.bind(_assertThisInitialized(_this));
      _this.parseAttachTo = parseAttachTo.bind(_assertThisInitialized(_this));
      return _possibleConstructorReturn(_this, _assertThisInitialized(_this));
    }
    /**
     * Adds buttons to the step as passed into options
     *
     * @private
     * @param {HTMLElement} content The element for the step, to append the footer with buttons to
     */

    _createClass(Step, [{
      key: "_addButtons",
      value: function _addButtons(content) {
        var _this2 = this;
        if (Array.isArray(this.options.buttons) && this.options.buttons.length) {
          var footer = document.createElement("footer");
          footer.classList.add("shepherd-footer");
          this.options.buttons.map(function (cfg) {
            var button = createFromHTML('<button class="shepherd-button '.concat(cfg.classes || "", '" tabindex="0">').concat(cfg.text, "</button>"));
            footer.appendChild(button);
            _this2.bindButtonEvents(cfg, button);
          });
          content.appendChild(footer);
        }
      }
      /**
       * Adds the "x" button to cancel the tour
       * @param {HTMLElement} element The step element
       * @param {HTMLElement} header The header element for the step
       * @private
       */
    }, {
      key: "_addCancelLink",
      value: function _addCancelLink(element, header) {
        if (this.options.showCancelLink) {
          var link = createFromHTML('<a href class="shepherd-cancel-link"></a>');
          header.appendChild(link);
          element.classList.add("shepherd-has-cancel-link");
          this.bindCancelLink(link);
        }
      }
      /**
       * Adds text passed in as options
       *
       * @private
       * @param {HTMLElement} content The content to append the text to
       * @param {string} descriptionId The id to set on the shepherd-text element
       * for the parent element to use for aria-describedby
       */
    }, {
      key: "_addContent",
      value: function _addContent(content, descriptionId) {
        var text = createFromHTML('<div class="shepherd-text"\n       id="'.concat(descriptionId, '"\n       ></div>'));
        var paragraphs = this.options.text;
        if (isFunction(paragraphs)) {
          paragraphs = paragraphs.call(this, text);
        }
        if (paragraphs instanceof HTMLElement) {
          text.appendChild(paragraphs);
        } else {
          if (isString(paragraphs)) {
            paragraphs = [paragraphs];
          }
          paragraphs.map(function (paragraph) {
            text.innerHTML += "<p>".concat(paragraph, "</p>");
          });
        }
        content.appendChild(text);
      }
      /**
       * Setup keydown events to allow closing the modal with ESC
       *
       * Borrowed from this great post! https://bitsofco.de/accessible-modal-dialog/
       *
       * @param {HTMLElement} element The element for the tooltip
       * @private
       */
    }, {
      key: "_addKeyDownHandler",
      value: function _addKeyDownHandler(element) {
        var _this3 = this;
        var KEY_TAB = 9;
        var KEY_ESC = 27;
        var LEFT_ARROW = 37;
        var RIGHT_ARROW = 39; // Get all elements that are focusable

        var focusableElements = element.querySelectorAll('a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), button:not([disabled]), [tabindex="0"]');
        var _focusableElements = _slicedToArray(focusableElements, 1),
          firstFocusableElement = _focusableElements[0];
        var lastFocusableElement = focusableElements[focusableElements.length - 1];
        element.addEventListener("keydown", function (e) {
          switch (e.keyCode) {
            case KEY_TAB:
              if (focusableElements.length === 1) {
                e.preventDefault();
                break;
              } // Backward tab

              if (e.shiftKey) {
                if (document.activeElement === firstFocusableElement) {
                  e.preventDefault();
                  lastFocusableElement.focus();
                }
              } else {
                if (document.activeElement === lastFocusableElement) {
                  e.preventDefault();
                  firstFocusableElement.focus();
                }
              }
              break;
            case KEY_ESC:
              _this3.cancel();
              break;
            case LEFT_ARROW:
              _this3.tour.back();
              break;
            case RIGHT_ARROW:
              _this3.tour.next();
              break;
          }
        });
      }
      /**
       * Creates Shepherd element for step based on options
       *
       * @private
       * @return {HTMLElement} The DOM element for the step tooltip
       */
    }, {
      key: "_createTooltipContent",
      value: function _createTooltipContent() {
        var content = document.createElement("div");
        var classes = this.options.classes || "";
        var descriptionId = "".concat(this.id, "-description");
        var labelId = "".concat(this.id, "-label");
        var element = createFromHTML('<div class="'.concat(classes, '"\n       data-shepherd-step-id="').concat(this.id, '"\n       role="dialog"\n       tabindex="0">'));
        var header = document.createElement("header");
        if (this.options.title) {
          var title = document.createElement("h3");
          title.classList.add("shepherd-title");
          title.innerHTML = "".concat(this.options.title);
          title.id = labelId;
          element.setAttribute("aria-labeledby", labelId);
          header.appendChild(title);
        }
        content.classList.add("shepherd-content");
        header.classList.add("shepherd-header");
        element.appendChild(content);
        content.appendChild(header);
        if (!isUndefined(this.options.text)) {
          this._addContent(content, descriptionId);
          element.setAttribute("aria-describedby", descriptionId);
        }
        this._addButtons(content);
        this._addCancelLink(element, header);
        return element;
      }
      /**
       * Returns the tour for the step
       * @return {Tour} The tour instance
       */
    }, {
      key: "getTour",
      value: function getTour() {
        return this.tour;
      }
      /**
       * Cancel the tour
       * Triggers the `cancel` event
       */
    }, {
      key: "cancel",
      value: function cancel() {
        this.tour.cancel();
        this.trigger("cancel");
      }
      /**
       * Complete the tour
       * Triggers the `complete` event
       */
    }, {
      key: "complete",
      value: function complete() {
        this.tour.complete();
        this.trigger("complete");
      }
      /**
       * Remove the step, delete the step's element, and destroy the tippy instance for the step
       * Triggers `destroy` event
       */
    }, {
      key: "destroy",
      value: function destroy() {
        try {
          if (this.tooltip) {
            this.tooltip.destroy();
            this.tooltip = null;
          }
          if (isElement$2(this.el) && this.el.parentNode) {
            this.el.parentNode.removeChild(this.el);
            this.el = null;
          }
          if (this.target) {
            this._updateStepTargetOnHide();
          }
          this.trigger("destroy");
        } catch (e) {}
      }
      /**
       * Hide the step and destroy the tippy instance
       */
    }, {
      key: "hide",
      value: function hide() {
        this.tour.modal.hide();
        this.trigger("before-hide");
        document.body.removeAttribute("data-shepherd-step");
        if (this.target) {
          this._updateStepTargetOnHide();
        }
        if (this.tooltip) {
          this.tooltip.hide();
        }
        this.trigger("hide");
      }
      /**
       * Check if the step is open and visible
       * @return {boolean} True if the step is open and visible
       */
    }, {
      key: "isOpen",
      value: function isOpen() {
        return Boolean(this.tooltip && this.tooltip.state && this.tooltip.state.isVisible);
      }
      /**
       * Create the element and set up the tippy instance
       */
    }, {
      key: "setupElements",
      value: function setupElements() {
        if (!isUndefined(this.el)) {
          this.destroy();
        }
        this.el = this._createTooltipContent();
        this._addKeyDownHandler(this.el);
        if (this.options.advanceOn) {
          this.bindAdvance();
        }
        this.setupTooltip();
      }
      /**
       * If a custom scrollToHandler is defined, call that, otherwise do the generic
       * scrollIntoView call.
       *
       * @param {boolean|Object} scrollToOptions If true, uses the default `scrollIntoView`,
       * if an object, passes that object as the params to `scrollIntoView` i.e. `{ behavior: 'smooth', block: 'center' }`
       */
    }, {
      key: "scrollTo",
      value: function scrollTo(scrollToOptions) {
        var _this$parseAttachTo = this.parseAttachTo(),
          element = _this$parseAttachTo.element;
        if (isFunction(this.options.scrollToHandler)) {
          this.options.scrollToHandler(element);
        } else if (isElement$2(element)) {
          element.scrollIntoView(scrollToOptions);
        }
      }
      /**
       * Sets the options for the step, maps `when` to events, sets up buttons
       * @param {Object} options The options for the step
       */
    }, {
      key: "setOptions",
      value: function setOptions() {
        var _this4 = this;
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        this.options = options;
        var when = this.options.when;
        this.destroy();
        this.id = this.options.id || "step-".concat(uniqueId());
        if (when) {
          Object.entries(when).forEach(function (_ref) {
            var _ref2 = _slicedToArray(_ref, 2),
              event = _ref2[0],
              handler = _ref2[1];
            _this4.on(event, handler, _this4);
          });
        }
      }
      /**
       * Wraps `_show` and ensures `beforeShowPromise` resolves before calling show
       * @return {*|Promise}
       */
    }, {
      key: "show",
      value: function show() {
        var _this5 = this;
        if (isFunction(this.options.beforeShowPromise)) {
          var beforeShowPromise = this.options.beforeShowPromise();
          if (!isUndefined(beforeShowPromise)) {
            return beforeShowPromise.then(function () {
              return _this5._show();
            });
          }
        }
        this._show();
      }
      /**
       * Triggers `before-show`, generates the tooltip DOM content,
       * sets up a tippy instance for the tooltip, then triggers `show`.
       * @private
       */
    }, {
      key: "_show",
      value: function _show() {
        var _this6 = this;
        this.tour.beforeShowStep(this);
        this.trigger("before-show");
        if (!this.el) {
          this.setupElements();
        }
        this.target.classList.add("shepherd-enabled", "shepherd-target");
        document.body.setAttribute("data-shepherd-step", this.id);
        if (this.options.scrollTo) {
          setTimeout(function () {
            _this6.scrollTo(_this6.options.scrollTo);
          });
        }
        this.tooltip.show();
        this.trigger("show");
        this.el.focus();
      }
      /**
       * When a step is hidden, remove the highlightClass and 'shepherd-enabled'
       * and 'shepherd-target' classes
       * @private
       */
    }, {
      key: "_updateStepTargetOnHide",
      value: function _updateStepTargetOnHide() {
        if (this.options.highlightClass) {
          this.target.classList.remove(this.options.highlightClass);
        }
        this.target.classList.remove("shepherd-enabled", "shepherd-target");
      }
    }]);
    return Step;
  }(Evented);
  var svgNS$1 = "http://www.w3.org/2000/svg";
  var elementIds$1 = {
    modalOverlay: "shepherdModalOverlayContainer",
    modalOverlayMask: "shepherdModalMask",
    modalOverlayMaskRect: "shepherdModalMaskRect",
    modalOverlayMaskOpening: "shepherdModalMaskOpening"
  };
  var classNames = {
    isVisible: "shepherd-modal-is-visible",
    modalTarget: "shepherd-modal-target"
  };
  /**
   * <svg id="shepherdModalOverlayContainer" xmlns="http://www.w3.org/2000/svg">
   */

  function _createModalContainer$1() {
    var element = document.createElementNS(svgNS$1, "svg");
    element.setAttributeNS(null, "id", elementIds$1.modalOverlay);
    return element;
  }
  /**
   * <mask id="shepherdModalMask" x="0" y="0" width="100%" height="100%">
   */

  function _createMaskContainer$1() {
    var element = document.createElementNS(svgNS$1, "mask");
    _setAttributes(element, {
      height: "100%",
      id: elementIds$1.modalOverlayMask,
      width: "100%",
      x: "0",
      y: "0"
    });
    return element;
  }
  /**
   *  <rect id="modalOverlayMaskRect" x="0" y="0" width="100%" height="100%" fill="#FFFFFF"/>
   */

  function _createMaskRect$1() {
    var element = document.createElementNS(svgNS$1, "rect");
    _setAttributes(element, {
      fill: "#FFFFFF",
      height: "100%",
      id: elementIds$1.modalOverlayMaskRect,
      width: "100%",
      x: "0",
      y: "0"
    });
    return element;
  }
  /**
   * <rect id="shepherdModalMaskOpening" fill="#000000"/>
   */

  function _createMaskOpening$1() {
    var element = document.createElementNS(svgNS$1, "rect");
    _setAttributes(element, {
      fill: "#000000",
      id: elementIds$1.modalOverlayMaskOpening
    });
    return element;
  }
  /**
   * <rect x="0" y="0" width="100%" height="100%" mask="url(#shepherdModalMask)"/>
   */

  function _createMaskConsumer$1() {
    var element = document.createElementNS(svgNS$1, "rect");
    _setAttributes(element, {
      height: "100%",
      width: "100%",
      x: "0",
      y: "0"
    });
    element.setAttribute("mask", "url(#".concat(elementIds$1.modalOverlayMask, ")"));
    return element;
  }
  /**
   * Generates an SVG with the following structure:
   * ```html
   *  <svg id="shepherdModalOverlayContainer" xmlns="http://www.w3.org/2000/svg">
   <defs>
   <mask id="shepherdModalMask" x="0" y="0" width="100%" height="100%" >
   <rect x="0" y="0" width="100%" height="100%" fill="#FFFFFF"/>
   <!-- This element will "punch a hole" through the mask by preventing it from rendering within the perimeter -->
   <rect id="shepherdModalMaskOpening"/>
   </mask>
   </defs>
   <rect x="0" y="0" width="100%" height="100%" mask="url(#shepherdModalMask)"/>
   </svg>
   * ```
   */

  function createModalOverlay() {
    var containerElement = _createModalContainer$1();
    var defsElement = document.createElementNS(svgNS$1, "defs");
    var maskContainer = _createMaskContainer$1();
    var maskRect = _createMaskRect$1();
    var maskOpening = _createMaskOpening$1();
    var maskConsumer = _createMaskConsumer$1();
    maskContainer.appendChild(maskRect);
    maskContainer.appendChild(maskOpening);
    defsElement.appendChild(maskContainer);
    containerElement.appendChild(defsElement);
    containerElement.appendChild(maskConsumer);
    return containerElement;
  }
  /**
   * Uses the bounds of the element we want the opening overtop of to set the dimensions of the opening and position it
   * @param {HTMLElement} targetElement The element the opening will expose
   * @param {SVGElement} openingElement The svg mask for the opening
   * @param {Number} modalOverlayOpeningPadding An amount of padding to add around the modal overlay opening
   */

  function positionModalOpening$1(targetElement, openingElement) {
    var modalOverlayOpeningPadding = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    if (targetElement.getBoundingClientRect && openingElement instanceof SVGElement) {
      var _targetElement$getBou = targetElement.getBoundingClientRect(),
        x = _targetElement$getBou.x,
        y = _targetElement$getBou.y,
        width = _targetElement$getBou.width,
        height = _targetElement$getBou.height,
        left = _targetElement$getBou.left,
        top = _targetElement$getBou.top; // getBoundingClientRect is not consistent. Some browsers use x and y, while others use left and top

      _setAttributes(openingElement, {
        x: (x || left) - modalOverlayOpeningPadding,
        y: (y || top) - modalOverlayOpeningPadding,
        width: width + modalOverlayOpeningPadding * 2,
        height: height + modalOverlayOpeningPadding * 2
      });
    }
  }
  function closeModalOpening(openingElement) {
    if (openingElement && openingElement instanceof SVGElement) {
      _setAttributes(openingElement, {
        height: "0",
        x: "0",
        y: "0",
        width: "0"
      });
    }
  }
  function getModalMaskOpening(modalElement) {
    return modalElement.querySelector("#".concat(elementIds$1.modalOverlayMaskOpening));
  }
  function preventModalBodyTouch(event) {
    event.preventDefault();
  }
  function preventModalOverlayTouch(event) {
    event.stopPropagation();
  }
  /**
   * Remove any leftover modal target classes and add the modal target class to the currentElement
   * @param {HTMLElement} currentElement The element for the current step
   */

  function toggleShepherdModalClass(currentElement) {
    var shepherdModal = document.querySelector("".concat(classNames.modalTarget));
    if (shepherdModal) {
      shepherdModal.classList.remove(classNames.modalTarget);
    }
    currentElement.classList.add(classNames.modalTarget);
  }
  /**
   * Set multiple attributes on an element, via a hash
   * @param {HTMLElement|SVGElement} el The element to set the attributes on
   * @param {Object} attrs A hash of key value pairs for attributes to set
   * @private
   */

  function _setAttributes(el, attrs) {
    Object.keys(attrs).forEach(function (key) {
      el.setAttribute(key, attrs[key]);
    });
  }

  /**
   * Get the element from an option object
   *
   * @method getElementFromObject
   * @param Object attachTo
   * @returns {Element}
   * @private
   */

  function getElementFromObject(attachTo) {
    var op = attachTo.element;
    if (op instanceof HTMLElement) {
      return op;
    }
    if (op instanceof SVGElement) {
      return op;
    }
    try {
      return document.querySelector(op);
    } catch (e) {}
    return null;
  }
  /**
   * Return the element for a step
   *
   * @method getElementForStep
   * @param step step the step to get an element for
   * @returns {Element} the element for this step
   * @private
   */

  function getElementForStep(step) {
    var attachTo = step.options.attachTo;
    if (!attachTo) {
      return null;
    }
    var type = _typeof(attachTo);
    var element;
    if (type === "string") {
      element = getElementFromString(attachTo);
    } else if (type === "object") {
      element = getElementFromObject(attachTo);
    } else {
      /* istanbul ignore next: cannot test undefined attachTo, but it does work! */
      element = null;
    }
    return element;
  }
  /**
   * Get the element from an option string
   *
   * @method getElementFromString
   * @param element the string in the step configuration
   * @returns {Element} the element from the string
   * @private
   */

  function getElementFromString(element) {
    var _element$split = element.split(" "),
      _element$split2 = _slicedToArray(_element$split, 1),
      selector = _element$split2[0];
    return document.querySelector(selector);
  }
  function addStepEventListeners() {
    if (typeof this._onScreenChange === "function") {
      window.removeEventListener("resize", this._onScreenChange, false);
      window.removeEventListener("scroll", this._onScreenChange, true);
    }
    window.addEventListener("resize", this._onScreenChange, false);
    window.addEventListener("scroll", this._onScreenChange, true);
    var overlay = document.querySelector("#".concat(elementIds$1.modalOverlay)); // Prevents window from moving on touch.

    window.addEventListener("touchmove", preventModalBodyTouch, {
      passive: false
    }); // Allows content to move on touch.

    if (overlay) {
      overlay.addEventListener("touchmove", preventModalOverlayTouch, false);
    }
  }
  var Modal = /*#__PURE__*/
  function () {
    function Modal(options) {
      _classCallCheck(this, Modal);
      this.createModalOverlay();
      this.options = options;
      return this;
    }
    /**
     * Removes svg mask from modal overlay and removes classes for modal being visible
     */

    _createClass(Modal, [{
      key: "cleanup",
      value: function cleanup() {
        try {
          var element = this._modalOverlayElem;
          if (element && element instanceof SVGElement) {
            element.parentNode.removeChild(element);
          }
          this._modalOverlayElem = null;
          document.body.classList.remove(classNames.isVisible);
        } catch (e) {}
      }
      /**
       * Create the modal overlay, if it does not already exist
       */
    }, {
      key: "createModalOverlay",
      value: function createModalOverlay$1() {
        if (!this._modalOverlayElem) {
          var existingModal = document.getElementById("shepherdModalOverlayContainer");
          this._modalOverlayElem = existingModal || createModalOverlay();
          this._modalOverlayOpening = getModalMaskOpening(this._modalOverlayElem); // don't show yet -- each step will control that

          this.hide(); // Only add to the DOM if this is a new modal, not reusing another one

          if (!existingModal) {
            document.body.appendChild(this._modalOverlayElem);
          }
        }
      }
      /**
       * Hide the modal overlay
       */
    }, {
      key: "hide",
      value: function hide() {
        document.body.classList.remove(classNames.isVisible);
        if (this._modalOverlayElem) {
          this._modalOverlayElem.style.display = "none";
        }
      }
      /**
       * If modal is enabled, setup the svg mask opening and modal overlay for the step
       * @param step
       */
    }, {
      key: "setupForStep",
      value: function setupForStep(step) {
        if (this.options.useModalOverlay) {
          this._styleForStep(step);
          this.show();
        } else {
          this.hide();
        }
      }
      /**
       * Show the modal overlay
       */
    }, {
      key: "show",
      value: function show() {
        document.body.classList.add(classNames.isVisible);
        if (this._modalOverlayElem) {
          this._modalOverlayElem.style.display = "block";
        }
      }
      /**
       * Style the modal for the step
       * @param {Step} step The step to style the opening for
       * @private
       */
    }, {
      key: "_styleForStep",
      value: function _styleForStep(step) {
        var modalOverlayOpening = this._modalOverlayOpening;
        var targetElement = getElementForStep(step);
        var modalOverlayOpeningPadding = step.options.modalOverlayOpeningPadding;
        if (targetElement) {
          positionModalOpening$1(targetElement, modalOverlayOpening, modalOverlayOpeningPadding);
          this._onScreenChange = debounce$2$1(positionModalOpening$1.bind(this, targetElement, modalOverlayOpening, modalOverlayOpeningPadding), 0);
          addStepEventListeners.call(this);
        } else {
          closeModalOpening(this._modalOverlayOpening);
        }
      }
    }]);
    return Modal;
  }();

  // Older browsers don't support event options, feature detect it.

  // Adopted and modified solution from Bohdan Didukh (2017)
  // https://stackoverflow.com/questions/41594997/ios-10-safari-prevent-scrolling-behind-a-fixed-overlay-and-maintain-scroll-posi

  var hasPassiveEvents = false;
  if (typeof window !== "undefined") {
    var passiveTestOptions = {
      get passive() {
        hasPassiveEvents = true;
        return undefined;
      }
    };
    window.addEventListener("testPassive", null, passiveTestOptions);
    window.removeEventListener("testPassive", null, passiveTestOptions);
  }
  var isIosDevice = typeof window !== "undefined" && window.navigator && window.navigator.platform && /iP(ad|hone|od)/.test(window.navigator.platform);
  var locks = [];
  var documentListenerAdded = false;
  var initialClientY = -1;
  var previousBodyOverflowSetting;
  var previousBodyPaddingRight;

  // returns true if `el` should be allowed to receive touchmove events
  var allowTouchMove = function allowTouchMove(el) {
    return locks.some(function (lock) {
      if (lock.options.allowTouchMove && lock.options.allowTouchMove(el)) {
        return true;
      }
      return false;
    });
  };
  var preventDefault = function preventDefault(rawEvent) {
    var e = rawEvent || window.event;

    // For the case whereby consumers adds a touchmove event listener to document.
    // Recall that we do document.addEventListener('touchmove', preventDefault, { passive: false })
    // in disableBodyScroll - so if we provide this opportunity to allowTouchMove, then
    // the touchmove event on document will break.
    if (allowTouchMove(e.target)) {
      return true;
    }

    // Do not prevent if the event has more than one touch (usually meaning this is a multi touch gesture like pinch to zoom)
    if (e.touches.length > 1) return true;
    if (e.preventDefault) e.preventDefault();
    return false;
  };
  var setOverflowHidden = function setOverflowHidden(options) {
    // Setting overflow on body/documentElement synchronously in Desktop Safari slows down
    // the responsiveness for some reason. Setting within a setTimeout fixes this.
    setTimeout(function () {
      // If previousBodyPaddingRight is already set, don't set it again.
      if (previousBodyPaddingRight === undefined) {
        var reserveScrollBarGap = !!options && options.reserveScrollBarGap === true;
        var scrollBarGap = window.innerWidth - document.documentElement.clientWidth;
        if (reserveScrollBarGap && scrollBarGap > 0) {
          previousBodyPaddingRight = document.body.style.paddingRight;
          document.body.style.paddingRight = "".concat(scrollBarGap, "px");
        }
      }

      // If previousBodyOverflowSetting is already set, don't set it again.
      if (previousBodyOverflowSetting === undefined) {
        previousBodyOverflowSetting = document.body.style.overflow;
        document.body.style.overflow = "hidden";
      }
    });
  };
  var restoreOverflowSetting = function restoreOverflowSetting() {
    // Setting overflow on body/documentElement synchronously in Desktop Safari slows down
    // the responsiveness for some reason. Setting within a setTimeout fixes this.
    setTimeout(function () {
      if (previousBodyPaddingRight !== undefined) {
        document.body.style.paddingRight = previousBodyPaddingRight;

        // Restore previousBodyPaddingRight to undefined so setOverflowHidden knows it
        // can be set again.
        previousBodyPaddingRight = undefined;
      }
      if (previousBodyOverflowSetting !== undefined) {
        document.body.style.overflow = previousBodyOverflowSetting;

        // Restore previousBodyOverflowSetting to undefined
        // so setOverflowHidden knows it can be set again.
        previousBodyOverflowSetting = undefined;
      }
    });
  };

  // https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollHeight#Problems_and_solutions
  var isTargetElementTotallyScrolled = function isTargetElementTotallyScrolled(targetElement) {
    return targetElement ? targetElement.scrollHeight - targetElement.scrollTop <= targetElement.clientHeight : false;
  };
  var handleScroll = function handleScroll(event, targetElement) {
    var clientY = event.targetTouches[0].clientY - initialClientY;
    if (allowTouchMove(event.target)) {
      return false;
    }
    if (targetElement && targetElement.scrollTop === 0 && clientY > 0) {
      // element is at the top of its scroll
      return preventDefault(event);
    }
    if (isTargetElementTotallyScrolled(targetElement) && clientY < 0) {
      // element is at the top of its scroll
      return preventDefault(event);
    }
    event.stopPropagation();
    return true;
  };
  var disableBodyScroll = function disableBodyScroll(targetElement, options) {
    if (isIosDevice) {
      // targetElement must be provided, and disableBodyScroll must not have been
      // called on this targetElement before.
      if (!targetElement) {
        // eslint-disable-next-line no-console
        console.error("disableBodyScroll unsuccessful - targetElement must be provided when calling disableBodyScroll on IOS devices.");
        return;
      }
      if (targetElement && !locks.some(function (lock) {
        return lock.targetElement === targetElement;
      })) {
        var lock = {
          targetElement: targetElement,
          options: options || {}
        };
        locks = [].concat(_toConsumableArray(locks), [lock]);
        targetElement.ontouchstart = function (event) {
          if (event.targetTouches.length === 1) {
            // detect single touch
            initialClientY = event.targetTouches[0].clientY;
          }
        };
        targetElement.ontouchmove = function (event) {
          if (event.targetTouches.length === 1) {
            // detect single touch
            handleScroll(event, targetElement);
          }
        };
        if (!documentListenerAdded) {
          document.addEventListener("touchmove", preventDefault, hasPassiveEvents ? {
            passive: false
          } : undefined);
          documentListenerAdded = true;
        }
      }
    } else {
      setOverflowHidden(options);
      var _lock = {
        targetElement: targetElement,
        options: options || {}
      };
      locks = [].concat(_toConsumableArray(locks), [_lock]);
    }
  };
  var clearAllBodyScrollLocks = function clearAllBodyScrollLocks() {
    if (isIosDevice) {
      // Clear all locks ontouchstart/ontouchmove handlers, and the references
      locks.forEach(function (lock) {
        lock.targetElement.ontouchstart = null;
        lock.targetElement.ontouchmove = null;
      });
      if (documentListenerAdded) {
        document.removeEventListener("touchmove", preventDefault, hasPassiveEvents ? {
          passive: false
        } : undefined);
        documentListenerAdded = false;
      }
      locks = [];

      // Reset initial clientY
      initialClientY = -1;
    } else {
      restoreOverflowSetting();
      locks = [];
    }
  };
  var defaults = {
    trigger: "manual",
    arrow: true,
    animation: "fade",
    duration: 420,
    flip: true,
    animateFill: false,
    // https://atomiks.github.io/tippyjs/#animate-fill-option
    interactive: true,
    // https://atomiks.github.io/tippyjs/#interactive-option
    hideOnClick: "toggle",
    // https://atomiks.github.io/tippyjs/#hide-on-click-option
    multiple: true // https://atomiks.github.io/tippyjs/#multiple-option
  };

  /**
   * Cleanup the steps and set pointerEvents back to 'auto'
   * @param tour The tour object
   */

  function cleanupSteps(tour) {
    if (tour) {
      var steps = tour.steps;
      steps.forEach(function (step) {
        if (step.options && step.options.canClickTarget === false && step.options.attachTo) {
          var stepElement = getElementForStep(step);
          if (stepElement instanceof HTMLElement) {
            stepElement.style.pointerEvents = "auto";
          }
        }
      });
    }
  }
  /**
   * Remove resize and scroll event listeners
   */

  function cleanupStepEventListeners() {
    if (typeof this._onScreenChange === "function") {
      window.removeEventListener("resize", this._onScreenChange, false);
      window.removeEventListener("scroll", this._onScreenChange, false);
      this._onScreenChange = null;
    }
    window.removeEventListener("touchmove", preventModalBodyTouch, {
      passive: false
    });
  }

  /**
   * Creates incremented ID for each newly created tour
   *
   * @private
   * @return {Number} The unique id for the tour
   */

  var uniqueId$1 = function () {
    var id = 0;
    return function () {
      return ++id;
    };
  }();
  var Shepherd = new Evented();
  /**
   * Class representing the site tour
   * @extends {Evented}
   */

  var Tour = /*#__PURE__*/
  function (_Evented) {
    _inherits(Tour, _Evented);

    /**
     * @param {Object} options The options for the tour
     * @param {Object} options.defaultStepOptions Default options for Steps ({@link Step#constructor}), created through `addStep`
     * @param {boolean} options.disableScroll When set to true, will keep the user from scrolling with the scrollbar,
     * mousewheel, arrow keys, etc. You may want to use this to ensure you are driving the scroll position with the tour.
     * @param {Step[]} options.steps An array of Step instances to initialize the tour with
     * @param {string} options.tourName An optional "name" for the tour. This will be appended to the the tour's
     * dynamically generated `id` property -- which is also set on the `body` element as the `data-shepherd-active-tour` attribute
     * whenever the tour becomes active.
     * @param {boolean} options.useModalOverlay Whether or not steps should be placed above a darkened
     * modal overlay. If true, the overlay will create an opening around the target element so that it
     * can remain interactive
     * @returns {Tour}
     */
    function Tour() {
      var _this;
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, Tour);
      _this = _possibleConstructorReturn(this, _getPrototypeOf(Tour).call(this, options));
      bindMethods.call(_assertThisInitialized(_this), ["back", "cancel", "complete", "hide", "next"]);
      _this.options = options;
      _this.steps = _this.options.steps || []; // Pass these events onto the global Shepherd object

      var events = ["active", "cancel", "complete", "inactive", "show", "start"];
      events.map(function (event) {
        (function (e) {
          _this.on(e, function (opts) {
            opts = opts || {};
            opts.tour = _assertThisInitialized(_this);
            Shepherd.trigger(e, opts);
          });
        })(event);
      });
      _this.modal = new Modal(options);
      _this._setTooltipDefaults();
      _this._setTourID();
      return _possibleConstructorReturn(_this, _assertThisInitialized(_this));
    }
    /**
     * Adds a new step to the tour
     * @param {Object|Number|Step|String} arg1
     * When arg2 is defined, arg1 can either be a string or number, to use for the `id` for the step
     * When arg2 is undefined, arg1 is either an object containing step options or a Step instance
     * @param {Object|Step} arg2 An object containing step options or a Step instance
     * @return {Step} The newly added step
     */

    _createClass(Tour, [{
      key: "addStep",
      value: function addStep(arg1, arg2) {
        var name, step; // If we just have one argument, we can assume it is an object of step options, with an id

        if (isUndefined(arg2)) {
          step = arg1;
        } else {
          name = arg1;
          step = arg2;
        }
        if (!(step instanceof Step)) {
          step = this.setupStep(step, name);
        } else {
          step.tour = this;
        }
        this.steps.push(step);
        return step;
      }
      /**
       * Go to the previous step in the tour
       */
    }, {
      key: "back",
      value: function back() {
        var index = this.steps.indexOf(this.currentStep);
        this.show(index - 1, false);
      }
      /**
       * Calls done() triggering the 'cancel' event
       * If `confirmCancel` is true, will show a window.confirm before cancelling
       */
    }, {
      key: "cancel",
      value: function cancel() {
        if (this.options.confirmCancel) {
          var cancelMessage = this.options.confirmCancelMessage || "Are you sure you want to stop the tour?";
          var stopTour = window.confirm(cancelMessage);
          if (stopTour) {
            this.done("cancel");
          }
        } else {
          this.done("cancel");
        }
      }
      /**
       * Calls done() triggering the `complete` event
       */
    }, {
      key: "complete",
      value: function complete() {
        this.done("complete");
      }
      /**
       * Called whenever the tour is cancelled or completed, basically anytime we exit the tour
       * @param {String} event The event name to trigger
       */
    }, {
      key: "done",
      value: function done(event) {
        if (Array.isArray(this.steps)) {
          this.steps.forEach(function (step) {
            return step.destroy();
          });
        }
        cleanupStepEventListeners.call(this);
        cleanupSteps(this.tourObject);
        this.trigger(event);
        Shepherd.activeTour = null;
        this._removeBodyAttrs();
        this.trigger("inactive", {
          tour: this
        });
        if (this.options.disableScroll) {
          clearAllBodyScrollLocks();
        }
        this.modal.cleanup();
      }
      /**
       * Gets the step from a given id
       * @param {Number|String} id The id of the step to retrieve
       * @return {Step} The step corresponding to the `id`
       */
    }, {
      key: "getById",
      value: function getById(id) {
        return this.steps.find(function (step) {
          return step.id === id;
        });
      }
      /**
       * Gets the current step
       * @returns {Step|null}
       */
    }, {
      key: "getCurrentStep",
      value: function getCurrentStep() {
        return this.currentStep;
      }
      /**
       * Hide the current step
       */
    }, {
      key: "hide",
      value: function hide() {
        var currentStep = this.getCurrentStep();
        if (currentStep) {
          return currentStep.hide();
        }
      }
      /**
       * Check if the tour is active
       * @return {boolean}
       */
    }, {
      key: "isActive",
      value: function isActive() {
        return Shepherd.activeTour === this;
      }
      /**
       * Go to the next step in the tour
       * If we are at the end, call `complete`
       */
    }, {
      key: "next",
      value: function next() {
        var index = this.steps.indexOf(this.currentStep);
        if (index === this.steps.length - 1) {
          this.complete();
        } else {
          this.show(index + 1, true);
        }
      }
      /**
       * Removes the step from the tour
       * @param {String} name The id for the step to remove
       */
    }, {
      key: "removeStep",
      value: function removeStep(name) {
        var _this2 = this;
        var current = this.getCurrentStep(); // Find the step, destroy it and remove it from this.steps

        this.steps.some(function (step, i) {
          if (step.id === name) {
            if (step.isOpen()) {
              step.hide();
            }
            step.destroy();
            _this2.steps.splice(i, 1);
            return true;
          }
        });
        if (current && current.id === name) {
          this.currentStep = undefined; // If we have steps left, show the first one, otherwise just cancel the tour

          this.steps.length ? this.show(0) : this.cancel();
        }
      }
      /**
       * Setup a new step object
       * @param {Object} stepOptions The object describing the options for the step
       * @param {String|Number} name The string or number to use as the `id` for the step
       * @return {Step} The step instance
       */
    }, {
      key: "setupStep",
      value: function setupStep(stepOptions, name) {
        if (isString(name) || isNumber(name)) {
          stepOptions.id = name.toString();
        }
        stepOptions = _extends({}, this.options.defaultStepOptions, stepOptions);
        return new Step(this, stepOptions);
      }
    }, {
      key: "beforeShowStep",
      value: function beforeShowStep(step) {
        this.modal.setupForStep(step);
        this._styleTargetElementForStep(step);
      }
      /**
       * Show a specific step in the tour
       * @param {Number|String} key The key to look up the step by
       * @param {Boolean} forward True if we are going forward, false if backward
       */
    }, {
      key: "show",
      value: function show() {
        var key = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        var forward = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
        var step = isString(key) ? this.getById(key) : this.steps[key];
        if (step) {
          this._updateStateBeforeShow();
          var shouldSkipStep = isFunction(step.options.showOn) && !step.options.showOn(); // If `showOn` returns false, we want to skip the step, otherwise, show the step like normal

          if (shouldSkipStep) {
            this._skipStep(step, forward);
          } else {
            this.trigger("show", {
              step: step,
              previous: this.currentStep
            });
            this.currentStep = step;
            step.show();
          }
        }
      }
      /**
       * Start the tour
       */
    }, {
      key: "start",
      value: function start() {
        this.trigger("start");
        if (this.options.disableScroll) {
          disableBodyScroll();
        }
        this.currentStep = null;
        this._setupActiveTour();
        this.next();
      }
      /**
       * Make this tour "active"
       * @private
       */
    }, {
      key: "_setupActiveTour",
      value: function _setupActiveTour() {
        this.modal.createModalOverlay();
        this._addBodyAttrs();
        this.trigger("active", {
          tour: this
        });
        Shepherd.activeTour = this;
      }
      /**
       * Modulates the styles of the passed step's target element, based on the step's options and
       * the tour's `modal` option, to visually emphasize the element
       *
       * @param step The step object that attaches to the element
       * @private
       */
    }, {
      key: "_styleTargetElementForStep",
      value: function _styleTargetElementForStep(step) {
        var targetElement = getElementForStep(step);
        if (!targetElement) {
          return;
        }
        toggleShepherdModalClass(targetElement);
        if (step.options.highlightClass) {
          targetElement.classList.add(step.options.highlightClass);
        }
        if (step.options.canClickTarget === false) {
          targetElement.style.pointerEvents = "none";
        }
      }
      /**
       * Called when `showOn` evaluates to false, to skip the step
       * @param {Step} step The step to skip
       * @param {Boolean} forward True if we are going forward, false if backward
       * @private
       */
    }, {
      key: "_skipStep",
      value: function _skipStep(step, forward) {
        var index = this.steps.indexOf(step);
        var nextIndex = forward ? index + 1 : index - 1;
        this.show(nextIndex, forward);
      }
      /**
       * Set the tippy defaults
       * @private
       */
    }, {
      key: "_setTooltipDefaults",
      value: function _setTooltipDefaults() {
        tippy$1.setDefaultProps(defaults);
      }
      /**
       * Before showing, hide the current step and if the tour is not
       * already active, call `this._setupActiveTour`.
       * @private
       */
    }, {
      key: "_updateStateBeforeShow",
      value: function _updateStateBeforeShow() {
        if (this.currentStep) {
          this.currentStep.hide();
        }
        if (!this.isActive()) {
          this._setupActiveTour();
        }
      }
      /**
       * Sets this.id to `${tourName}--${uuid}`
       * @private
       */
    }, {
      key: "_setTourID",
      value: function _setTourID() {
        var tourName = this.options.tourName || "tour";
        var uuid = uniqueId$1();
        this.id = "".concat(tourName, "--").concat(uuid);
      }
      /**
       * Adds the data-shepherd-active-tour attribute and the 'shepherd-active'
       * class to the body.
       * @private
       */
    }, {
      key: "_addBodyAttrs",
      value: function _addBodyAttrs() {
        document.body.setAttribute("data-shepherd-active-tour", this.id);
        document.body.classList.add("shepherd-active");
      }
      /**
       * Removes the data-shepherd-active-tour attribute and the 'shepherd-active'
       * class from the body.
       * @private
       */
    }, {
      key: "_removeBodyAttrs",
      value: function _removeBodyAttrs() {
        document.body.removeAttribute("data-shepherd-active-tour");
        document.body.classList.remove("shepherd-active");
      }
    }]);
    return Tour;
  }(Evented);
  _extends(Shepherd, {
    Tour: Tour,
    Step: Step,
    Evented: Evented
  });

  var ApxorWalkthroughTour;
  var onClickCallback = function onClickCallback(rtmInstance, configId, configName) {
    var isHitTheTarget = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    var dismiss_target_touch = arguments.length > 4 ? arguments[4] : undefined;
    if (dismiss_target_touch) {
      try {
        if (isHitTheTarget) {
          rtmInstance.logActionEvent("InlineTargetViewClicked", configId, configName);
        }
        ApxorWalkthroughTour.complete();
        // console.log('InlineTargetViewClicked');
      } catch (e) {
        rtmInstance.isShowingAction = false;
        rtmInstance.currentAction = null;
      }
    }
  };
  var flutterClickCallbackWrapper = null;
  var getPropertyFrom = function getPropertyFrom(position) {
    var pos = position.toUpperCase();
    switch (pos) {
      case "TOP":
        return "top: -8px !important";
      case "LEFT":
        return "left: 0px !important";
      case "RIGHT":
        return "left: -0px !important";
      case "BOTTOM":
        return "top: 0px !important";
    }
  };
  var addTourStep = function addTourStep(uiConfig, messageConfig, rtmInstance, on_tooltip_shown, on_tooltip_hidden) {
    var _text_config$segments;
    var _uiConfig$animation = uiConfig.animation,
      animation = _uiConfig$animation === void 0 ? {} : _uiConfig$animation,
      _uiConfig$bg_color = uiConfig.bg_color,
      bg_color = _uiConfig$bg_color === void 0 ? "black" : _uiConfig$bg_color,
      _uiConfig$border = uiConfig.border,
      border = _uiConfig$border === void 0 ? {} : _uiConfig$border,
      _uiConfig$buttons_con = uiConfig.buttons_config,
      buttons_config = _uiConfig$buttons_con === void 0 ? [] : _uiConfig$buttons_con,
      _uiConfig$button_posi = uiConfig.button_position,
      button_position = _uiConfig$button_posi === void 0 ? "right" : _uiConfig$button_posi,
      _uiConfig$button_dire = uiConfig.button_direction,
      button_direction = _uiConfig$button_dire === void 0 ? DIRECTION.HORIZONTAL : _uiConfig$button_dire,
      _uiConfig$corners = uiConfig.corners,
      corners = _uiConfig$corners === void 0 ? {} : _uiConfig$corners,
      _uiConfig$shadow = uiConfig.shadow,
      shadow = _uiConfig$shadow === void 0 ? "0 8px 16px rgba(0,0,0,0.19), 0 6px 6px rgba(0,0,0,0.23)" : _uiConfig$shadow,
      _uiConfig$opacity = uiConfig.opacity,
      opacity = _uiConfig$opacity === void 0 ? 1 : _uiConfig$opacity,
      _uiConfig$dismiss_out = uiConfig.dismiss_outside_touch,
      dismiss_outside_touch = _uiConfig$dismiss_out === void 0 ? false : _uiConfig$dismiss_out,
      _uiConfig$escapeWithR = uiConfig.escapeWithReference,
      escapeWithReference = _uiConfig$escapeWithR === void 0 ? false : _uiConfig$escapeWithR,
      _uiConfig$dismiss_tar = uiConfig.dismiss_target_touch,
      dismiss_target_touch = _uiConfig$dismiss_tar === void 0 ? true : _uiConfig$dismiss_tar,
      _uiConfig$position = uiConfig.position,
      position = _uiConfig$position === void 0 ? "TOP" : _uiConfig$position,
      _uiConfig$text_config = uiConfig.text_config,
      text_config = _uiConfig$text_config === void 0 ? {} : _uiConfig$text_config,
      _uiConfig$title_confi = uiConfig.title_config,
      title_config = _uiConfig$title_confi === void 0 ? {} : _uiConfig$title_confi,
      view_id = uiConfig.view_id,
      _uiConfig$show_shadow = uiConfig.show_shadow,
      show_shadow = _uiConfig$show_shadow === void 0 ? false : _uiConfig$show_shadow,
      _uiConfig$show_close_ = uiConfig.show_close_icon,
      show_close_icon = _uiConfig$show_close_ === void 0 ? false : _uiConfig$show_close_,
      _uiConfig$dim_backgro = uiConfig.dim_background_color,
      dim_background_color = _uiConfig$dim_backgro === void 0 ? "#0a0a0a" : _uiConfig$dim_backgro,
      _uiConfig$dim_backgro2 = uiConfig.dim_background_opacity,
      dim_background_opacity = _uiConfig$dim_backgro2 === void 0 ? 0.5 : _uiConfig$dim_backgro2,
      _uiConfig$layout_type = uiConfig.layout_type,
      layout_type = _uiConfig$layout_type === void 0 ? "default" : _uiConfig$layout_type,
      _uiConfig$pb_color = uiConfig.pb_color,
      pb_color = _uiConfig$pb_color === void 0 ? "orange" : _uiConfig$pb_color,
      _uiConfig$index = uiConfig.index,
      index = _uiConfig$index === void 0 ? 0 : _uiConfig$index,
      _uiConfig$total = uiConfig.total,
      total = _uiConfig$total === void 0 ? 1 : _uiConfig$total,
      _uiConfig$iframe_id = uiConfig.iframe_id,
      iframe_id = _uiConfig$iframe_id === void 0 ? "" : _uiConfig$iframe_id;
    rtmInstance.currentAction = ApxorWalkthroughTour.complete;
    var text_alignment = (text_config === null || text_config === void 0 ? void 0 : text_config.alignment) || "center";
    var title_alignment = (title_config === null || title_config === void 0 ? void 0 : title_config.alignment) || "center";
    var configId = messageConfig.configId,
      configName = messageConfig.configName;
    var _generateButtons = generateButtons(buttons_config, ApxorWalkthroughTour, configId, configName),
      buttons_array = _generateButtons.buttons_array,
      buttons_css = _generateButtons.buttons_css;
    var textContentCSS = {
      color: text_config.color,
      fontSize: text_config.size,
      fontFamily: text_config.font_family,
      fontStyle: text_config.style
    };
    if (text_config.margin_config && Object.keys(text_config.margin_config).length > 0) {
      var margin = text_config.margin_config;
      textContentCSS.margin = "".concat(margin.top, "px ").concat(margin.right, "px ").concat(margin.bottom, "px ").concat(margin.left, "px");
    }
    var style = text_config.style;
    if (style === "bold") {
      textContentCSS.fontWeight = style;
    }
    var titleContentCSS = {
      color: title_config.color,
      fontSize: title_config.size,
      fontFamily: title_config.font_family,
      fontStyle: title_config.style
    };
    if (title_config.margin_config && Object.keys(title_config.margin_config).length > 0) {
      var _margin = title_config.margin_config;
      titleContentCSS.margin = "".concat(_margin.top, "px ").concat(_margin.right, "px ").concat(_margin.bottom, "px ").concat(_margin.left, "px");
    }
    style = title_config.style;
    if (style === "bold") {
      textContentCSS.fontWeight = style;
    }
    var textContent;
    switch (layout_type) {
      case "with_progress":
        textContent = "\n<div>\n <div style=\"height: 6px;background: ".concat(pb_color, ";width: ").concat((index + 1) / total * 100, "%;border-radius: ").concat(corners["enabled"] ? corners["width"] : 0, "px;\"></div>\n <header class=\"shepherd-header\" style=\"").concat(title_config ? "padding: 10px 10px 0 10px" : "", "\">\n  ").concat(title_config ? "<h3 class=\"shepherd-title\" id=\"apxor-step-".concat(index, "-label\" style=\"padding: 0 !important;padding-right: 0.7em;text-align:").concat(title_alignment, ";\">").concat(getStylisedText(title_config === null || title_config === void 0 ? void 0 : title_config.text, title_config === null || title_config === void 0 ? void 0 : title_config.segments, title_config === null || title_config === void 0 ? void 0 : title_config.quote, title_config === null || title_config === void 0 ? void 0 : title_config.link_config), "</h3>") : "", "\n </header>\n <p style=\"padding: 8px 10px;text-align:").concat(text_alignment, ";\">").concat(getStylisedText(text_config === null || text_config === void 0 ? void 0 : text_config.text, text_config === null || text_config === void 0 ? void 0 : text_config.segments, text_config === null || text_config === void 0 ? void 0 : text_config.quote, text_config === null || text_config === void 0 ? void 0 : text_config.link_config), "</p>\n</div>\n      ");
        // eslint-disable-next-line no-case-declarations
        var fragment = new DOMParser().parseFromString(textContent, "text/html");

        // If we put the DOM node in text, the Shepherd library will append the HTML
        textContent = fragment.body.children[0];
        break;
      default:
        if ((text_config === null || text_config === void 0 || (_text_config$segments = text_config.segments) === null || _text_config$segments === void 0 ? void 0 : _text_config$segments.length) > 0) {
          textContent = getStylisedText(text_config === null || text_config === void 0 ? void 0 : text_config.text, text_config === null || text_config === void 0 ? void 0 : text_config.segments, text_config === null || text_config === void 0 ? void 0 : text_config.quote, text_config === null || text_config === void 0 ? void 0 : text_config.link_config);
        } else {
          textContent = [text_config && text_config.text ? text_config.text : "Tap here"];
        }
        break;
    }
    var tooltipCSS = {
      "border-radius": corners["enabled"] ? corners["width"] : 0,
      background: bg_color,
      "border-color": border["color"],
      "border-width": border["width"]
    };
    var button;
    if (Apxor.isFlutter()) {
      var _configId = messageConfig.configId,
        _configName = messageConfig.configName;
      var _uiConfig$dismiss_tar2 = uiConfig.dismiss_target_touch,
        _dismiss_target_touch = _uiConfig$dismiss_tar2 === void 0 ? true : _uiConfig$dismiss_tar2;
      button = createTargetView(getElementPositionFromFlutter(view_id));
      if (button) {
        flutterClickCallbackWrapper = addClickListenerForFlutterElement(button, function () {
          /*attach a click listener for target view*/
          onClickCallback(rtmInstance, _configId, _configName, true, _dismiss_target_touch);
          // removeELementOnScroll(onHidden);
        });
      }
    } else {
      button = getElementFromSelector(view_id, iframe_id);
    }
    if (!button) {
      console.warn("Element not found with id or path");
      return;
    }
    var dummySpan = document.createElement("span");
    dummySpan.setAttribute("id", "apxor-style-" + configId + "-step-" + index);
    var styleElement = document.createElement("style");
    styleElement.innerHTML = "\n#shepherdModalOverlayContainer {\n  -ms-filter: \"progid:dximagetransform.microsoft.gradient.alpha(Opacity=50)\";\n  filter: alpha(opacity=50);height: 100vh;left: 0;opacity: ".concat(dim_background_opacity !== null && dim_background_opacity !== void 0 ? dim_background_opacity : 0.5, ";position: fixed;\n  top: 0;transition: all .3s ease-out;width: 100vw;z-index: 9997;fill: ").concat(dim_background_color !== null && dim_background_color !== void 0 ? dim_background_color : "transparent", "\n}\n#shepherdModalOverlayContainer #shepherdModalMask, #shepherdModalOverlayContainer #shepherdModalMaskRect {\n  height: 100vh;width: 100vw\n}\n.shepherd-modal.shepherd-enabled {\n  position: relative;z-index: 9998\n}\n.shepherd-active.shepherd-modal-is-visible :not(.shepherd-target) {\n  pointer-events: none\n}\n.shepherd-active.shepherd-modal-is-visible .shepherd-button, .shepherd-active.shepherd-modal-is-visible .shepherd-button *, .shepherd-active.shepherd-modal-is-visible .shepherd-cancel-link, .shepherd-active.shepherd-modal-is-visible .shepherd-cancel-link *, .shepherd-active.shepherd-modal-is-visible .shepherd-element, .shepherd-active.shepherd-modal-is-visible .shepherd-element *, .shepherd-active.shepherd-modal-is-visible .shepherd-target, .shepherd-active.shepherd-modal-is-visible .shepherd-target * {\n  pointer-events: auto\n}\n.tippy-popper.shepherd {\n  z-index: 999999\n}\n.tippy-popper.shepherd[x-placement^=top] {\n  margin-top: 0px\n}\n.tippy-popper.shepherd[x-placement^=bottom] {\n  margin-top: 8px\n}\n.tippy-popper.shepherd[x-placement^=left] {\n  margin-right: 0px\n}\n.tippy-popper.shepherd[x-placement^=right] {\n  margin-left: 0px\n}\n.tippy-popper.shepherd .tippy-tooltip .tippy-content {\n  max-height: 100%;padding-top:0px;padding-bottom:0px;text-align: left;max-width: 400px;\n}\n.shepherd-element, .shepherd-element *, .shepherd-element:after, .shepherd-element :after, .shepherd-element:before, .shepherd-element :before {\n  box-sizing: border-box\n}\n.shepherd-element {\n  outline: none;\n}\n.shepherd-element .shepherd-content header {\n  *zoom: 1;align-items: left;border-top-left-radius: 5px;border-top-right-radius: 5px;\n  display: flex;justify-content: left;line-height: 2em;").concat(show_close_icon ? "padding: .75em;" : "", "\n}\n.shepherd-element .shepherd-content header:after {\n  clear: both;content: \"\";display: table\n}\n.shepherd-element .shepherd-content header .shepherd-cancel-link, .shepherd-element .shepherd-content header .shepherd-title {\n  margin: 0;padding: 0;position: relative;vertical-align: middle\n}\n.shepherd-element .shepherd-content header .shepherd-title {\n  text-align:").concat(title_alignment, ";\n  color: ").concat(titleContentCSS["color"], ";display: flex;flex: 1 0 auto;\n  font-size:  ").concat(titleContentCSS["fontSize"], "px;font-family: ").concat(titleContentCSS["fontFamily"], ";\n  font-weight: ").concat(titleContentCSS["fontStyle"] !== "bold" ? "normal" : titleContentCSS["fontStyle"], ";font-style: ").concat(titleContentCSS["fontStyle"] === "italic" ? "italic" : "unset", ";\n  line-height: ").concat(layout_type === "default" ? "26" : "20", "px;letter-spacing:0.01em;padding: .7em;padding-bottom: 0px;max-width: 400px;\n}\n.shepherd-element .shepherd-content header .shepherd-cancel-link {\n  color: hsla(0, 0%, 70.2%, .75);font-size: 2em;margin-left: auto;\n  text-decoration: none;transition: color .5s ease\n}\n.shepherd-element .shepherd-content header .shepherd-cancel-link:before {\n  mix-blend-mode: screen;content: \"\xD7\"\n}\n.shepherd-element .shepherd-content header .shepherd-cancel-link:hover {\n  mix-blend-mode: difference;\n}\n.shepherd-element .shepherd-content .shepherd-text {\n  text-align:").concat(text_alignment, ";\n  line-height: 1em;").concat(layout_type === "default" ? "padding:14px;padding-top:4px" : "", "\n}\n.shepherd-element .shepherd-content .shepherd-text a,\n.shepherd-element .shepherd-content .shepherd-text a:active,\n.shepherd-element .shepherd-content .shepherd-text a:visited {\n  border-bottom: 1px dotted rgba(0, 0, 0, .75);color: ").concat(textContentCSS["color"], ";\n  opacity: 0.75;text-decoration: none\n}\n.shepherd-element .shepherd-content .shepherd-text a:active:hover, \n.shepherd-element .shepherd-content .shepherd-text a:hover,\n.shepherd-element .shepherd-content .shepherd-text a:visited:hover {\n  border-bottom-style: solid\n}\n.shepherd-element .shepherd-content .shepherd-text p {\n  margin-top: 0\n}\n.shepherd-element .shepherd-content .shepherd-text p:last-child {\n  margin-bottom: 0\n}\n.shepherd-content > .shepherd-text p {\n  font-size:  ").concat(textContentCSS["fontSize"], "px;font-family: ").concat(textContentCSS["fontFamily"], "; \n  font-weight: ").concat(textContentCSS["fontStyle"] !== "bold" ? "normal" : textContentCSS["fontStyle"], ";\n  font-style: ").concat(textContentCSS["fontStyle"] === "italic" ? "italic" : "unset", ";\n  color: ").concat(textContentCSS["color"], ";line-height: ").concat(layout_type === "default" ? "26" : "20", "px;letter-spacing:0.01em;\n}\n").concat(getButtonsCSS(buttons_css, button_position, button_direction, ".shepherd-element .shepherd-content "), "\n@-webkit-keyframes cycle {\n  0% { transform: ").concat(translateDir(position, 0), "; }\n  50% { transform: ").concat(translateDir(position, 50), "; }\n  100% { transform: ").concat(translateDir(position, 100), "; }\n}\n@keyframes cycle {\n  0% { transform: ").concat(translateDir(position, 0), "; }\n  50% { transform: ").concat(translateDir(position, 50), "; }\n  100% { transform: ").concat(translateDir(position, 100), "; }\n}\n.tippy-tooltip.apxor-").concat(configId, "-step-").concat(index, "-theme {\n  animation: ").concat(animation["enabled"] ? animation["type"] + " 1000ms" : "none", ";\n  animation-timing-function: ease-in-out;animation-iteration-count: infinite;\n  box-shadow: ").concat(show_shadow ? shadow : "none", ";color: ").concat(textContentCSS["color"], ";\n  opacity: ").concat(opacity, ";border-radius: ").concat(tooltipCSS["border-radius"] + "px", ";\n  background-color: ").concat(tooltipCSS["background"], ";").concat(getPropertyFrom(position), ";\n}\n.apxor-").concat(configId, "-step-").concat(index, "-theme  .tippy-roundarrow {\n  fill: ").concat(tooltipCSS["background"], ";\n}\n.tippy-tooltip[data-placement^='top'] .tippy-arrow {\n  border-top-color: ").concat(tooltipCSS["background"], ";\n}\n.tippy-tooltip[data-placement^='bottom'] .tippy-arrow {\n  border-bottom-color: ").concat(tooltipCSS["background"], ";\n}\n.tippy-tooltip[data-placement^='left'] .tippy-arrow {\n  border-left-color: ").concat(tooltipCSS["background"], ";\n}\n.tippy-tooltip[data-placement^='right'] .tippy-arrow {\n  border-right-color: ").concat(tooltipCSS["background"], ";\n}\n  ");
    dummySpan.appendChild(styleElement);
    if (Apxor.isFlutter()) {
      document.body.appendChild(dummySpan);
    } else {
      button.parentNode.insertBefore(dummySpan, button);
    }
    var clickHandler = function clickHandler() {
      return onClickCallback(rtmInstance, configId, configName, true, dismiss_target_touch);
    };
    var onHidden = function onHidden() {
      var _ApxorWalkthroughTour2;
      try {
        var _ApxorWalkthroughTour;
        (_ApxorWalkthroughTour = ApxorWalkthroughTour) === null || _ApxorWalkthroughTour === void 0 || _ApxorWalkthroughTour.complete();
      } catch (e) {
        console.error(e);
      }
      // Detach the observer
      targetDeletionObserver.disconnect();
      viewPortObservor.disconnect();
      try {
        var _styleDiv$parentNode;
        var styleDiv = document.getElementById("apxor-style-" + configId + "-step-" + index);
        styleDiv === null || styleDiv === void 0 || (_styleDiv$parentNode = styleDiv.parentNode) === null || _styleDiv$parentNode === void 0 || _styleDiv$parentNode.removeChild(styleDiv);
      } catch (e) {
        window.ApxorLogger.error("Error removing the tooltip styles:" + e);
      }
      try {
        var _overlayDiv$parentNod;
        var overlayDiv = document.getElementById("shepherdModalOverlayContainer");
        overlayDiv === null || overlayDiv === void 0 || (_overlayDiv$parentNod = overlayDiv.parentNode) === null || _overlayDiv$parentNod === void 0 || _overlayDiv$parentNod.removeChild(overlayDiv);
      } catch (e) {
        window.ApxorLogger.error("Error removing the tooltip overlay:" + e);
      }
      if (on_tooltip_hidden) on_tooltip_hidden((_ApxorWalkthroughTour2 = ApxorWalkthroughTour) === null || _ApxorWalkthroughTour2 === void 0 ? void 0 : _ApxorWalkthroughTour2._isCancelled);
      button.removeEventListener("click", clickHandler);
      document.body.removeEventListener("click", flutterClickCallbackWrapper);
      if (Apxor.isFlutter()) {
        button.remove();
      }
    };
    var scrolledToView = false;
    // Add MutationObserver to the target element
    var targetDeletionObserver = new MutationObserver(function () {
      if (!document.body.contains(button)) {
        // Indicates that element is removed from DOM
        document.getElementById("shepherdModalOverlayContainer").remove();
        var nodes = document.getElementsByClassName("apxor-".concat(configId, "-step-").concat(index, "-theme"));
        if (nodes.length > 0 && nodes[0] && nodes[0].parentNode) {
          nodes[0].parentNode.remove();
        }
        onHidden();
      }
    });
    var viewPortObservor = new IntersectionObserver(function () {
      var elementInViewPort = isElementInViewport(button);
      if (!elementInViewPort && scrolledToView) {
        // Indicates that element is removed from DOM
        document.getElementById("shepherdModalOverlayContainer").remove();
        var nodes = document.getElementsByClassName("apxor-".concat(configId, "-step-").concat(index, "-theme"));
        if (nodes.length > 0 && nodes[0] && nodes[0].parentNode) {
          nodes[0].parentNode.remove();
        }
        onHidden();
      }
      if (elementInViewPort) {
        scrolledToView = true;
      }
    });
    var titleText = getStylisedText(title_config === null || title_config === void 0 ? void 0 : title_config.text, title_config === null || title_config === void 0 ? void 0 : title_config.segments, title_config === null || title_config === void 0 ? void 0 : title_config.quote, title_config === null || title_config === void 0 ? void 0 : title_config.link_config);
    ApxorWalkthroughTour.addStep("apxor-step-" + index, {
      title: layout_type === "default" ? titleText === "" ? null : titleText.outerHTML : null,
      text: textContent,
      classes: "apxor-".concat(configId, "-step-").concat(index, "-theme"),
      attachTo: {
        element: button,
        on: position.toLowerCase()
      },
      showCancelLink: show_close_icon,
      buttons: buttons_array,
      tippyOptions: {
        allowHTML: true,
        arrow: true,
        flipOnUpdate: true,
        interactive: true,
        maxWidth: "100%",
        hideOnClick: dismiss_outside_touch,
        escapeWithReference: escapeWithReference,
        theme: "apxor-".concat(configId, "-step-").concat(index),
        onShow: function onShow() {
          if (on_tooltip_shown) on_tooltip_shown();
          button.addEventListener("click", clickHandler);
          // Attach the observer upon show
          targetDeletionObserver.observe(document.body, {
            childList: true,
            subtree: true
          });
          viewPortObservor.observe(button);
        },
        onHidden: onHidden
      }
    });
  };
  var showTooltip = function showTooltip(uiConfig, walkthroughConfigs, terminationConfig, messageConfig, rtmInstance, on_tooltip_shown, on_tooltip_hidden) {
    var _uiConfig$title_confi2, _uiConfig$text_config2;
    var isWalkthrough = Array.isArray(walkthroughConfigs) && walkthroughConfigs.length > 0;
    var delay = uiConfig.delay,
      dim_background = uiConfig.dim_background,
      view_id = uiConfig.view_id,
      iframe_id = uiConfig.iframe_id,
      _uiConfig$find_interv = uiConfig.find_interval,
      find_interval = _uiConfig$find_interv === void 0 ? 0 : _uiConfig$find_interv,
      _uiConfig$max_find_in = uiConfig.max_find_interval,
      max_find_interval = _uiConfig$max_find_in === void 0 ? 10000 : _uiConfig$max_find_in,
      _uiConfig$scrollToVie = uiConfig.scrollToView,
      scrollToView = _uiConfig$scrollToVie === void 0 ? false : _uiConfig$scrollToVie;
    if (((_uiConfig$title_confi2 = uiConfig.title_config) === null || _uiConfig$title_confi2 === void 0 ? void 0 : _uiConfig$title_confi2.text) === DYNAMIC_TEXT) {
      var _uiConfig$title_confi3;
      ((_uiConfig$title_confi3 = uiConfig.title_config.script) === null || _uiConfig$title_confi3 === void 0 ? void 0 : _uiConfig$title_confi3.t) === 0 ? evaluateDynamicText(uiConfig.title_config) : evaluateDynamicScript(uiConfig.title_config);
    }
    if (((_uiConfig$text_config2 = uiConfig.text_config) === null || _uiConfig$text_config2 === void 0 ? void 0 : _uiConfig$text_config2.text) === DYNAMIC_TEXT) {
      var _uiConfig$text_config3;
      ((_uiConfig$text_config3 = uiConfig.text_config.script) === null || _uiConfig$text_config3 === void 0 ? void 0 : _uiConfig$text_config3.t) === 0 ? evaluateDynamicText(uiConfig.text_config) : evaluateDynamicScript(uiConfig.text_config);
    }
    var scrollTo = false;
    if (scrollToView) {
      scrollTo = {
        behavior: "smooth",
        block: "center"
      };
    }
    ApxorWalkthroughTour = new Shepherd.Tour({
      defaultStepOptions: {
        scrollTo: scrollTo
      },
      useModalOverlay: isWalkthrough || dim_background
    });

    // Checks if the element is in viewport. If it is then adds a step to the tour.
    var checkViewPortAndAddStep = function checkViewPortAndAddStep(element) {
      try {
        var rect = element.getBoundingClientRect();
        if (rect.width === 0 || rect.height === 0) {
          console.warn("Width and height are 0 for: ", view_id, ". Can't show");
          rtmInstance.currentAction = null;
          return;
        }
      } catch (e) {
        rtmInstance.isShowingAction = false;
        rtmInstance.currentAction = null;
        return;
      }
      if (isWalkthrough) {
        walkthroughConfigs.forEach(function (config) {
          var ui = config.ui;
          addTourStep(ui, messageConfig, rtmInstance, on_tooltip_shown, on_tooltip_hidden);
        });
      } else {
        addTourStep(uiConfig, messageConfig, rtmInstance, on_tooltip_shown, on_tooltip_hidden);
      }
      if (rtmInstance.isShowingAction) {
        window.ApxorLogger.error("An action already being shown");
        return;
      }
      try {
        ApxorWalkthroughTour.start();
        rtmInstance.isShowingAction = true;
      } catch (e) {
        rtmInstance.isShowingAction = false;
        rtmInstance.currentAction = null;
        console.error(e);
      }
    };

    // Continuously recheck for the HTML element after a configured find_interval.
    // For now we are checking for 10sec. Later we can take this from the configuration.
    var recheckViewElementAndAddStep = function recheckViewElementAndAddStep(view_id) {
      var recheckStartedAt = new Date();
      //For every find_interval
      var elementRecheckIntervalId = setInterval(function () {
        //If the element is found, stop checking and create a step
        if (rtmInstance.currentAction !== null && rtmInstance.currentAction !== undefined) {
          clearInterval(elementRecheckIntervalId);
          return;
        }
        var element;
        if (Apxor.isFlutter()) {
          var configId = messageConfig.configId,
            configName = messageConfig.configName;
          var _uiConfig$dismiss_tar3 = uiConfig.dismiss_target_touch,
            dismiss_target_touch = _uiConfig$dismiss_tar3 === void 0 ? true : _uiConfig$dismiss_tar3;
          element = createTargetView(getElementPositionFromFlutter(view_id));
          if (element) {
            flutterClickCallbackWrapper = addClickListenerForFlutterElement(element, function () {
              onClickCallback(rtmInstance, configId, configName, true, dismiss_target_touch);
            });
          }
        } else {
          element = getElementFromSelector(view_id, iframe_id);
        }
        if (element) {
          clearInterval(elementRecheckIntervalId);
          checkViewPortAndAddStep(element);
        } else {
          var currentTime = new Date();
          // If the element is not found even after 10sec, stop checking
          if (currentTime - recheckStartedAt > max_find_interval) {
            clearInterval(elementRecheckIntervalId);
            console.warn("Element with id:".concat(view_id, " not found."));
            rtmInstance.currentAction = null;
          }
        }
      }, find_interval);
    };
    setTimeout(function () {
      var element = getElementFromSelector(view_id, iframe_id);
      if (!element) {
        console.warn("Element with id:".concat(view_id, " not found."));
        if (find_interval) {
          console.warn("Rechecking");
          recheckViewElementAndAddStep(view_id);
        } else {
          rtmInstance.currentAction = null;
        }
      } else {
        checkViewPortAndAddStep(element);
      }
    }, delay);
    if (terminationConfig["auto_dismiss"] === true) {
      setTimeout(function () {
        try {
          ApxorWalkthroughTour.complete();
        } catch (e) {
          rtmInstance.isShowingAction = false;
          rtmInstance.currentAction = null;
          console.error(e);
        }
      }, delay + terminationConfig["duration"]);
    }
    return ApxorWalkthroughTour.complete;
  };

  var svgNS = "http://www.w3.org/2000/svg";
  var elementIds = {
    modalOverlay: "tippyModalOverlayContainer",
    modalOverlayMask: "tippyModalMask",
    modalOverlayMaskRect: "tippyModalMaskRect",
    modalOverlayMaskOpening: "tippyModalMaskOpening"
  };
  var createMask = function createMask(targetElement) {
    var circularcoachmark = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var containerElement = _createModalContainer();
    var defsElement = document.createElementNS(svgNS, "defs");
    var maskContainer = _createMaskContainer();
    var maskRect = _createMaskRect();
    var maskOpening = _createMaskOpening(circularcoachmark);
    var maskConsumer = _createMaskConsumer();
    positionModalOpening(targetElement, maskOpening);
    window.addEventListener("scroll", function () {
      positionModalOpening(targetElement, maskOpening);
      setAttributes(maskOpening, {
        "scroll-behavior": "smooth"
      });
    });
    maskContainer.appendChild(maskRect);
    maskContainer.appendChild(maskOpening);
    defsElement.appendChild(maskContainer);
    containerElement.appendChild(defsElement);
    containerElement.appendChild(maskConsumer);
    return containerElement;
  };

  /**
   * Set multiple attributes on an element, via a hash
   * @param {HTMLElement|SVGElement} el The element to set the attributes on
   * @param {Object} attrs A hash of key value pairs for attributes to set
   * @public
   */

  function setAttributes(el, attrs) {
    Object.keys(attrs).forEach(function (key) {
      el.setAttribute(key, attrs[key]);
    });
  }
  function _createModalContainer() {
    var element = document.createElementNS(svgNS, "svg");
    element.setAttributeNS(null, "id", elementIds.modalOverlay);
    if (Apxor.isFlutter()) {
      element.style.pointerEvents = "none";
      element.style.position = "absolute";
    }
    return element;
  }
  /**
   * <mask id="shepherdModalMask" x="0" y="0" width="100%" height="100%">
   */

  function _createMaskContainer() {
    var element = document.createElementNS(svgNS, "mask");
    setAttributes(element, {
      height: "100%",
      id: elementIds.modalOverlayMask,
      width: "100%",
      x: "0",
      y: "0"
    });
    return element;
  }
  /**
   *  <rect id="modalOverlayMaskRect" x="0" y="0" width="100%" height="100%" fill="#FFFFFF"/>
   */

  function _createMaskRect() {
    var element = document.createElementNS(svgNS, "rect");
    setAttributes(element, {
      fill: "#FFFFFF",
      height: "100%",
      id: elementIds.modalOverlayMaskRect,
      width: "100%",
      x: "0",
      y: "0"
    });
    return element;
  }
  /**
   * <rect id="shepherdModalMaskOpening" fill="#000000"/>
   */

  function _createMaskOpening(circularcoachmark) {
    var element = document.createElementNS(svgNS, "rect");
    if (circularcoachmark === true) {
      setAttributes(element, {
        fill: "#000000",
        id: elementIds.modalOverlayMaskOpening,
        rx: "50%",
        ry: "50%"
      });
    } else {
      setAttributes(element, {
        fill: "#000000",
        id: elementIds.modalOverlayMaskOpening
      });
    }
    return element;
  }

  /**
   * <rect x="0" y="0" width="100%" height="100%" mask="url(#shepherdModalMask)"/>
   */

  function _createMaskConsumer() {
    var element = document.createElementNS(svgNS, "rect");
    setAttributes(element, {
      height: "100%",
      width: "100%",
      x: "0",
      y: "0"
    });
    element.setAttribute("mask", "url(#".concat(elementIds.modalOverlayMask, ")"));
    return element;
  }
  function createSVGDivMask(targetElement) {
    var _targetElement$getBou = targetElement.getBoundingClientRect(),
      // x = _targetElement$getBou.x,
      // y = _targetElement$getBou.y,
      width = _targetElement$getBou.width,
      height = _targetElement$getBou.height,
      left = _targetElement$getBou.left,
      top = _targetElement$getBou.top;
    var s = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    s.setAttribute("width", document.scrollingElement.scrollWidth);
    s.setAttribute("height", document.scrollingElement.scrollHeight);
    s.setAttribute("id", "maskforflutter");
    s.style.position = "absolute";
    s.style.opacity = "0";
    s.setAttribute("pointer-events", "none");
    var path = document.createElementNS("http://www.w3.org/2000/svg", "path");
    path.setAttribute("d", "m0 0 l".concat(document.scrollingElement.scrollWidth, " 0 l0 ").concat(document.scrollingElement.scrollHeight, " l-").concat(document.scrollingElement.scrollWidth, " 0 l0 -").concat(document.scrollingElement.scrollHeight, " l").concat(left, " ").concat(top, " l0 ").concat(height, " l").concat(width, " 0 l0 ").concat(-height, " l").concat(-width, " 0Z"));
    path.setAttribute("pointer-events", "fill");
    s.appendChild(path);
    return s;
  }
  function positionModalOpening(targetElement, openingElement) {
    var modalOverlayOpeningPadding = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    if (targetElement.getBoundingClientRect && openingElement instanceof SVGElement) {
      var _targetElement$getBou = targetElement.getBoundingClientRect(),
        x = _targetElement$getBou.x,
        y = _targetElement$getBou.y,
        width = _targetElement$getBou.width,
        height = _targetElement$getBou.height,
        left = _targetElement$getBou.left,
        top = _targetElement$getBou.top; // getBoundingClientRect is not consistent. Some browsers use x and y, while others use left and top

      setAttributes(openingElement, {
        x: (x || left) - modalOverlayOpeningPadding,
        y: (y || top) - modalOverlayOpeningPadding,
        width: width + modalOverlayOpeningPadding * 2,
        height: height + modalOverlayOpeningPadding * 2
      });
    }
  }

  var DEFAULT_PADDING$1 = 5;
  var currentId = makeid(10);
  function getDocumentOffsetPosition(el) {
    var scroll_coachMark = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var rect = el.getBoundingClientRect();

    // Add window scroll position to get the offset position
    // relative to the document but not viewport.

    var scrollX = 0;
    var scrollY = 0;
    if (!scroll_coachMark) {
      scrollX = window.scrollX;
      scrollY = window.scrollY;
    }
    var left = rect.left + scrollX;
    var top = rect.top + scrollY;
    var right = rect.right + scrollX;
    var bottom = rect.bottom + scrollY;

    // polyfill missing 'x' and 'y' rect properties not returned
    // from getBoundingClientRect() by older browsers
    var x = isDefined(rect.x) ? rect.x + scrollX : left;
    var y = isDefined(rect.y) ? rect.y + scrollY : top;

    // width and height are the same
    var width = rect.width;
    var height = rect.height;
    return {
      left: left,
      top: top,
      right: right,
      bottom: bottom,
      x: x,
      y: y,
      width: width,
      height: height
    };
  }
  function createTitleDescriptionButtons(text_config) {
    var title_config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var buttons_config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
    var button_position = arguments.length > 3 ? arguments[3] : undefined;
    var button_direction = arguments.length > 4 ? arguments[4] : undefined;
    var uuid = arguments.length > 5 ? arguments[5] : undefined;
    var name = arguments.length > 6 ? arguments[6] : undefined;
    var on_dismiss = arguments.length > 7 ? arguments[7] : undefined;
    var scroll_coachMark = arguments.length > 8 ? arguments[8] : undefined;
    var element = null;
    if (!title_config && text_config) {
      element = createTextElement(text_config, currentId);
      /*element = document.createElement("div");
      element.style.textAlign = text_config?.alignment || "center";
      element.appendChild(createTextElement(text_config, currentId));*/
    } else if (title_config && text_config) {
      element = document.createElement("div");
      element.style.display = "inline-flex";
      element.style.flexDirection = "column";
      element.style.visibility = "hidden";
      element.style.textAlign = (text_config === null || text_config === void 0 ? void 0 : text_config.alignment) || "center";
      element.style.lineHeight = "26px";
      element.style.letterSpacing = "0.01em";
      element.appendChild(createTextElement(title_config, currentId));
      element.appendChild(createTextElement(text_config, currentId));
    }
    if (buttons_config && buttons_config.length > 0) {
      var buttons = document.createElement("footer");
      buttons.className = "shepherd-footer";
      buttons.style.zIndex = 99999;
      buttons.style.margin = "8px";
      buttons.style.padding = "0";
      var hideCallback = function hideCallback() {
        if (on_dismiss) on_dismiss();
      };
      var _generateButtons = generateButtons(buttons_config, {
          next: hideCallback,
          complete: hideCallback,
          cancel: hideCallback
        }, uuid, name),
        buttons_array = _generateButtons.buttons_array,
        buttons_css = _generateButtons.buttons_css;
      var buttonsStyle = document.createElement("style");
      buttonsStyle.innerHTML = getButtonsCSS(buttons_css, button_position, button_direction);
      buttons.appendChild(buttonsStyle);
      buttons_array.forEach(function (button_data) {
        var classes = button_data.classes,
          text = button_data.text,
          action = button_data.action;
        var newButton = document.createElement("button");
        newButton.className = "shepherd-button " + classes;
        newButton.innerHTML = text;
        newButton.onclick = function () {
          return action();
        };
        buttons.appendChild(newButton);
      });
      var template = document.createElement("div");
      template.style.display = "inline-flex";
      template.style.flexDirection = "column";
      template.style.visibility = "hidden";
      template.appendChild(element);
      template.appendChild(buttons);
      element = template;
    }
    if (scroll_coachMark) {
      element.style.position = "fixed";
    } else element.style.position = "absolute";
    document.body.appendChild(element);
    return element;
  }
  function addRippleStyles(type, width, height) {
    return "\n<style>\n.ripple-animator {\n  ".concat(Apxor.isFlutter() ? "pointer-events:none;" : "", "\n  position: relative;\n  display: -webkit-box;\n  display: flex;\n  -webkit-box-orient: horizontal;\n  -webkit-box-direction: normal;\n  flex-direction: row;\n  -webkit-box-pack: center;\n  justify-content: center;\n  -webkit-box-align: center;\n  align-items: center;\n  height: ").concat(height, "px !important;\n  width: ").concat(width, "px !important;\n  border-radius: ").concat(type === "circle" ? "100%" : "0", ";\n}\n.ripple-animator span {\n  position: relative;\n  font-size: 72px;\n  top: 5px;left: -5px;\n}\n\n.ripple-animator:before,\n.ripple-animator:after {\n  content: '';\n  display: block;\n  position: absolute;\n  top: 0; \n  right: 0; \n  bottom: 0; \n  left: 0;\n  opacity:1;\n  z-index:10;\n  border: 0px solid white;\n  border-radius: ").concat(type === "circle" ? "100%" : "0%", ";\n  z-index: 99999;\n}\n\n.ripple-animator:before {\n  animation: ripple 1s infinite ease-out;\n}\n\n@keyframes ripple{\n  0% { \n    border: 0px solid white;\n    transform: scale(0.8); \n  }\n  100% { \n    border: 20px solid white;\n    transform: scale(1.5); \n    opacity:0; \n  }\n}\n</style>");
  }
  function createInnerCircle(width, height, left, top, type, has_ripple, scroll_coachMark) {
    var newWidth = Math.sqrt(Math.pow(width, 2) + Math.pow(height, 2));
    var newHeight = newWidth;
    var newLeft = left - (newWidth - width) / 2;
    var newTop = top - (newWidth - height) / 2;
    if (type != "circle") {
      newWidth = width;
      newHeight = height;
      newLeft = left;
      newTop = top;
    }
    var element = document.createElement("div");
    element.setAttribute("id", currentId + "-ripple-div");
    if (has_ripple) {
      element.innerHTML = addRippleStyles(type, newWidth, newHeight);
    }
    if (scroll_coachMark) {
      element.style.position = "fixed";
    } else element.style.position = "absolute";
    element.style.width = "".concat(newWidth, "px");
    element.style.height = "".concat(newHeight, "px");
    element.style.left = "".concat(newLeft, "px");
    element.style.top = "".concat(newTop, "px");
    element.classList.add("ripple-animator");
    // element.style.backgroundColor = "#fff";
    element.style.borderRadius = "".concat(type === "circle" ? "50%" : "0");
    // element.style.boxShadow = "rgb(255 255 255) 0px 0px 20px 15px";
    element.style.visibility = "hidden";
    if (Apxor.isFlutter()) {
      element.style.pointerEvents = "none";
    }
    document.body.appendChild(element);
    return element;
  }
  function getSVG(maskChild, svgChild) {
    return "\n  <svg\n    style=\"position:absolute;\"\n    height=\"".concat(document.scrollingElement.scrollHeight, "\" \n    width=\"").concat(document.scrollingElement.scrollWidth, "\"\n    class=\"apx-fade-in\">\n    <defs>\n      <mask\n        id=\"apx-mask\"\n        x=\"0\"\n        y=\"0\"\n        height=\"").concat(document.scrollingElement.scrollHeight, "\" \n        width=\"").concat(document.scrollingElement.scrollWidth, "\">\n        ").concat(maskChild, "\n      </mask>\n    </defs>\n    ").concat(svgChild, "\n  </svg>\n  ");
  }
  function getCircleSVG(data) {
    var bg_color = data.bg_color,
      opacity = data.opacity,
      innerRadius = data.innerRadius,
      innerCenterX = data.innerCenterX,
      innerCenterY = data.innerCenterY,
      outerRadius = data.outerRadius,
      outerCircleCenterX = data.outerCircleCenterX,
      outerCircleCenterY = data.outerCircleCenterY;
    var maskChild = "\n  <rect\n    x=\"".concat(outerCircleCenterX - outerRadius, "\"\n    y=\"").concat(outerCircleCenterY - outerRadius < 0 ? 0 : outerCircleCenterY - outerRadius, "\"\n    height=\"").concat(outerRadius * 2, "\"\n    width=\"").concat(outerRadius * 2, "\"\n    fill=\"#fff\" />\n  <circle\n    cx=\"").concat(innerCenterX, "\"\n    cy=\"").concat(innerCenterY, "\"\n    r=\"").concat(innerRadius, "\" />\n  ");
    var svgChild = "\n  <circle\n    cx=\"".concat(outerCircleCenterX, "\" \n    cy=\"").concat(outerCircleCenterY, "\" \n    r=\"").concat(outerRadius, "\" \n    fill=\"").concat(bg_color, "\" \n    fill-opacity=\"").concat(opacity, "\"\n    mask=\"url(#apx-mask)\" />\n  ");
    return getSVG(maskChild, svgChild);
  }
  function getRectangleSVG(data) {
    var bg_color = data.bg_color,
      opacity = data.opacity,
      targetElementLeft = data.targetElementLeft,
      targetElementTop = data.targetElementTop,
      targetElementWidth = data.targetElementWidth,
      targetElementHeight = data.targetElementHeight;
    var maskChild = "\n  <rect\n    x=\"0\" y=\"0\"\n    height=\"".concat(document.scrollingElement.scrollHeight, "\" \n    width=\"").concat(document.scrollingElement.scrollWidth, "\" \n    fill=\"#fff\"\n    ").concat(Apxor.isFlutter() ? 'style="pointer-events:none"' : "", "\n    />\n  <rect\n    x=\"").concat(targetElementLeft, "\" \n    y=\"").concat(targetElementTop, "\" \n    width=\"").concat(targetElementWidth, "\" \n    height=\"").concat(targetElementHeight, "\"\n    ").concat(Apxor.isFlutter() ? 'style="pointer-events:none"' : "", " />\n  ");
    var svgChild = "\n  <rect\n    x=\"0\" y=\"0\"\n    height=\"".concat(document.scrollingElement.scrollHeight, "\" \n    width=\"").concat(document.scrollingElement.scrollWidth, "\" \n    mask=\"url(#apx-mask)\"\n    fill=\"").concat(bg_color, "\" \n    fill-opacity=\"").concat(opacity, "\" />\n  ");
    return getSVG(maskChild, svgChild);
  }
  function createSVGDiv(data) {
    var opacity = data.opacity,
      type = data.type,
      scroll_coachMark = data.scroll_coachMark,
      element = data.element;
    var svgElement = document.createElement("div");
    svgElement.setAttribute("id", currentId + "-svg");
    if (scroll_coachMark) {
      svgElement.style.position = "fixed";
    } else svgElement.style.position = "absolute";
    svgElement.style.left = 0;
    svgElement.style.top = 0;
    svgElement.style.zIndex = 99998;
    svgElement.style.width = "100%";
    svgElement.style.height = "99%";
    if (Apxor.isFlutter()) {
      svgElement.style.pointerEvents = "none";
    }
    var svg = "";
    if (type === "circle") {
      svg = getCircleSVG(data);
    } else {
      svg = getRectangleSVG(data);
    }
    svgElement.innerHTML = "\n  <style>\n  @keyframes apx-anim {\n    from {\n      opacity: 0;\n    }\n    \n    to {\n      opacity: ".concat(opacity, ";\n    }\n  }\n  .apx-fade-in {\n    ").concat(Apxor.isFlutter() ? "pointer-events:none;" : "", "\n    animation: apx-anim 0.4s linear;\n  }\n  </style>\n  ").concat(svg);
    if (Apxor.isFlutter()) {
      var maskElement = createSVGDivMask(element);
      svgElement.appendChild(maskElement);
    }
    document.body.appendChild(svgElement);
    return svgElement;
  }
  function showCoachmark(ui_config, campaignConfig, termination_config, on_shown, on_dismissed) {
    var _ui_config$title_conf, _ui_config$text_confi;
    var view_id = ui_config.view_id,
      _ui_config$iframe_id = ui_config.iframe_id,
      iframe_id = _ui_config$iframe_id === void 0 ? "" : _ui_config$iframe_id;
    if (((_ui_config$title_conf = ui_config.title_config) === null || _ui_config$title_conf === void 0 ? void 0 : _ui_config$title_conf.text) === DYNAMIC_TEXT) {
      var _ui_config$title_conf2;
      ((_ui_config$title_conf2 = ui_config.title_config.script) === null || _ui_config$title_conf2 === void 0 ? void 0 : _ui_config$title_conf2.t) === 0 ? evaluateDynamicText(ui_config.title_config) : evaluateDynamicScript(ui_config.title_config);
    }
    if (((_ui_config$text_confi = ui_config.text_config) === null || _ui_config$text_confi === void 0 ? void 0 : _ui_config$text_confi.text) === DYNAMIC_TEXT) {
      var _ui_config$text_confi2;
      ((_ui_config$text_confi2 = ui_config.text_config.script) === null || _ui_config$text_confi2 === void 0 ? void 0 : _ui_config$text_confi2.t) === 0 ? evaluateDynamicText(ui_config.text_config) : evaluateDynamicScript(ui_config.text_config);
    }
    var element;
    if (Apxor.isFlutter()) {
      element = createTargetView(getElementPositionFromFlutter(view_id));
    } else {
      element = getElementFromSelector(view_id, iframe_id);
    }
    if (element) {
      var isTargetElementCovered = isElementCovered(element);
      if (isTargetElementCovered) {
        window.ApxorLogger.info("The tooltip is not visible because another element is overlapping the target element.");
        return;
      }
      addStep(element, ui_config, campaignConfig, termination_config, on_shown, on_dismissed);
    } else {
      var _ui_config$find_inter = ui_config.find_interval,
        find_interval = _ui_config$find_inter === void 0 ? 0 : _ui_config$find_inter,
        _ui_config$timeout = ui_config.timeout,
        timeout = _ui_config$timeout === void 0 ? 10000 : _ui_config$timeout;
      var recheckStartedAt = new Date();
      var rtmInstance = window.ApxorRTM;
      // TODO: There are different possible ways to identify the element.
      var elementRecheckIntervalId = setInterval(function () {
        if (Apxor.isFlutter()) {
          element = createTargetView(getElementPositionFromFlutter(view_id));
        } else {
          element = getElementFromSelector(view_id, iframe_id);
        }
        if (element) {
          clearInterval(elementRecheckIntervalId);
          if (rtmInstance.currentAction !== null && rtmInstance.currentAction !== undefined) {
            window.ApxorLogger.error("An action is already being shown. Try after it gets dismissed");
            return;
          }
          var _isTargetElementCovered = isElementCovered(element);
          if (_isTargetElementCovered) {
            window.ApxorLogger.info("The tooltip is not visible because another element is overlapping the target element.");
            return;
          }
          addStep(element, ui_config, campaignConfig, termination_config, on_shown, on_dismissed);
        } else {
          var currentTime = new Date();
          // If the element is not found even after 10sec, stop checking
          if (currentTime - recheckStartedAt > timeout) {
            clearInterval(elementRecheckIntervalId);
            console.warn("Element with id:".concat(view_id, " not found."));
            rtmInstance.currentAction = null;
          }
        }
      }, find_interval);
    }
  }
  function addStep(element, ui_config, campaignConfig, termination_config, on_shown, on_dismissed) {
    var bg_color = ui_config.bg_color,
      _ui_config$scroll_coa = ui_config.scroll_coachMark,
      scroll_coachMark = _ui_config$scroll_coa === void 0 ? false : _ui_config$scroll_coa,
      _ui_config$buttons_co = ui_config.buttons_config,
      buttons_config = _ui_config$buttons_co === void 0 ? [] : _ui_config$buttons_co,
      button_position = ui_config.button_position,
      _ui_config$button_dir = ui_config.button_direction,
      button_direction = _ui_config$button_dir === void 0 ? DIRECTION.HORIZONTAL : _ui_config$button_dir,
      _ui_config$coach_mark = ui_config.coach_mark_details,
      _ui_config$coach_mark2 = _ui_config$coach_mark.has_ripple,
      has_ripple = _ui_config$coach_mark2 === void 0 ? false : _ui_config$coach_mark2,
      _ui_config$coach_mark3 = _ui_config$coach_mark.type,
      type = _ui_config$coach_mark3 === void 0 ? "circle" : _ui_config$coach_mark3,
      delay = ui_config.delay,
      _ui_config$dismiss_ou = ui_config.dismiss_outside_touch,
      dismiss_outside_touch = _ui_config$dismiss_ou === void 0 ? false : _ui_config$dismiss_ou,
      _ui_config$opacity = ui_config.opacity,
      opacity = _ui_config$opacity === void 0 ? 0.8 : _ui_config$opacity,
      _ui_config$position = ui_config.position,
      position = _ui_config$position === void 0 ? "TOP" : _ui_config$position,
      text_config = ui_config.text_config,
      _ui_config$title_conf3 = ui_config.title_config,
      title_config = _ui_config$title_conf3 === void 0 ? null : _ui_config$title_conf3,
      view_id = ui_config.view_id,
      _ui_config$scroll_to_ = ui_config.scroll_to_view,
      scroll_to_view = _ui_config$scroll_to_ === void 0 ? false : _ui_config$scroll_to_;
    var configId = campaignConfig.configId,
      configName = campaignConfig.configName;
    var rtmInstance = window.ApxorRTM;
    var flutterClickWrapper = null;
    if (Apxor.isFlutter()) if (element) {
      flutterClickWrapper = addClickListenerForFlutterElement(element, function () {
        dismissCallback();
      });
    }
    if (!element) {
      console.warn("Element not found with id or path: ", view_id);
      return;
    }
    currentId = makeid(10);
    if (!scroll_to_view && !isElementInViewport(element)) {
      console.warn("Element ", view_id, " not in viewport. Can't show");
      return;
    }
    var scrolledToView = false;
    // Add MutationObserver to the target element
    var targetDeletionObserver = new MutationObserver(function () {
      if (!document.body.contains(element)) {
        will_dismiss();
      }
    });
    var viewPortObservor = new IntersectionObserver(function () {
      var elementInViewPort = isElementInViewport(element);
      if (!elementInViewPort && scrolledToView) {
        will_dismiss();
      }
      if (elementInViewPort) {
        scrolledToView = true;
      }
    });
    var rect = getDocumentOffsetPosition(element, scroll_coachMark);
    var _rect$left = rect.left,
      targetElementLeft = _rect$left === void 0 ? 0 : _rect$left,
      _rect$top = rect.top,
      targetElementTop = _rect$top === void 0 ? 0 : _rect$top,
      _rect$width = rect.width,
      targetElementWidth = _rect$width === void 0 ? 0 : _rect$width,
      _rect$height = rect.height,
      targetElementHeight = _rect$height === void 0 ? 0 : _rect$height;
    var isFirstHalf = rect.left < window.innerWidth / 2;
    if (targetElementHeight === 0 || targetElementWidth === 0) {
      console.warn("Can't show on an invisible element: ", view_id);
      return;
    }
    var will_dismiss = function will_dismiss() {
      // Detach the observer
      targetDeletionObserver.disconnect();
      viewPortObservor.disconnect();
      svgElement.remove();
      textElement.parentNode.removeChild(textElement);
      transparentCircle.parentNode.removeChild(transparentCircle);
      if (on_dismissed) on_dismissed();
      if (autoDismissCallback) clearTimeout(autoDismissCallback);
      document.body.removeEventListener("click", flutterClickWrapper);
      if (Apxor.isFlutter()) {
        element.remove();
      }
    };
    rtmInstance.currentAction = will_dismiss;
    var textElement = createTitleDescriptionButtons(text_config, title_config, buttons_config, button_position, button_direction, configId, configName, will_dismiss, scroll_coachMark);
    var textElemOffsetWidth = textElement.offsetWidth;
    var textElemOffsetHeight = textElement.offsetHeight;
    var marginLeft = 0;
    var marginRight = 0;
    if (text_config && text_config.margin_config) {
      marginLeft = Number(text_config.margin_config.left) || 0;
      marginRight = Number(text_config.margin_config.right) || 0;
    }
    var transparentCircle = createInnerCircle(targetElementWidth, targetElementHeight, targetElementLeft, targetElementTop, type, has_ripple, scroll_coachMark);
    var innerCenterX = targetElementLeft + targetElementWidth / 2;
    var innerCenterY = targetElementTop + targetElementHeight / 2;
    var innerRadius = Math.sqrt(Math.pow(targetElementWidth, 2) + Math.pow(targetElementHeight, 2)) / 2;
    var outerRadius = innerRadius + Math.max(textElemOffsetWidth, targetElementWidth) / 2 + 2 * DEFAULT_PADDING$1;

    // Calculate the text element and outer center Y positions
    var textElementOffsetTop = -1;
    var textElementOffsetLeft = -1;
    var left = -1;
    var outerCircleCenterY = -1;
    var innerCircleTop = innerCenterY - innerRadius;
    var innerCircleBottom = innerCenterY + innerRadius;
    switch (position) {
      case "TOP":
        left = innerCenterX - textElemOffsetWidth / 2;
        textElementOffsetLeft = left < 0 ? DEFAULT_PADDING$1 : left;
        if (type === "circle") {
          textElementOffsetTop = innerCenterY - innerRadius - textElemOffsetHeight - 25;
        } else {
          textElementOffsetTop = targetElementTop - textElemOffsetHeight - 25;
        }
        outerCircleCenterY = innerCircleBottom - Math.abs(innerCircleBottom - textElementOffsetTop) / 2;
        break;
      case "BOTTOM":
      case "RIGHT":
      case "LEFT":
        left = innerCenterX - textElemOffsetWidth / 2;
        textElementOffsetLeft = left < 0 ? DEFAULT_PADDING$1 : left;
        if (type === "circle") {
          textElementOffsetTop = innerCenterY + innerRadius + 25;
        } else {
          textElementOffsetTop = targetElementTop + targetElementHeight + 25;
        }
        outerCircleCenterY = innerCircleTop + (textElementOffsetTop + textElemOffsetHeight - innerCircleTop) / 2;
        break;
    }
    if (textElementOffsetLeft === -1 || textElementOffsetTop === -1 || outerCircleCenterY === -1) {
      console.warn("Failed to identify the right place for text");
      return;
    }

    // Position Text element
    if (!isFirstHalf && textElementOffsetLeft + textElemOffsetWidth > window.innerWidth) {
      textElementOffsetLeft = window.innerWidth - textElemOffsetWidth - marginLeft - marginRight - 10;
    }
    textElement.style.left = "".concat(textElementOffsetLeft, "px");
    textElement.style.top = "".concat(textElementOffsetTop, "px");

    // Calculate outer circle center X position
    left = Math.min(targetElementLeft, textElementOffsetLeft);
    var right = Math.max(targetElementLeft + targetElementWidth, textElementOffsetLeft + textElemOffsetWidth);
    var outerCircleCenterX = (left + right) / 2;
    outerCircleCenterX = Math.min(outerCircleCenterX, document.scrollingElement.scrollWidth);
    if (outerCircleCenterX < 0) {
      outerCircleCenterX = 0;
    }
    outerCircleCenterY = Math.min(outerCircleCenterY, document.scrollingElement.scrollHeight);
    if (outerCircleCenterY < 0) {
      outerCircleCenterY = 0;
    }
    var svgElement = createSVGDiv({
      bg_color: bg_color,
      opacity: opacity,
      innerRadius: innerRadius,
      innerCenterX: innerCenterX,
      innerCenterY: innerCenterY,
      outerRadius: outerRadius,
      outerCircleCenterX: outerCircleCenterX,
      outerCircleCenterY: outerCircleCenterY,
      targetElementLeft: targetElementLeft,
      targetElementTop: targetElementTop,
      targetElementWidth: targetElementWidth,
      targetElementHeight: targetElementHeight,
      type: type,
      scroll_coachMark: scroll_coachMark,
      element: element,
      dismiss_outside_touch: dismiss_outside_touch,
      dismissCallback: dismissCallback
    });
    svgElement.style.visibility = "hidden";
    transparentCircle.style.visibility = "hidden";
    textElement.style.visibility = "hidden";
    var autoDismissCallback = null;
    var dismissCallback = function dismissCallback(e) {
      var isUserHitTarget = false;
      var autoDismiss = false;
      if (e === undefined) {
        autoDismiss = true;
      }
      var rect = element.getBoundingClientRect();
      if (e !== undefined && e.clientX >= rect.left && e.clientX <= rect.left + rect.width && e.clientY >= rect.top && e.clientY <= rect.top + rect.height) {
        isUserHitTarget = true;
        rtmInstance.logActionEvent("InlineTargetViewClicked", campaignConfig.configId, campaignConfig.configName);
      }
      if (dismiss_outside_touch || isUserHitTarget || autoDismiss) {
        will_dismiss();
        // FIXME: Uncomment it, whenever you are confident!!
        if (isUserHitTarget && element.click) {
          element.click();
        }
      }
    };
    if (termination_config && termination_config.auto_dismiss === true) {
      autoDismissCallback = setTimeout(function () {
        return dismissCallback();
      }, delay + termination_config.duration);
    }
    svgElement.style.visibility = "visible";
    transparentCircle.style.visibility = "visible";
    textElement.style.visibility = "visible";
    if (textElement.childElementCount > 0) {
      textElement.children[0].style.visibility = "visible";
    }
    if (dismiss_outside_touch) {
      svgElement.addEventListener("click", function () {
        dismissCallback();
      });
    }
    transparentCircle.addEventListener("click", dismissCallback);
    if (scroll_to_view) {
      if (position === "TOP") {
        window.scrollTo({
          top: outerCircleCenterY - outerRadius,
          behavior: "smooth"
        });
      } else if (position === "BOTTOM") {
        window.scrollTo({
          top: Math.min(document.scrollingElement.scrollHeight, outerCircleCenterY + outerRadius),
          behavior: "smooth"
        });
      }
    }

    // Attach the observer upon show
    targetDeletionObserver.observe(document.body, {
      childList: true,
      subtree: true
    });
    viewPortObservor.observe(element);
    if (on_shown) on_shown();
  }
  function showCoachmarkWithDelay(ui_config, campaignConfig, termination_config, on_shown, on_dismissed) {
    var rtmInstance = window.ApxorRTM;
    if (rtmInstance.currentAction !== null && rtmInstance.currentAction !== undefined) {
      window.ApxorLogger.error("An action is already being shown. Try after it gets dismissed");
      return;
    }
    if (ui_config && ui_config.delay <= 0) {
      showCoachmark(ui_config, campaignConfig, termination_config, on_shown, on_dismissed);
      return;
    }
    setTimeout(function () {
      if (rtmInstance.currentAction !== null && rtmInstance.currentAction !== undefined) {
        window.ApxorLogger.error("An action is already being shown. Try after it gets dismissed");
        return;
      }
      showCoachmark(ui_config, campaignConfig, termination_config, on_shown, on_dismissed);
    }, ui_config.delay);
  }

  /**
   * @constructor Border
   * @example
   * Example of a border model is
   *
   * border: {
   *  radius : 50,
   *  color : "#FFFFFF",
   *  width : 2,
   *  style : "dotted"
   * }
   */
  var Border = /*#__PURE__*/function () {
    function Border() {
      var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck$1(this, Border);
      this.radius = getNumberOrDefault(data.radius, 0);
      this.color = getColorOrDefault(data.color, "#FFFFFF");
      this.inactive_color = getColorOrDefault(data.inactive_color, "#FFFFFF");
      this.width = getNumberOrDefault(data.width, 0);
      this.style = getStringOrDefault(data.style, "solid");
    }
    _createClass$1(Border, null, [{
      key: "isEnabled",
      value: function isEnabled(data) {
        if (isUndefined$1(data) || isNull(data) || isEmptyObject(data)) {
          return false;
        } else {
          return true;
        }
      }
    }]);
    return Border;
  }();

  /**
   * @constructor DimBackground
   * @example
   * Example of a DimBackground model is
   *
   * dimbackground: {
   *  opacity : 0.5,
   *  color : "#FFF"
   * }
   */
  var DimBackground = /*#__PURE__*/function () {
    function DimBackground() {
      var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck$1(this, DimBackground);
      this.opacity = getNumberOrDefault(data.opacity, 0.5);
      this.color = getColorOrDefault(data.color, "#FFF");
    }
    _createClass$1(DimBackground, null, [{
      key: "isEnabled",
      value: function isEnabled(data) {
        if (isUndefined$1(data) || isNull(data) || isEmptyObject(data)) {
          return false;
        } else {
          return true;
        }
      }
    }]);
    return DimBackground;
  }();

  /**
   * @constructor DismissActions
   * @example
   * Example of a DismissActions model is
   *
   * dismiss_actions: {
   *  outside_touch : true,
   *  target_touch : false,
   * }
   */
  var DismissActions = /*#__PURE__*/_createClass$1(function DismissActions() {
    var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    _classCallCheck$1(this, DismissActions);
    this.outside_touch = Boolean(data.outside_touch);
    this.target_touch = Boolean(data.target_touch);
  });

  /**
   * @constructor Padding
   * @example
   * Example of a Padding model is
   *
   * padding: {
   *  top : 10,
   *  bottom : 10,
   *  left : 12,
   *  right : 12
   * }
   */
  var Padding = /*#__PURE__*/function () {
    function Padding() {
      var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck$1(this, Padding);
      this.top = getNumberOrDefault(data === null || data === void 0 ? void 0 : data.top, 0);
      this.bottom = getNumberOrDefault(data === null || data === void 0 ? void 0 : data.bottom, 0);
      this.left = getNumberOrDefault(data === null || data === void 0 ? void 0 : data.left, 0);
      this.right = getNumberOrDefault(data === null || data === void 0 ? void 0 : data.right, 0);
    }
    _createClass$1(Padding, null, [{
      key: "isEnabled",
      value: function isEnabled(data) {
        if (isUndefined$1(data) || isNull(data) || isEmptyObject(data)) {
          return false;
        } else {
          return true;
        }
      }
    }]);
    return Padding;
  }();

  /**
   * @constructor Margin
   * @example
   * Example of a margin model is
   *
   * margin: {
   *  top : 10,
   *  bottom : 10,
   *  left : 12,
   *  right : 12
   * }
   */
  var Margin = /*#__PURE__*/function () {
    function Margin() {
      var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck$1(this, Margin);
      this.top = getNumberOrDefault(data === null || data === void 0 ? void 0 : data.top, 0);
      this.bottom = getNumberOrDefault(data === null || data === void 0 ? void 0 : data.bottom, 0);
      this.left = getNumberOrDefault(data === null || data === void 0 ? void 0 : data.left, 0);
      this.right = getNumberOrDefault(data === null || data === void 0 ? void 0 : data.right, 0);
    }
    _createClass$1(Margin, null, [{
      key: "isEnabled",
      value: function isEnabled(data) {
        if (isUndefined$1(data) || isNull(data) || isEmptyObject(data)) {
          return false;
        } else {
          return true;
        }
      }
    }]);
    return Margin;
  }();

  /**
   * @constructor Font
   * @example
   * Example of a Font model is
   *
   * font: {
   *  family:"sans-serif",
   *  size : 14,
   *  style : "bold",
   *  weight : "normal"
   * }
   */
  var Font = /*#__PURE__*/_createClass$1(function Font() {
    var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    _classCallCheck$1(this, Font);
    if (getFontFormatFromCustomFontURL(data.family) === "unknown format") {
      this.family = getStringOrDefault(data.family, "sans-serif").toLowerCase();
    } else {
      this.family = getStringOrDefault(data.family, "sans-serif");
    }
    this.size = getNumberOrDefault(data.size, "14");
    this.style = getStringOrDefault(data.style, "bold").toLowerCase();
    this.weight = data.weight;
  });

  /**
   * @constructor Icon
   * @example
   * Example of a icon model is
   *
   * icon: {
   *  path: "<assets-path>",
   *  height: 20,
   *  width: 20,
   *  position : "center",
   *  enable_padding: true,
   *  padding: {
   *   top : 10,
   *   bottom : 10,
   *   left : 12,
   *   right : 12
   *  },
   *  enable_margin: true,
   *  margin: {
   *   top : 10,
   *   bottom : 10,
   *   left : 12,
   *   right : 12
   *  },
   *  enable_border : true,
   *  border: {
   *    enable : true,
   *    radius : 50,
   *    color : "#FFFFFF",
   *    width : 2,
   *    style : "dotted"
   *  }
   * }
   */
  var Icon = /*#__PURE__*/function () {
    function Icon() {
      var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck$1(this, Icon);
      this.position = getStringOrDefault(convertThePositionCode(data === null || data === void 0 ? void 0 : data.position), "left");
      this.path = getStringOrDefault(data.path, "");
      this.width = getNumberOrDefault(data.width, 48);
      this.height = getNumberOrDefault(data.height, 48);
      this.enable_margin = data.enable_margin;
      this.margin = new Margin(data.margin);
      this.enable_padding = data.enable_padding;
      this.padding = new Padding(data.padding);
      this.enable_border = data.enable_border;
      this.border = new Border(data.border);
      this.alignment = getStringOrDefault(data.alignment, CENTER);
    }
    _createClass$1(Icon, null, [{
      key: "isEnabled",
      value: function isEnabled(data) {
        if (isUndefined$1(data) || isNull(data) || isEmptyObject(data)) {
          return false;
        } else {
          return true;
        }
      }
    }]);
    return Icon;
  }();

  /**
   * @constructor Text
   * @example
   * Example of a Text model is
   *
   * text: {
   *  alignment:"center",
   *  color:"red",
   *  font: {
   *   family:"sans-serif",
   *   size : 14,
   *   style : "bold",
   *   weight : "normal"
   *  },
   *  enable_padding: true,
   *  padding: {
   *   top : 10,
   *   bottom : 10,
   *   left : 12,
   *   right : 12
   *  },
   *  enable_margin: true,
   *  margin: {
   *   top : 10,
   *   bottom : 10,
   *   left : 12,
   *   right : 12
   *  },
   *  "is_dynamic_text" : true,
   *  "is_dynamic_script" : false,
   *  "script": {
   *   "cmds": "e abc;e zzz;e x;e y;r \"Hi y-{} x- {} zzz-{} abc-{}\",4",
   *   "vmap": {
   *       "x": {
   *           "t": "u",
   *           "n": "os_version",
   *           "def": "wind",
   *           "id": 1239
   *       },
   *       "y": {
   *           "t": "s",
   *           "n": "location",
   *           "def": "AP",
   *           "id": 1235
   *       },
   *       "zzz": {
   *           "t": "v",
   *           "n": "asdfasdf",
   *           "def": "NoValue",
   *           "id": 1236
   *       },
   *       "abc": {
   *           "t": "ev",
   *           "n": "apx_app_opened",
   *           "def": "-1",
   *           "prop": "apx_lt_count",
   *           "id": 1237
   *       }
   *   },
   *   "src": "Hi y-{y} x- {x} zzz-{zzz} abc-{abc}",
   *   "t": 0
   *  },
   * segments : [],
   * quote : false,
   * }
   */
  var Text = /*#__PURE__*/function () {
    function Text() {
      var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck$1(this, Text);
      this.background_color = getColorOrDefault(data === null || data === void 0 ? void 0 : data.background_color, "#FFF");
      this.alignment = getStringOrDefault(data.alignment, "center").toLowerCase();
      this.color = getColorOrDefault(data.color, "#FFF").toLowerCase();
      this.font = new Font(data.font);
      this.text = getStringOrDefault(data.text, "");
      this.localized_messages = data.localized_messages;
      this.enable_margin = data.enable_margin;
      this.margin = new Margin(data.margin);
      this.enable_padding = data.enable_padding;
      this.padding = new Padding(data.padding);
      this.enable_icon = data.enable_icon;
      this.icon = new Icon(data.icon);
      this.link_config = data.link_config;
      this.is_dyn = data.is_dyn;
      this.is_dynamic_text = data.is_dynamic_text;
      this.is_dynamic_script = data.is_dynamic_script;
      this.script = data.script;
      this.segments = data.segments;
      this.quote = data.quote;
    }
    _createClass$1(Text, null, [{
      key: "isEnabled",
      value: function isEnabled(data) {
        if (isUndefined$1(data) || isNull(data) || isEmptyObject(data)) {
          return false;
        } else {
          return true;
        }
      }
    }]);
    return Text;
  }();

  /**
   * @constructor Description
   * @example
   * Example of a Description model is
   *
   * description: {
   *  alignment:"center",
   *  color:"red",
   *  font: {
   *   family:"sans-serif",
   *   size : 14,
   *   style : "bold",
   *   weight : "normal"
   *  },
   *  padding: {
   *   top : 10,
   *   bottom : 10,
   *   left : 12,
   *   right : 12
   *  },
   *  margin: {
   *   top : 10,
   *   bottom : 10,
   *   left : 12,
   *   right : 12
   *  }
   * icon: {
   *  enable: true,
   *  path: "<assets-path>",
   *  height: 20,
   *  width: 20,
   *  position : "center"
   *  border: {
   *    enable : true,
   *    radius : 50,
   *    color : "#FFFFFF",
   *    width : 2,
   *    style : "dotted"
   *  }
   * },
   * "isDynamicText" : true,
   * "script": {
   *  "cmds": "e abc;e zzz;e x;e y;r \"Hi y-{} x- {} zzz-{} abc-{}\",4",
   *  "vmap": {
   *      "x": {
   *          "t": "u",
   *          "n": "os_version",
   *          "def": "wind",
   *          "id": 1239
   *      },
   *      "y": {
   *          "t": "s",
   *          "n": "location",
   *          "def": "AP",
   *          "id": 1235
   *      },
   *      "zzz": {
   *          "t": "v",
   *          "n": "asdfasdf",
   *          "def": "NoValue",
   *          "id": 1236
   *      },
   *      "abc": {
   *          "t": "ev",
   *          "n": "apx_app_opened",
   *          "def": "-1",
   *          "prop": "apx_lt_count",
   *          "id": 1237
   *      }
   *  },
   *  "src": "Hi y-{y} x- {x} zzz-{zzz} abc-{abc}",
   *  "t": 0
   * },
   * segments : [],
   * quote : false,
   * }
   */
  var Description = /*#__PURE__*/function (_Text) {
    _inherits$1(Description, _Text);
    var _super = _createSuper(Description);
    function Description() {
      var _this;
      var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck$1(this, Description);
      _this = _super.call(this, data);
      _this.is_title = false;
      _this.is_description = true;
      return _this;
    }
    return _createClass$1(Description);
  }(Text);

  /**
   * @constructor Title
   * @example
   * Example of a Title model is
   *
   * title: {
   *  alignment:"center",
   *  color:"red",
   *  font: {
   *   family:"sans-serif",
   *   size : 14,
   *   style : "bold",
   *   weight : "normal"
   *  },
   *  padding: {
   *   top : 10,
   *   bottom : 10,
   *   left : 12,
   *   right : 12
   *  },
   *  margin: {
   *   top : 10,
   *   bottom : 10,
   *   left : 12,
   *   right : 12
   *  }
   *
   * icon: {
   *  enable: true,
   *  path: "<assets-path>",
   *  height: 20,
   *  width: 20,
   *  position : "center"
   *  border: {
   *    enable : true,
   *    radius : 50,
   *    color : "#FFFFFF",
   *    width : 2,
   *    style : "dotted"
   *  }
   * },
   * "isDynamicText" : true,
   * "script": {
   *  "cmds": "e abc;e zzz;e x;e y;r \"Hi y-{} x- {} zzz-{} abc-{}\",4",
   *  "vmap": {
   *      "x": {
   *          "t": "u",
   *          "n": "os_version",
   *          "def": "wind",
   *          "id": 1239
   *      },
   *      "y": {
   *          "t": "s",
   *          "n": "location",
   *          "def": "AP",
   *          "id": 1235
   *      },
   *      "zzz": {
   *          "t": "v",
   *          "n": "asdfasdf",
   *          "def": "NoValue",
   *          "id": 1236
   *      },
   *      "abc": {
   *          "t": "ev",
   *          "n": "apx_app_opened",
   *          "def": "-1",
   *          "prop": "apx_lt_count",
   *          "id": 1237
   *      }
   *  },
   *  "src": "Hi y-{y} x- {x} zzz-{zzz} abc-{abc}",
   *  "t": 0
   * },
   * segments : [],
   * quote : false,
   * }
   */
  var Title = /*#__PURE__*/function (_Text) {
    _inherits$1(Title, _Text);
    var _super = _createSuper(Title);
    function Title() {
      var _this;
      var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck$1(this, Title);
      _this = _super.call(this, data);
      _this.is_title = true;
      _this.is_description = false;
      return _this;
    }
    return _createClass$1(Title);
  }(Text);

  /**
   * @constructor BackgroundImage
   * @example
   * Example of a BackgroundImage model is
   *
   * background_image: {
   *  mask_opacity : 0.5,
   *  mask_color : "#FFF"
   * }
   */
  var BackgroundImage = /*#__PURE__*/_createClass$1(function BackgroundImage() {
    var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    _classCallCheck$1(this, BackgroundImage);
    this.mask_opacity = getNumberOrDefault(data.mask_opacity, 0.25);
    this.mask_color = getColorOrDefault(data.mask_color, "#000000");
  });

  /**
   * @constructor Image
   * @example
   * Example of a image model is
   *
   * image: {
   *  path: "<assets-path>",
   *  height: 360,
   *  width: 360,
   *  enable_border : true,
   *  border: {
   *    enable : true,
   *    radius : 50,
   *    color : "#FFFFFF",
   *    width : 2,
   *    style : "dotted"
   *  },
   *  enable_background_image : true,
   *  background_image: {
   *   enable : true,
   *   mask_opacity : 0.5,
   *   mask_color : "#FFF"
   *  }
   * }
   */
  var Image = /*#__PURE__*/function () {
    function Image() {
      var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck$1(this, Image);
      this.path = getStringOrDefault(data.path, "");
      this.width = getNumberOrDefault(data.width, 360);
      this.height = getNumberOrDefault(data.height, 360);
      this.enable_background_image = data.enable_background_image;
      if (this.background_image) this.background_image = new BackgroundImage(data.background_image);
      this.enable_border = data.enable_border;
      if (this.enable_border) this.border = new Border(data.border);
    }
    _createClass$1(Image, null, [{
      key: "isEnabled",
      value: function isEnabled(data) {
        if (isUndefined$1(data) || isNull(data) || isEmptyObject(data)) {
          return false;
        } else {
          return true;
        }
      }
    }]);
    return Image;
  }();

  /**
   * @constructor Gradient
   * @example
   * Example of a Gradient model is
   *
   * gradient: {
   *  direction : "to right",
   *  colors : ["#FFF","#000"]
   * }
   */
  var Gradient = /*#__PURE__*/function () {
    function Gradient() {
      var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck$1(this, Gradient);
      this.direction = getStringOrDefault(data.direction, "to right");
      this.colors = getArrayOrDefault(data.colors, ["#FFF", "000"]);
    }
    _createClass$1(Gradient, null, [{
      key: "isEnabled",
      value: function isEnabled(data) {
        if (isUndefined$1(data) || isNull(data) || isEmptyObject(data)) {
          return false;
        } else {
          return true;
        }
      }
    }]);
    return Gradient;
  }();

  /**
   * @constructor NumberedStepper
   * @example
   * Example of a NumberedStepper model is
   *
   * numbered: {
   *  style : "number",
   *  position : "bottom-left",
   *  font: {
   *   family:"sans-serif",
   *   size : 14,
   *   style : "bold",
   *   weight : "normal"
   *  },
   *  color: "#123",
   * }
   */
  var NumberedStepper = /*#__PURE__*/function () {
    function NumberedStepper() {
      var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck$1(this, NumberedStepper);
      this.style = getStringOrDefault(data.style, "number");
      this.position = getStringOrDefault(data.position, "bottom-left");
      this.font = new Font(data.font);
      this.color = getColorOrDefault(data.color, "#FFF");
    }
    _createClass$1(NumberedStepper, null, [{
      key: "isEnabled",
      value: function isEnabled(data) {
        if (isUndefined$1(data) || isNull(data) || isEmptyObject(data)) {
          return false;
        } else {
          return true;
        }
      }
    }]);
    return NumberedStepper;
  }();

  /**
   * @constructor Pagination
   * @example
   * Example of a Pagination model is
   *
   * pagination: {
   *  style : "number",
   *  position : "bottom-left",
   *  font: {
   *   family:"sans-serif",
   *   size : 14,
   *   style : "bold",
   *   weight : "normal"
   *  },
   *  color: "#123",
   * }
   */
  var Pagination = /*#__PURE__*/function () {
    function Pagination() {
      var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck$1(this, Pagination);
      this.style = getStringOrDefault(data.style, "number");
      this.position = getStringOrDefault(data.position, "bottom-left");
      this.font = new Font(data.font);
      this.color = getColorOrDefault(data.color, "#FFF");
    }
    _createClass$1(Pagination, null, [{
      key: "isEnabled",
      value: function isEnabled(data) {
        if (isUndefined$1(data) || isNull(data) || isEmptyObject(data)) {
          return false;
        } else {
          return true;
        }
      }
    }]);
    return Pagination;
  }();

  /**
   * @constructor ProgressBar
   * @example
   * Example of a ProgressBar model is
   *
   * progressbar: {
   *  position : "top", //"bottom"
   *  width : 2,
   *  progress_color : "#000",
   *  reamining_color : "#FFFF",
   * }
   */
  var ProgressBar = /*#__PURE__*/function () {
    function ProgressBar() {
      var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck$1(this, ProgressBar);
      this.position = getStringOrDefault(data.position, "top");
      this.width = getNumberOrDefault(data.position, 4);
      this.progress_color = getColorOrDefault(data.progress_color, "#000");
      this.remaining_color = getColorOrDefault(data.remaining_color, "#FFFF");
    }
    _createClass$1(ProgressBar, null, [{
      key: "isEnabled",
      value: function isEnabled(data) {
        if (isUndefined$1(data) || isNull(data) || isEmptyObject(data)) {
          return false;
        } else {
          return true;
        }
      }
    }]);
    return ProgressBar;
  }();

  /**
   * @constructor Carousel
   * @example
   * Example of a Carousel model is
   *
   * Carousel: {
   *  style:"circle", // "narrow"
   *  space_between:1,
   *  active_radius:8,
   *  inactive_radius:4,
   *  active_color:"#000",
   *  inactive_color:"#123",
   * }
   */
  var Carousel = /*#__PURE__*/function () {
    function Carousel() {
      var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck$1(this, Carousel);
      this.style = getStringOrDefault(data.style, "default");
      this.spacebetween = this.position = getNumberOrDefault(data.space_between, 4);
      this.active_radius = getNumberOrDefault(data.active_radius, 4);
      this.inactive_radius = getNumberOrDefault(data.inactive_radius, 2);
      this.active_color = getColorOrDefault(data.active_color, "#000000");
      this.inactive_color = getColorOrDefault(data.inactive_color, "#FFF");
    }
    _createClass$1(Carousel, null, [{
      key: "isEnabled",
      value: function isEnabled(data) {
        if (isUndefined$1(data) || isNull(data) || isEmptyObject(data)) {
          return false;
        } else {
          return true;
        }
      }
    }]);
    return Carousel;
  }();

  /**
   * @constructor Pagination
   * @example
   * Example of a Pagination-text model is
   *  "pagination_text": {
        "text": "Question",
        "color": "#CFCFCF",
        "background_color": "transparent",
        "max_characters": 150,
        "alignment": "left",
        "font": {
          "family": "sans-serif",
          "size": 12,
          "style": "normal",
           "weight": "normal"
        },
        "enable_padding": true,
        "padding": {
          "top": 0,
          "bottom": 0,
          "left": 0,
          "right": 0
        },
        "enable_margin": true,
        "margin": {
          "bottom": 0,
          "left": 0,
          "right": 0,
          "top": 0
        }
      }
   */
  var Paginationtext = /*#__PURE__*/function () {
    function Paginationtext() {
      var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck$1(this, Paginationtext);
      this.text = getStringOrDefault(data === null || data === void 0 ? void 0 : data.text, "step");
      this.color = getColorOrDefault(data.color, "#FFF");
      this.background_color = getColorOrDefault(data.background_color, "#FFF");
      this.alignment = getColorOrDefault(data.alignment, "#FFF");
      this.font = new Font(data.font);
      this.enable_padding = data.enable_padding;
      if (this.enable_padding) this.padding = new Padding(data === null || data === void 0 ? void 0 : data.padding);
      this.enable_margin = data.enable_margin;
      if (this.enable_margin) this.margin = new Margin(data === null || data === void 0 ? void 0 : data.margin);
    }
    _createClass$1(Paginationtext, null, [{
      key: "isEnabled",
      value: function isEnabled(data) {
        if (isUndefined$1(data) || isNull(data) || isEmptyObject(data)) {
          return false;
        } else {
          return true;
        }
      }
    }]);
    return Paginationtext;
  }();

  /**
   * @constructor Stepper
   * @example
   * Example of a Stepper model is
   *
   * stepper: {
   *  index : 1,
   *  length : 4,
   *  enable_numbered: false,
   *  enable_pagination: false,
   *  enable_progressbar: true,
   *  progressbar: {
   *   position : "top", //"bottom"
   *   width : 2,
   *   progress_color : "#000",
   *   reamining_color : "#FFFF",
   *  }
   * }
   */
  var Stepper = /*#__PURE__*/function () {
    function Stepper() {
      var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck$1(this, Stepper);
      this.index = getNumberOrDefault(data.index, 1);
      this.length = getNumberOrDefault(data.length, 1);
      this.enable_numbered = data.enable_numbered;
      if (this.enable_numbered) this.numbered = new NumberedStepper(data.numbered);
      this.enable_pagination = data.enable_pagination;
      if (this.enable_pagination) this.pagination = new Pagination(data.pagination);
      this.enable_carousel = data.enable_carousel;
      if (this.enable_carousel) this.carousel = new Carousel(data.carousel);
      this.enable_progressbar = data.enable_progressbar;
      if (this.enable_progressbar) this.progressbar = new ProgressBar(data.progressbar);

      //surveys
      this.type = data === null || data === void 0 ? void 0 : data.type;
      this.pagination_text = new Paginationtext(data === null || data === void 0 ? void 0 : data.pagination_text);
      this.enable_padding = data === null || data === void 0 ? void 0 : data.enable_padding;
      if (this.enable_padding) this.padding = new Padding(data.padding);
      this.enable_margin = data === null || data === void 0 ? void 0 : data.enable_margin;
      if (this.enable_margin) this.margin = new Margin(data.margin);
    }
    _createClass$1(Stepper, null, [{
      key: "isEnabled",
      value: function isEnabled(data) {
        if (isUndefined$1(data) || isNull(data) || isEmptyObject(data)) {
          return false;
        } else {
          return true;
        }
      }
    }]);
    return Stepper;
  }();

  /**
   * @constructor Offset
   * @example
   * Example of a Offset model is
   *
   * offset: {
   *    skid : 10,
   *    distance : 10,
   * }
   */
  var Offset = /*#__PURE__*/_createClass$1(function Offset() {
    var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    _classCallCheck$1(this, Offset);
    this.skid = getNumberOrDefault(data === null || data === void 0 ? void 0 : data.skid, 0);
    this.distance = getNumberOrDefault(data === null || data === void 0 ? void 0 : data.distance, 0);
    this.x = getNumberOrDefault(data === null || data === void 0 ? void 0 : data.x, 0);
    this.y = getNumberOrDefault(data === null || data === void 0 ? void 0 : data.y, 0);
  });

  /**
   * @constructor Position
   * @example
   * Example of a Position model is
   *
   * position: {
   *  position : "top-left",
   *  offset: {
   *    skid : 10,
   *    distance : 10,
   *    top: 0,
   *    bottom : 0,
   *    left: 0,
   *    right : 0
   *  }
   * }
   */
  var Position = /*#__PURE__*/_createClass$1(function Position() {
    var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    _classCallCheck$1(this, Position);
    this.position = getStringOrDefault(convertThePositionCode(data === null || data === void 0 ? void 0 : data.position), "top-left");
    this.enable_offset = data.enable_offset;
    this.offset = new Offset(data.offset);
  });

  /**
   * @constructor CloseButton
   * @example
   * Example of a close button model is
   *
   * close_button: {
   *  color: "#172B4D",
   *  fill_color: "#FFFFFF",
   *  type: "normal/filled/custom",
   *  path: "<assets-path>",
   *  offset_top: 8,
   *  offset_right: 8,
   *  height: 20,
   *  width: 20,
   *  action: "cancel/dismiss",
   *  shape: "rectangle/circle"
   * }
   */
  var CloseButton = /*#__PURE__*/function () {
    function CloseButton() {
      var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck$1(this, CloseButton);
      this.color = getColorOrDefault(data.color, "#FFFFFF");
      this.fill_color = getColorOrDefault(data.fill_color, "#FFFFFF");
      this.type = getStringOrDefault(data.type, "normal");
      this.path = data.path;
      this.height = getNumberOrDefault(data.height, 24);
      this.width = getNumberOrDefault(data.width, 24);
      this.offset_top = getNumberOrDefault(data.offset_top, 8);
      this.offset_right = getNumberOrDefault(data.offset_right, 8);
      this.action = getStringOrDefault(data.action, "dismiss");
      this.shape = getStringOrDefault(data.shape, "circle");

      //surveys
      if (data !== null && data !== void 0 && data.position) {
        this.position = new Position(data.position);
      }
      this.enable_margin = data.enable_margin;
      if (this.enable_margin) this.margin = new Margin(data.margin);
      this.enable_padding = data.enable_padding;
      if (this.enable_padding) this.padding = new Padding(data.padding);
      this.enable_border = data.enable_border;
      if (this.enable_border) this.border = new Border(data.border);
    }
    _createClass$1(CloseButton, null, [{
      key: "isEnabled",
      value: function isEnabled(data) {
        if (isUndefined$1(data) || isNull(data) || isEmptyObject(data)) {
          return false;
        } else {
          return true;
        }
      }
    }]);
    return CloseButton;
  }();

  /**
   * @constructor BackButton
   * @example
   * Example of a back button model is
   *
   * back_button: {
      path: "<path>",
      type: "normal/filled/custom",
      color: "#172B4D",
      shape: "rectangle/circle",
      height: 20,
      width: 20,
      position: {
        position: "TL",
        offset: {
          skid: 1,
          distance: 1,
        },
      },
      margin: {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0,
      },
      padding: {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0,
      },
      border: {
        color: "#045343",
        width: 5,
        radius: 5,
        style: "solid/dotted",
      },
    },
   */
  var BackButton = /*#__PURE__*/function () {
    function BackButton() {
      var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck$1(this, BackButton);
      this.path = data.path;
      this.type = getStringOrDefault(data.type, "normal");
      this.color = getColorOrDefault(data.color, "#FFFFFF");
      this.shape = getStringOrDefault(data.shape, "circle");
      this.height = getNumberOrDefault(data.height, 24);
      this.width = getNumberOrDefault(data.width, 24);
      this.offset_top = getNumberOrDefault(data.offset_top, 8);
      this.offset_left = getNumberOrDefault(data.offset_left, 8);
      this.action = getStringOrDefault(data === null || data === void 0 ? void 0 : data.action, "dismiss");
      if (data !== null && data !== void 0 && data.position) {
        this.position = new Position(data.position);
      }
      this.enable_margin = data.enable_margin;
      if (this.enable_margin) this.margin = new Margin(data.margin);
      this.enable_padding = data.enable_padding;
      if (this.enable_padding) this.padding = new Padding(data.padding);
      this.enable_border = data.enable_border;
      if (this.enable_border) this.border = new Border(data.border);
    }
    _createClass$1(BackButton, null, [{
      key: "isEnabled",
      value: function isEnabled(data) {
        if (isUndefined$1(data) || isNull(data) || isEmptyObject(data)) {
          return false;
        } else {
          return true;
        }
      }
    }]);
    return BackButton;
  }();

  /**
   * @constructor Header
   * @example
   * Example of a Header model is
   * header: {
   *    background_color: "#123",
   *    enable_title: true,
   *    title: {
           background_color: "#f1f0f0",
           max_characters: 150,
           text: "content",
           alignment: "center",
           color: "red",
           font: {
              family: "sans-serif",
              size: 14,
              style: "bold",
              weight: "normal",
           },
           padding: {
              "top ": 10,
              "bottom ": 10,
              "left ": 12,
              "right ": 12,
           },
           margin: {
              "top ": 10,
              "bottom ": 10,
              "left ": 12,
              "right ": 12,
           },
        },
        enable_desciption: true,
        desciption: {
           background_color: "#f1f0f0",
           max_characters: 150,
           text: "content",
           alignment: "center",
           color: "red",
           font: {
              family: "sans-serif",
              size: 14,
              style: "bold",
              weight: "normal",
           },
           padding: {
              "top ": 10,
              "bottom ": 10,
              "left ": 12,
              "right ": 12,
           },
           margin: {
              "top ": 10,
              "bottom ": 10,
              "left ": 12,
              "right ": 12,
           },
        },
        enable_image: true,
        image: {
           path: "<assets-path>",
           height: 360,
           width: 360,
           enable_border: true,
           border: {
           enable: true,
           radius: 50,
           color: "#FFFFFF",
           width: 2,
           style: "dotted",
           },
           enable_background_image: true,
           background_image: {
              enable: true,
              mask_opacity: 0.5,
              mask_color: "#FFF",
           },
        },
        enable_margin: true,
        margin: {
           top: 0,
           bottom: 0,
           left: 0,
           right: 0,
        },
        enable_padding: true,
        padding: {
           top: 0,
           bottom: 0,
           left: 0,
           right: 0,
        },
        enable_border: true,
        border: {
           color: "#045343",
           width: 5,
           radius: 5,
           style: "solid/dotted",
        },
        enable_gradient: true,
        gradient: {
           direction: "#045343",
           colors: ["#045343", "#045343"],
        },
      },
   */
  var Header = /*#__PURE__*/function () {
    function Header() {
      var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck$1(this, Header);
      this.background_color = data === null || data === void 0 ? void 0 : data.background_color;
      this.enable_stepper = data.enable_stepper;
      if (this.enable_stepper) this.stepper = new Stepper(data.stepper);
      this.enable_close_button = data.enable_close_button;
      if (this.enable_close_button) this.closebutton = new CloseButton(data.close_button);
      this.enable_back_button = data.enable_back_button;
      if (this.enable_back_button) this.backbutton = new BackButton(data.back_button);
      this.enable_title = data.enable_title;
      if (this.enable_title) this.title = new Title(data.title);
      this.enable_description = data.enable_description;
      if (this.enable_description) this.description = new Description(data.description);
      this.enable_image = data.enable_image;
      if (this.enable_image) this.image = new Image(data.image);
      this.enable_margin = data.enable_margin;
      if (this.enable_margin) this.margin = new Margin(data.margin);
      this.enable_padding = data.enable_padding;
      if (this.enable_padding) this.padding = new Padding(data.padding);
      this.enable_border = data.enable_border;
      if (this.enable_border) this.border = new Border(data.border);
      this.enable_gradient = data.enable_gradient;
      if (this.enable_gradient) this.gradient = new Gradient(data.gradient);
    }
    _createClass$1(Header, null, [{
      key: "isEnabled",
      value: function isEnabled(data) {
        if (isUndefined$1(data) || isNull(data) || isEmptyObject(data)) {
          return false;
        } else {
          return true;
        }
      }
    }]);
    return Header;
  }();

  var Labelelement = /*#__PURE__*/_createClass$1(function Labelelement() {
    var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    _classCallCheck$1(this, Labelelement);
    this.position = data.position;
    this.text = new Text(data.text);
  });

  var Labels = /*#__PURE__*/_createClass$1(function Labels() {
    var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    _classCallCheck$1(this, Labels);
    this.first_rating = new Labelelement(data.first_rating);
    this.last_rating = new Labelelement(data.last_rating);
  });

  /**
   * @constructor Question
   * @example
   * Example of a question model is
   * question: {
        answer_mode: "single_choice",
        enable_title: true,
        title: {
          background_color: "#f1f0f0",
          max_characters: 150,
          text: "content",
          alignment: "center",
          color: "red",
          font: {
            family: "sans-serif",
            size: 14,
            style: "bold",
            weight: "normal",
          },
          padding: {
            "top ": 10,
            "bottom ": 10,
            "left ": 12,
            "right ": 12,
          },
          margin: {
            "top ": 10,
            "bottom ": 10,
            "left ": 12,
            "right ": 12,
          },
        },
        enable_desciption: true,
        desciption: {
          background_color: "#f1f0f0",
          max_characters: 150,
          text: "content",
          alignment: "center",
          color: "red",
          font: {
            family: "sans-serif",
            size: 14,
            style: "bold",
            weight: "normal",
          },
          padding: {
            "top ": 10,
            "bottom ": 10,
            "left ": 12,
            "right ": 12,
          },
          margin: {
            "top ": 10,
            "bottom ": 10,
            "left ": 12,
            "right ": 12,
          },
        },
        enable_margin: true,
        margin: {
          top: 0,
          bottom: 0,
          left: 0,
          right: 0,
        },
        enable_padding: true,
        padding: {
          top: 0,
          bottom: 0,
          left: 0,
          right: 0,
        },
      },
   */
  var Question$1 = /*#__PURE__*/function () {
    function Question() {
      var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck$1(this, Question);
      this.id = data === null || data === void 0 ? void 0 : data.id;
      this.paths = data === null || data === void 0 ? void 0 : data.paths;
      this.enable_title = data.enable_title;
      if (this.enable_title) this.title = new Title(data.title);
      this.enable_description = data.enable_description;
      if (this.enable_description) this.description = new Description(data.description);
      this.enable_icon = data === null || data === void 0 ? void 0 : data.enable_icon;
      if (this.enable_icon) this.icon = new Icon(data.icon);
      this.enable_margin = data === null || data === void 0 ? void 0 : data.enable_margin;
      if (this.enable_margin) this.margin = new Margin(data.margin);
      this.enable_padding = data === null || data === void 0 ? void 0 : data.enable_padding;
      if (this.enable_padding) this.padding = new Padding(data.padding);
    }
    _createClass$1(Question, null, [{
      key: "isEnabled",
      value: function isEnabled(data) {
        if (isUndefined$1(data) || isNull(data) || isEmptyObject(data)) {
          return false;
        } else {
          return true;
        }
      }
    }]);
    return Question;
  }();

  var Suggestion = /*#__PURE__*/_createClass$1(function Suggestion(data) {
    _classCallCheck$1(this, Suggestion);
    this.bg_color_active = data.bg_color_active;
    this.bg_color_inactive = data.bg_color_inactive;
    this.color_active = data.color_active;
    this.color_inactive = data.color_inactive;
    this.font = new Font(data.font);
    this.text = data.text;
    this.enable_padding = data.enable_padding;
    if (this.enable_padding) this.padding = new Padding(data.padding);
    this.enable_margin = data.enable_margin;
    if (this.enable_margin) this.margin = new Margin(data.margin);
    this.enable_border = data.enable_border;
    if (this.enable_border) this.border = new Border(data.border);
  });

  var QandS = /*#__PURE__*/function () {
    function QandS(data) {
      _classCallCheck$1(this, QandS);
      this.start = data.start;
      this.end = data.end;
      this.question = new Question$1(data.question);
      this.enable_suggestion = data.enable_suggestion;
      if (this.enable_suggestion) this.suggestion = new Suggestion(data.suggestion);
      this.enable_input_text = data.enable_input_text;
      if (this.enable_input_text) {
        this.qandsInputAnswer = "";
      }
    }
    _createClass$1(QandS, null, [{
      key: "isEnabled",
      value: function isEnabled(data) {
        if (isUndefined$1(data) || isNull(data) || isEmptyObject(data)) {
          return false;
        } else {
          return true;
        }
      }
    }]);
    return QandS;
  }();

  /**
   * @constructor Shadow
   * @example
   * Example of a Shadow model is
   *
   * shadow: {
   *  color : "#FFF",
   *  offset_x : 2,
   *  offset_y : 2,
   *  blur_radius : 2,
   *  spread_radius : 2,
   * }
   */
  var Shadow = /*#__PURE__*/function () {
    function Shadow() {
      var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck$1(this, Shadow);
      this.color = getColorOrDefault(data.color, "#FFF");
      this.offset_x = getNumberOrDefault(data.offset_x, 0);
      this.offset_y = getNumberOrDefault(data.offset_y, 0);
      this.blur_radius = getNumberOrDefault(data.blur_radius, 0);
      this.spread_radius = getNumberOrDefault(data.spread_radius, 0);
    }
    _createClass$1(Shadow, null, [{
      key: "isEnabled",
      value: function isEnabled(data) {
        if (isUndefined$1(data) || isNull(data) || isEmptyObject(data)) {
          return false;
        } else {
          return true;
        }
      }
    }]);
    return Shadow;
  }();

  var RatingButtons = /*#__PURE__*/_createClass$1(function RatingButtons() {
    var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    _classCallCheck$1(this, RatingButtons);
    this.type = data.type;
    this.start = data.start;
    this.end = data.end;
    this.start_from_index = 0;
    if (this.start !== 0) {
      this.start_from_index = 1;
    }
    this.prev_selected_button = -1;
    this.selected_rating = [];
    if (this.start < this.end) {
      for (var i = this.start; i <= this.end; i++) {
        this.selected_rating.push(-1);
      }
    } else {
      for (var _i = this.end; _i >= this.start; _i--) {
        this.selected_rating.push(-1);
      }
    }
    this.width = data.width;
    this.height = data.height;
    this.split_line = data.split_line;
    this.enable_fade = data.enable_fade || false;
    this.enable_shadow = data.enable_shadow || false;
    if (this.enable_shadow) this.shadow = new Shadow(data.shadow);
    this.bg_color_active = getColorOrDefault(data.bg_color_active, "#FFF");
    this.bg_color_inactive = getColorOrDefault(data.bg_color_inactive, "#FFF");
    this.color_active = getColorOrDefault(data.color_active, "#FFF");
    this.color_inactive = getColorOrDefault(data.color_inactive, "#FFF");
    this.font = new Font(data.font);
    this.enable_box_model = data.enable_box_model || false;
    if (this.enable_box_model) {
      this.box_model = data.box_model;
    }
    this.enable_colors = data.enable_colors;
    this.buttons = [];
    if (data !== null && data !== void 0 && data.buttons && data.buttons.length !== 0) {
      this.length = data.buttons.length;
      this.buttons = data.buttons;
    } else {
      if (this.start > this.end) {
        var _ref = [this.end, this.start];
        this.start = _ref[0];
        this.end = _ref[1];
      }
      for (var _i2 = this.start; _i2 <= this.end; _i2++) {
        var obj = {};
        obj.value = _i2;
        this.buttons.push(obj);
      }
    }
    this.enable_border = data.enable_border;
    if (this.enable_border) this.border = data.border;
    this.enable_padding = data.enable_padding;
    if (this.enable_padding) this.padding = data.padding;
    this.enable_margin = data.enable_margin;
    if (this.enable_margin) this.margin = data.margin;
    this.prevSelectedRadioButton = -1; //to store the previous selected radio button.
    this.SelectedRadioButton = -1; //to store the current selected radio button.
  });

  /**{
    start: 1,
    end: 3,
    enable_text: "true",
    text: {
      background_color: "#f1f0f0",
      max_characters: 150,
      text: "How do you think this newly introduced feature will help out the new students of your academy?",
      alignment: "center",
      color: "#4C4B16",
      font: {
        family: "sans-serif",
        size: 14,
        style: "bold",
        weight: "normal",
      },
      enable_padding: true,
      padding: {
        "top ": 10,
        "bottom ": 10,
        "left ": 12,
        "right ": 12,
      },
      enable_margin: true,
      margin: {
        "top ": 0,
        "bottom ": 0,
        "left ": 0,
        "right ": 0,
      },
    },
    text_position: "above_image/below_image/below_rating",
    enable_image: "true",
    image: {
      height: 360,
      width: 360,
      path: "user_pic.png",
      enable_border: true,
      border: {
        radius: 50,
        color: "#FFFFFF",
        width: 2,
        style: "dotted",
      },
      enable_background_image: true,
      background_image: {
        enable: true,
        mask_opacity: 0.5,
        mask_color: "#FFF",
      },
      enable_margin: true,
      margin: {
        "top ": 0,
        "bottom ": 0,
        "left ": 0,
        "right ": 0,
      },
    },
  };
  */
  var Reaction = /*#__PURE__*/_createClass$1(function Reaction(data) {
    _classCallCheck$1(this, Reaction);
    this.start = data.start;
    this.end = data.end;
    this.enable_text = data.enable_text;
    if (this.enable_text) this.text = new Text(data.text);
    this.text_position = data.text_position;
    this.enable_image = data.enable_image;
    if (this.enable_image) this.image = data.image;
  });

  var Rating = /*#__PURE__*/_createClass$1(function Rating() {
    var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    _classCallCheck$1(this, Rating);
    this.reactions = [];
    this.reaction_paths = {};
    this.enable_reaction = false;
    this.prevReactionIndex = -1;
    this.currReactionIndex = -1;
    if (data !== null && data !== void 0 && data.reactions && data.reactions.length !== 0) {
      for (var i = 0; i < data.reactions.length; i++) {
        this.enable_reaction = true;
        var path = [];
        var reaction = new Reaction(data.reactions[i]);
        for (var _i = reaction.start; _i <= reaction.end; _i++) {
          path.push(parseInt(_i));
        }
        this.reaction_paths[i] = path;
        this.reactions.push(reaction);
      }
    }
    this.ratingbuttons = new RatingButtons(data.buttons);
    this.enable_labels = data.enable_labels;
    if (this.enable_labels) this.ratingLabels = new Labels(data.labels);
    this.QandSArray = [];
    this.qandsPaths = {};
    this.enable_qands = false;
    this.prevQandSArrayIndex = -1;
    this.stateOfQandS = [];
    for (var _i2 = 0; _i2 < this.ratingbuttons.length; _i2++) {
      this.stateOfQandS.push({
        suggestion: [],
        input_field: ""
      });
    }
    if (data !== null && data !== void 0 && data.q_and_s && data.q_and_s.length !== 0) {
      for (var _i3 = 0; _i3 < data.q_and_s.length; _i3++) {
        var qandsElement = new QandS(data.q_and_s[_i3]);
        this.enable_qands = true;
        var _path = [];
        for (var _i4 = qandsElement.start; _i4 <= qandsElement.end; _i4++) {
          _path.push(parseInt(_i4));
        }
        this.qandsPaths[_i3] = _path;
        this.QandSArray.push(qandsElement);
      }
    }
  });

  var List = /*#__PURE__*/function () {
    function List(data) {
      _classCallCheck$1(this, List);
      this.id = data.id;
      this.value = data.value;
      this.is_other = data.is_other;
      this.next_question_id = data.next_question_id;
      this.is_selected = false;
      this.other_answer = "";
    }
    _createClass$1(List, null, [{
      key: "isEnabled",
      value: function isEnabled(data) {
        if (isUndefined$1(data) || isNull(data) || isEmptyObject(data)) {
          return false;
        } else {
          return true;
        }
      }
    }]);
    return List;
  }();

  /**
   * "choices":{
      "randomize_choices": true,
      "color_active": "black",
      "color_inactive": "black",
      "radio_color_active": "blue",
      "radio_color_inactive": "black",
      "bg_color_active": "white",
      "bg_color_inactive": "white",
      "list": [
          {
              "id": 103239,
              "value": "For external exams",
              "is_other": false,
              "next_question_id": -1
          },
          {
              "id": 19433,
              "value": "For competitive knowledge",
              "is_other": false,
              "next_question_id": -1
          },
          {
              "id": 89456,
              "value": "For additional knowledge",
              "is_other": false,
              "next_question_id": -1
          },
          {
              "id": 38775,
              "value": "Others",
              "is_other": true,
              "next_question_id": -1
          }
      ]
                          },
   */
  var Choices = /*#__PURE__*/function () {
    function Choices(data) {
      _classCallCheck$1(this, Choices);
      this.randomize_choices = data === null || data === void 0 ? void 0 : data.randomize_choices;
      this.color_active = data === null || data === void 0 ? void 0 : data.color_active;
      this.color_inactive = data === null || data === void 0 ? void 0 : data.color_inactive;
      this.radio_color_active = data === null || data === void 0 ? void 0 : data.radio_color_active;
      this.radio_color_inactive = data === null || data === void 0 ? void 0 : data.radio_color_inactive;
      if (data !== null && data !== void 0 && data.bg_type && data.bg_type === "normal") {
        //this.choice_border_active is use when the bg_type is normal(means "outline")
        //frontend send the outline active and inactive color as bg_color_active and bg_color_inactive
        this.choice_border_active = data === null || data === void 0 ? void 0 : data.bg_color_active;
        this.choice_border_inactive = data === null || data === void 0 ? void 0 : data.bg_color_inactive;
        this.bg_color_active = "transparent";
        this.bg_color_inactive = "transparent";
      } else {
        this.bg_color_active = data === null || data === void 0 ? void 0 : data.bg_color_active;
        this.bg_color_inactive = data === null || data === void 0 ? void 0 : data.bg_color_inactive;
      }
      this.before_parse_choices = data.list;
      this.list = [];
      for (var i = 0; i < this.before_parse_choices.length; i++) {
        var list = new List(this.before_parse_choices[i]);
        this.list.push(list);
      }
      this.enable_border = data.enable_border;
      if (this.enable_border) this.border = new Border(data.border);
      if (this.randomize_choices) {
        this.list = getShuffledArr(this.list);
      }
    }
    _createClass$1(Choices, null, [{
      key: "isEnabled",
      value: function isEnabled(data) {
        if (isUndefined$1(data) || isNull(data) || isEmptyObject(data)) {
          return false;
        } else {
          return true;
        }
      }
    }]);
    return Choices;
  }();

  var InputText = /*#__PURE__*/_createClass$1(function InputText(data) {
    _classCallCheck$1(this, InputText);
    this.id = data === null || data === void 0 ? void 0 : data.id;
    this.background_color = getColorOrDefault(data.background_color, "#FFFFFF");
    this.max_characters = data.max_characters || "150";
    this.enable_placeholder = data.enable_placeholder;
    if (this.enable_placeholder) this.placeholder = data.placeholder || {};
    this.enable_border = data.enable_border;
    if (this.enable_border) this.border = data.border;
    this.text_color = data.text_color;
  });

  /**
   * @constructor Scroll
   * @example
   * Example of a Scroll model is
   *
   * scroll: {
   *  height: 400,
   *  enable_border: true,
   *  border : {
   *    radius : 50,
   *    color : "#FFFFFF",
   *    width : 2,
   *    style : "dotted"
   *  }
   * }
   */
  var Scroll = /*#__PURE__*/function () {
    function Scroll() {
      var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck$1(this, Scroll);
      this.height = getNumberOrDefault(data.height, 400);
      this.enable_border = data.enable_border;
      this.border = new Border(data.border);
    }
    _createClass$1(Scroll, null, [{
      key: "isEnabled",
      value: function isEnabled(data) {
        if (isUndefined$1(data) || isNull(data) || isEmptyObject(data)) {
          return false;
        } else {
          return true;
        }
      }
    }]);
    return Scroll;
  }();

  /**
   * @constructor answer
   * @example
   * Example of a answer model is
      "answer": {
        "enable_scroll":true,
        "scroll":{
            "height":300,
            "enable_border":true,
            "border":{
                "color": "black",
                "width": 1,
                "radius": 5,
                "style": "solid"
            }         
        },
        "background_color": "#FFFFFF",
        "is_required": false,
        "choices":{
            "randomize_choices": true,
            "color_active": "black",
            "color_inactive": "black",
            "radio_color_active": "blue",
            "radio_color_inactive": "black",
            "bg_color_active": "white",
            "bg_color_inactive": "white",
            "list": [
                {
                    "id": 103239,
                    "value": "For external exams",
                    "is_other": false,
                    "next_question_id": -1
                },
                {
                    "id": 19433,
                    "value": "For competitive knowledge",
                    "is_other": false,
                    "next_question_id": -1
                },
                {
                    "id": 89456,
                    "value": "For additional knowledge",
                    "is_other": false,
                    "next_question_id": -1
                },
                {
                    "id": 38775,
                    "value": "Others",
                    "is_other": true,
                    "next_question_id": -1
                }
            ]
        },
        "input_text":{
            "id": 85150,
            "background_color": "#000000",
            "max_characters": 150,
            "enable_placeholder": true,
            "placeholder": {
                "text": "palceholfderText",
                "color": "red"
            },
            "enable_border": true,
            "border":{},
            "text_color": "#ffffff"
        },
        "font": {
            "family": "Roboto",
            "size": 16,
            "style": "normal",
            "weight": "500"
        },
        "enable_border": true,
        "border": {
            "color": "black",
            "width": 1,
            "radius": 5,
            "style": "solid"
        },
        "enable_padding": true,
        "padding": {
            "top": 16,
            "bottom": 16,
            "left": 12,
            "right": 12
        },
        "enable_margin": true,
        "margin": {
            "top": 5,
            "bottom": 5,
            "left": 16,
            "right": 16
        }
                      },
   */
  var Answer = /*#__PURE__*/function () {
    function Answer() {
      var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck$1(this, Answer);
      this.answer_mode = data === null || data === void 0 ? void 0 : data.answer_mode;
      this.enable_scroll = data.enable_scroll || false;
      if (this.enable_scroll) this.scroll = new Scroll(data.scroll);
      this.background_color = getColorOrDefault(data.background_color);
      if (data !== null && data !== void 0 && data.choices && Object.keys(data.choices).length !== 0) {
        this.choices = new Choices(data.choices);
      }
      this.input_text = {};
      if (data !== null && data !== void 0 && data.input_text && Object.keys(data.input_text).length !== 0) {
        this.input_text = new InputText(data.input_text);
        this.text_answer = "";
        this.is_answered = false;
      }
      if (data !== null && data !== void 0 && data.rating && Object.keys(data.rating).length !== 0) {
        this.rating = new Rating(data.rating);
      }
      if (data !== null && data !== void 0 && data.font) this.font = new Font(data.font);
      this.enable_border = data.enable_border;
      if (this.enable_border) this.border = new Border(data.border);
      this.enable_margin = data.enable_margin;
      if (this.enable_margin) this.margin = new Margin(data.margin);
      this.enable_padding = data.enable_padding;
      if (this.enable_padding) this.padding = new Padding(data.padding);
    }
    _createClass$1(Answer, null, [{
      key: "isEnabled",
      value: function isEnabled(data) {
        if (isUndefined$1(data) || isNull(data) || isEmptyObject(data)) {
          return false;
        } else {
          return true;
        }
      }
    }]);
    return Answer;
  }();

  /**
   * @constructor Action
   * @example
   * Example of a Action model is
   *
   * action: {
   *  type: "dismiss",
   *  url : "",
   *  is_external : false,
   *  is_ir:false,
   *  is_within:true,
   *  callback:(()=>{})
   * }
   */
  var Action = /*#__PURE__*/_createClass$1(function Action() {
    var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    _classCallCheck$1(this, Action);
    this.type = getStringOrDefault(data.type, "dismiss").toLowerCase();
    this.url = getStringOrDefault(data.url, "");
    this.is_external = Boolean(data.is_external);
    this.is_ir = Boolean(data.is_ir);
    this.callback = data.callback || function () {};
    this.is_within = Boolean(data.is_within);
  });

  /**
   * @constructor Button
   * @example
   * Example of a Button model is
   *
   * button : {
   *  slot: 1,
   *  color: "#27a4f2",
   *  type: "stepper",
   *  sub_type: "number",
   *  enable_action: true,
   *  action: {
   *    type: "dismiss",
   *    url: "",
   *    is_external: true,
   *    is_ir: false,
   *    is_within:true,
   *    callback: ()=>{}
   *  },
   * enable_border: true,
   * border: {
   *   radius: 0,
   *   color: "#000000",
   *   width: 0,
   *   style:"solid"
   * },
   * enable_margin: true,
   * margin: {
   *   bottom: 18,
   *   left: 8,
   *   right: 8,
   *   top: 18,
   * },
   * enable_padding: true,
   * padding: {
   *   bottom: 0,
   *   left: 0,
   *   right: 0,
   *   top: 0,
   * },
   *  enable_text:true,
   *  text: {
   *   alignment: "center",
   *   color: "red",
   *   font: {
   *     family: "sans-serif",
   *     size: 14,
   *     style: "bold",
   *     weight: "normal",
   *   },
   *   enable_padding: true,
   *   padding: {
   *     top: 10,
   *      bottom: 10,
   *     left: 12,
   *     right: 12,
   *   },
   *   enable_margin: true,
   *   margin: {
   *     top: 10,
   *     bottom: 10,
   *     left: 12,
   *     right: 12,
   *   },
   *   isDynamicText: true,
   *   script: {
   *     cmds: 'e abc;e zzz;e x;e y;r "Hi y-{} x- {} zzz-{} abc-{}",4',
   *     vmap: {
   *       x: {
   *         t: "u",
   *          n: "os_version",
   *         def: "wind",
   *         id: 1239,
   *       },
   *       y: {
   *         t: "s",
   *         n: "location",
   *         def: "AP",
   *         id: 1235,
   *       },
   *       zzz: {
   *         t: "v",
   *          n: "asdfasdf",
   *         def: "NoValue",
   *         id: 1236,
   *       },
   *       abc: {
   *         t: "ev",
   *         n: "apx_app_opened",
   *         def: "-1",
   *         id: 1237,
   *       },
   *       prop: "apx_lt_count",
   *     },
   *      src: "Hi y-{y} x- {x} zzz-{zzz} abc-{abc}",
   *     t: 0,
   *   },
   *   segments: [],
   *   quote: false,
   * },
  }

  */
  var Button = /*#__PURE__*/_createClass$1(function Button() {
    var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    _classCallCheck$1(this, Button);
    if (data !== null && data !== void 0 && data.position) {
      this.position = convertThePositionCode(new Position(data.position));
    }
    if ((data === null || data === void 0 ? void 0 : data.slot) === undefined) {
      this.slot = getSlotNumberByPosition(this.position.position);
    } else {
      this.slot = getNumberOrDefault(data.slot, 0);
    }
    if ((data === null || data === void 0 ? void 0 : data.type) === "wide") {
      this.slot = getSlotNumberByPosition("center");
    }
    this.type = getStringOrDefault(data.type, "button");
    this.sub_type = getStringOrDefault(data.sub_type, "");
    this.fill_color = getColorOrDefault(data.fill_color, "#FFF");
    this.color = getColorOrDefault(data.color || data.active_color, "#FFF");
    this.active_color = getColorOrDefault(data.active_color, "#FFF");
    this.inactive_color = getColorOrDefault(data.inactive_color, "#FFF");
    this.enable_action = data.enable_action;
    this.action = new Action(data.action);
    this.enable_margin = data.enable_margin;
    this.margin = new Margin(data.margin);
    this.enable_padding = data.enable_padding;
    this.padding = new Padding(data.padding);
    this.enable_border = data.enable_border;
    this.border = new Border(data.border);
    this.enable_text = data.enable_text;
    this.text = new Text(data.text);
    this.enable_gradient = data.enable_gradient;
    this.gradient = {};
    if (this.enable_gradient) {
      this.gradient = new Gradient(data.gradient);
    }
  });

  /**
   * @constructor BottomButton
   * @example
   * Example of a BottomButton model is
   *
   * {
   *  //button-config
   * }
   */
  var BottomButton = /*#__PURE__*/function (_Button) {
    _inherits$1(BottomButton, _Button);
    var _super = _createSuper(BottomButton);
    function BottomButton() {
      var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck$1(this, BottomButton);
      return _super.call(this, data);
    }
    return _createClass$1(BottomButton);
  }(Button);

  /**
   * @constructor CenterButton
   * @example
   * Example of a CenterButton model is
   *
   * {
   *  //button-config
   * }
   */
  var CenterButton = /*#__PURE__*/function (_Button) {
    _inherits$1(CenterButton, _Button);
    var _super = _createSuper(CenterButton);
    function CenterButton() {
      var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck$1(this, CenterButton);
      return _super.call(this, data);
    }
    return _createClass$1(CenterButton);
  }(Button);

  /**
   * @constructor FooterButton //survey footer buttons
   * @example
   * Example of a FooterButton model is
   *
   * {
   *  //button-config
   * }
   */
  var FooterButton = /*#__PURE__*/function (_Button) {
    _inherits$1(FooterButton, _Button);
    var _super = _createSuper(FooterButton);
    function FooterButton() {
      var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck$1(this, FooterButton);
      return _super.call(this, data);
    }
    return _createClass$1(FooterButton);
  }(Button);

  /**
   * @constructor TopButton
   * @example
   * Example of a TopButton model is
   *
   * {
   *  //button-config
   * }
   */
  var TopButton = /*#__PURE__*/function (_Button) {
    _inherits$1(TopButton, _Button);
    var _super = _createSuper(TopButton);
    function TopButton() {
      var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck$1(this, TopButton);
      return _super.call(this, data);
    }
    return _createClass$1(TopButton);
  }(Button);

  /**
   * @constructor Buttons
   * @example
   * Example of a Buttons model is
   *
   * buttons: {
   *  bottom : [{},{}],
   *  center : [{}],
   *  top : [{},{}],
   * }
   */
  var Buttons = /*#__PURE__*/_createClass$1(function Buttons() {
    var _this = this;
    var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    _classCallCheck$1(this, Buttons);
    this.background_color = data.background_color;
    this.enable_top = data.enable_top;
    this.enable_center = data.enable_center;
    this.enable_bottom = data.enable_bottom;
    this.bottom = [];
    this.center = [];
    this.top = [];
    this.buttons = []; //survey footer buttons

    var bottomButtons = getArrayOrDefault(data.bottom, []);
    bottomButtons.forEach(function (bottomButton) {
      _this.bottom.push(new BottomButton(bottomButton));
    });
    var centerButtons = getArrayOrDefault(data.center, []);
    centerButtons.forEach(function (centerButton) {
      _this.center.push(new CenterButton(centerButton));
    });
    var topButtons = getArrayOrDefault(data.top, []);
    topButtons.forEach(function (topButton) {
      _this.top.push(new TopButton(topButton));
    });
    var buttons = getArrayOrDefault(data.buttons, []);
    buttons.forEach(function (button) {
      _this.buttons.push(new FooterButton(button));
    });
    this.enable_margin = data.enable_margin;
    if (this.enable_margin) this.margin = new Margin(data.margin);
    this.enable_padding = data.enable_padding;
    if (this.enable_padding) this.padding = new Padding(data.padding);
    this.enable_border = data.enable_border;
    if (this.enable_border) this.border = new Border(data.border);
    this.enable_gradient = data.enable_gradient;
    if (this.enable_gradient) this.gradient = new Gradient(data.gradient);
  });

  var QandA = /*#__PURE__*/_createClass$1(function QandA() {
    var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    _classCallCheck$1(this, QandA);
    this.q_and_a = [];
    this.questionIDs = [];
    for (var i = 0; i < data.length; i++) {
      var question = new Question$1(data[i].question);
      if (question !== null && question !== void 0 && question.id) this.questionIDs.push(question.id);
      var answer = new Answer(data[i].answer);
      var footer = new Buttons(data[i].footer);
      var is_required = getBooleanOrDefault(data[i].is_required, false);
      this.q_and_a.push({
        question: question,
        answer: answer,
        footer: footer,
        is_required: is_required
      });
    }
  });

  /**
   * @constructor Survey
   * @example
   * Example of a survey model is
   * survey: {
      background_color: "#123",
      question: {
        answer_mode: "single_choice",
        enable_title: true,
        title: {
          background_color: "#f1f0f0",
          max_characters: 150,
          text: "content",
          alignment: "center",
          color: "red",
          font: {
            family: "sans-serif",
            size: 14,
            style: "bold",
            weight: "normal",
          },
          padding: {
            "top ": 10,
            "bottom ": 10,
            "left ": 12,
            "right ": 12,
          },
          margin: {
            "top ": 10,
            "bottom ": 10,
            "left ": 12,
            "right ": 12,
          },
        },
        enable_desciption: true,
        desciption: {
          background_color: "#f1f0f0",
          max_characters: 150,
          text: "content",
          alignment: "center",
          color: "red",
          font: {
            family: "sans-serif",
            size: 14,
            style: "bold",
            weight: "normal",
          },
          padding: {
            "top ": 10,
            "bottom ": 10,
            "left ": 12,
            "right ": 12,
          },
          margin: {
            "top ": 10,
            "bottom ": 10,
            "left ": 12,
            "right ": 12,
          },
        },
        enable_margin: true,
        margin: {
          top: 0,
          bottom: 0,
          left: 0,
          right: 0,
        },
        enable_padding: true,
        padding: {
          top: 0,
          bottom: 0,
          left: 0,
          right: 0,
        },
      },
      answer: {
        is_required: false,
        randomize_choices: false,
        color_active: "#002845",
        color_inactive: "#002845",
        radio_color_active: "#017DFD",
        radio_color_inactive: "#E5E5E5",
        bg_color_active: "#017DFD",
        bg_color_inactive: "#E5E5E5",
        choices: [
          {
            id: 103239,
            value: "Option 1",
            is_other: false,
            next_question_id: -1,
          },
          {
            id: 19433,
            value: "Option 2",
            is_other: false,
            next_question_id: -1,
          },
          {
            id: 89456,
            value: "Option 3",
            is_other: false,
            next_question_id: -1,
          },
          {
            id: 38775,
            value: "Option 4",
            is_other: false,
            next_question_id: -1,
          },
        ],
        enable_margin: true,
        margin: {
          top: 0,
          bottom: 0,
          left: 0,
          right: 0,
        },
        enable_padding: true,
        padding: {
          top: 0,
          bottom: 0,
          left: 0,
          right: 0,
        },
      },
      enable_margin: true,
      margin: {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0,
      },
      enable_padding: true,
      padding: {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0,
      },
      enable_border: true,
      border: {
        color: "#045343",
        width: 5,
        radius: 5,
        style: "solid/dotted",
      },
      enable_gradient: true,
      gradient: {
        direction: "#045343",
        colors: ["#045343", "#045343"],
      },
    },
   */
  var Survey = /*#__PURE__*/function () {
    function Survey() {
      var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck$1(this, Survey);
      this.background_color = data === null || data === void 0 ? void 0 : data.background_color;
      this.is_response_based_survey = data === null || data === void 0 ? void 0 : data.is_response_based_survey;
      this.q_and_a = new QandA(data === null || data === void 0 ? void 0 : data.q_and_a);
      this.enable_margin = data.enable_margin;
      if (this.enable_margin) this.margin = new Margin(data.margin);
      this.enable_padding = data.enable_padding;
      if (this.enable_padding) this.padding = new Padding(data.padding);
      this.enable_border = data.enable_border;
      if (this.enable_border) this.border = new Border(data.border);
      this.enable_gradient = data.enable_gradient;
      if (this.enable_gradient) this.gradient = new Gradient(data.gradient);
    }
    _createClass$1(Survey, null, [{
      key: "isEnabled",
      value: function isEnabled(data) {
        if (isUndefined$1(data) || isNull(data) || isEmptyObject(data)) {
          return false;
        } else {
          return true;
        }
      }
    }]);
    return Survey;
  }();

  /**
   * @constructor Direction
   * @example
   * Example of a Direction model is
   *
   * direction: {
   *  nudge : "vertical",
   *  non_media : "vertical",
   *  buttons : "vertical"
   * }
   */
  var Direction = /*#__PURE__*/_createClass$1(function Direction() {
    var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    _classCallCheck$1(this, Direction);
    this.nudge = getStringOrDefault(convertTheDirectionCode(data.nudge), DIRECTION.VERTICAL);
    this.non_media = getStringOrDefault(convertTheDirectionCode(data.non_media), DIRECTION.VERTICAL);
    this.buttons = getStringOrDefault(convertTheDirectionCode(data.buttons), DIRECTION.HORIZONTAL);
  });

  var SuccessMessage = /*#__PURE__*/_createClass$1(function SuccessMessage(data) {
    _classCallCheck$1(this, SuccessMessage);
    this.enable_icon = data.enable_icon;
    if (this.enable_icon) {
      this.icon = new Icon(data.icon);
    }
    this.enable_description = data.enable_description;
    if (this.enable_description) {
      this.description = new Description(data.description);
    }
  });

  var Surveyrequest = /*#__PURE__*/_createClass$1(function Surveyrequest(data) {
    var _this = this;
    _classCallCheck$1(this, Surveyrequest);
    this.enable_close_button = data.enable_close_button || false;
    if (this.enable_close_button) this.closebutton = new CloseButton(data.close_button);
    this.enable_icon = data.enable_icon;
    if (this.enable_icon) this.icon = new Icon(data.icon);
    this.enable_title = data.enable_title;
    if (this.enable_title) this.title = new Title(data.title);
    this.enable_description = data.enable_description;
    if (this.enable_description) this.description = new Description(data.description);
    this.buttons = [];
    var buttons = getArrayOrDefault(data.buttons, []);
    buttons.forEach(function (button) {
      _this.buttons.push(new BottomButton(button));
    });
  });

  var Logger$6 = window.ApxorLogger;
  var NewSurveys = /*#__PURE__*/function () {
    function NewSurveys(configId, _name, config, uis, rtmInstance, showCallback, hideCallback) {
      var _this = this;
      _classCallCheck$1(this, NewSurveys);
      _defineProperty$1(this, "_getAnswerForQuestion", function (index) {
        if (index >= _this.QandAArray.length) {
          return null;
        }
        var question = _this.QandAArray[index].question;
        var answer = _this.QandAArray[index].answer;
        if (!question) {
          return null;
        }
        question.id;
        var answer_mode = answer.answer_mode,
          choices = answer.choices,
          input_text = answer.input_text,
          text_answer = answer.text_answer,
          is_answered = answer.is_answered;
        var list = choices === null || choices === void 0 ? void 0 : choices.list;
        var result = {
          answers: [],
          answerTexts: [],
          others: [],
          textBasedQuestionAnswers: []
        };
        switch (answer_mode) {
          case "single_choice":
          case "multi_choice":
            list.forEach(function (choice) {
              if (choice.is_selected) {
                result.answers.push(choice.id);
                result.answerTexts.push(choice.value);
                if (choice.is_other && choice.other_answer !== null && choice.other_answer.trim() !== "") {
                  result.others.push({
                    id: choice.id,
                    answer: choice.other_answer
                  });
                }
              }
            });
            break;
          case "text":
            if (is_answered && text_answer !== "" && text_answer.trim() !== "" && input_text !== null) {
              result.answers.push(input_text.id);
              result.answerTexts.push(text_answer);
              result.textBasedQuestionAnswers.push({
                id: input_text.id,
                answer: text_answer
              });
            }
            break;
        }
        return result;
      });
      _defineProperty$1(this, "_submitSurveyResponses", function (is_completed) {
        if (is_completed && _this.enable_success_message) {
          _this._enableSuccessMessageContainer();
        }
        // Prepare survey data and send to server
        var response = {
          survey_id: _this.configId,
          name: _this.name,
          responses: []
        };
        var QandAArray = _this.QandAArray;
        QandAArray.forEach(function (qandaarray, index) {
          var answer = _this._getAnswerForQuestion(index);
          var question = qandaarray.question;
          if (answer.answers.length > 0) {
            var data = {
              question_id: question.id,
              answers: answer.answers
            };
            if (answer.others.length > 0) {
              data.others = answer.others;
            } else if (answer.textBasedQuestionAnswers.length > 0) {
              data.others = answer.textBasedQuestionAnswers;
            }
            response.responses.push(data);
          }
        });
        if (response.responses.length > 0) {
          var power = Math.pow(10, 3);
          response.time_taken = Math.round((Date.now() - _this.startTime) / 1000 * power) / power;
          var controller = Apxor.getController();
          var _controller$getFromSt = controller.getFromStorage("_apx_cd", true),
            launch_time = _controller$getFromSt.session_info.launch_time;
          response.session_id = Apxor.getSessionId();
          response.is_completed = is_completed;
          response.app_version = controller.getFromStorage("apx_ver", false);
          response.device_uuid = Apxor.getClientId();
          response.launch_time = launch_time;
          response.user_attributes = controller.getUserAttributes();
          response.session_attributes = controller.getSessionAttributes();

          // this._sendReponseToServer(response);
        }

        if (is_completed) {
          _this._logSurveyAppEvent("apx_survey_completed", {
            apx_survey_id: _this.configId,
            apx_survey_name: _this.name,
            apx_survey_type: true,
            apx_time_to_complete: 200
          });
        }
      });
      _defineProperty$1(this, "_sendReponseToServer", function (data) {
        var surveysResponseUrl = SURVEY_RESPONSE_URL.replace("<app_id>", Apxor.getSiteId());
        console.log(JSON.stringify(data));
        fetch(surveysResponseUrl, {
          method: "POST",
          headers: {
            "Content-Type": "application/json"
          },
          body: JSON.stringify(data)
        });
      });
      _defineProperty$1(this, "_logSurveyAppEvent", function (name) {
        var _window$ApxorRTM;
        var attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var meta = (_window$ApxorRTM = window.ApxorRTM) === null || _window$ApxorRTM === void 0 ? void 0 : _window$ApxorRTM.getCampaignMeta(_this.configId);
        var attrs = meta._attr;
        Apxor.logEvent(name, _objectSpread2$1(_objectSpread2$1({
          apx_survey_id: _this.configId,
          apx_survey_name: _this.name
        }, attributes), attrs));
      });
      _defineProperty$1(this, "_logSurveyQuestionEvent", function (index) {
        var answer = _this._getAnswerForQuestion(index);
        var textBasedAnswers = [];
        if (answer.textBasedQuestionAnswers.length > 0) {
          answer.textBasedQuestionAnswers.forEach(function (textAnswers) {
            textBasedAnswers.push(textAnswers.answer);
          });
        }
        var apx_additional_info = {};
        var questionObj = _this.QandAArray[index].question;
        var answerObj = _this.QandAArray[index].answer;
        questionObj.id;
        var answer_mode = answerObj.answer_mode;
          answerObj.choices;
          answerObj.input_text;
          answerObj.text_answer;
          answerObj.is_answered;
        if (answer_mode === "single_choice" || answer_mode === "multi_choice") {
          apx_additional_info.apx_choice = answer.answerTexts;
          apx_additional_info.apx_free_text = answer.others;
        } else if (answer_mode === "text") {
          apx_additional_info.apx_choice = "";
          apx_additional_info.apx_free_text = textBasedAnswers;
        } else if (answer_mode === "nps") {
          apx_additional_info.apx_choice = ["6"];
          apx_additional_info.apx_nps_advanced_question = "chiranjevi";
          apx_additional_info.apx_nps_advanced_choice = ["indra", "stalin"];
          apx_additional_info.apx_nps_advanced_free_text = ["text response"];
        }
        if (answer.answers.length > 0) {
          _this._logSurveyAppEvent("apx_survey_question_answered", _objectSpread2$1({
            apx_question_id: _this.QandAArray[_this.index].question.id,
            apx_question_name: "",
            apx_question_type: _this.QandAArray[_this.index].answer.answer_mode,
            apx_question_position: _this.index + 1,
            apx_survey_id: _this.configId,
            apx_survey_name: _this.name,
            apx_survey_type: true
          }, apx_additional_info));
        }
      });
      this.configId = configId;
      this.name = _name;
      this.uis = uis;
      this.rtmInstance = rtmInstance;
      this.showCallback = showCallback;
      this.closeCallback = hideCallback;
      if (config) {
        var _this$survey, _this$survey2;
        this.delay = config.delay;
        this.width = config.width; //percentage
        this.height = config.height;
        this.background_color = config.background_color;
        this.cssPostFix = "-".concat(configId, "-").concat(_name).replaceAll(" ", "").replace(/[^\w\s]/gi, "");
        this.is_response_based_survey = config.is_response_based_survey;
        this.direction = new Direction(config.direction);
        this.position = new Position(config.position);
        this.enable_survey_request = config.enable_survey_request;
        if (this.enable_survey_request) this.surveyrequest = new Surveyrequest(config.survey_request);
        this.enable_dismiss_actions = config.enable_dismiss_actions;
        if (this.enable_dismiss_actions) this.dismiss_actions = new DismissActions(config.dismiss_actions);
        this.enable_dimbackground = config.enable_dimbackground;
        if (this.enable_dimbackground) this.dimbackground = new DimBackground(config.dimbackground);
        this.enable_padding = config.enable_padding;
        if (this.enable_padding) this.padding = new Padding(config.padding);
        this.enable_margin = config.enable_margin;
        if (this.enable_margin) this.margin = new Margin(config.margin);
        this.enable_border = config.enable_border;
        if (this.enable_border) this.border = new Border(config.border);
        this.enable_success_message = config.enable_success_message;
        if (this.enable_success_message) this.success_message = new SuccessMessage(config.success_message);
        this.enable_progressbar = config.enable_progressbar;
        if (this.enable_progressbar) this.progressbar = new ProgressBar(config.progressbar);
        this.enable_header = config.enable_header;
        if (this.enable_header) this.header = new Header(config.header);
        this.survey = new Survey(config.survey);
        this.QandAArray = (_this$survey = this.survey) === null || _this$survey === void 0 || (_this$survey = _this$survey.q_and_a) === null || _this$survey === void 0 ? void 0 : _this$survey.q_and_a;
        this.index = 0;
        this.questionids = (_this$survey2 = this.survey) === null || _this$survey2 === void 0 || (_this$survey2 = _this$survey2.q_and_a) === null || _this$survey2 === void 0 ? void 0 : _this$survey2.questionIDs;
        this.visitedQuestion = [-1];
        this.overlayElement = null;
        this.surveylaunched = false;
        this._setSurveyDimensions();
      }
    }
    _createClass$1(NewSurveys, [{
      key: "showNewSurvey",
      value: function showNewSurvey() {
        try {
          var canCreate = this._canCreateSurvey();
          if (canCreate) {
            this.createSurvey();
            this.showCallback();
          }
        } catch (e) {
          this._resetRTMAction();
        }
      }
    }, {
      key: "_canCreateSurvey",
      value: function _canCreateSurvey() {
        if (this.rtmInstance.currentAction !== null && this.rtmInstance.currentAction !== undefined || this.rtmInstance.isShowingAction) {
          Logger$6.info("A survey is being shown,can not show another survey");
          return false;
        }
        return true;
      }
    }, {
      key: "_resetRTMAction",
      value: function _resetRTMAction() {
        this.closeCallback();
      }
    }, {
      key: "createSurvey",
      value: function createSurvey() {
        this._setBackgroundOverlay();
        this._setStyles();
        this._setSurveyContent();
      }
    }, {
      key: "_setSurveyDimensions",
      value: function _setSurveyDimensions() {
        var scale = this.width / 100;
        var calculateFromHeight = false;
        if (this.enable_header && this.header.enable_image) {
          this._setDimenstionFromResolution(this.header.image.width, this.header.image.height, scale, calculateFromHeight);
        } else {
          this.width = "".concat(this.width, "%");
        }
      }
    }, {
      key: "_setDimenstionFromResolution",
      value: function _setDimenstionFromResolution(width, height) {
        var scale = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.5;
        var calculateFromHeight = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
        var dimensions = getHeightWidthFromResolution({
          width: width,
          height: height
        }, scale, calculateFromHeight);
        this.media_width = "".concat(dimensions.width, "px");
        this.media_height = "".concat(dimensions.height, "px");
        this.width = "".concat(dimensions.width, "px");
      }
    }, {
      key: "_setBackgroundOverlay",
      value: function _setBackgroundOverlay() {
        this.overlayElement = document.createElement("div");
        this.overlayElement.classList.add("apxor-survey-overlay".concat(this.cssPostFix));
        if (this.enable_dimbackground) {
          this.dimBackgroundElement = document.createElement("div");
          this.dimBackgroundElement.classList.add("apxor-survey-dimbackground-overlay".concat(this.cssPostFix));
          this.overlayElement.appendChild(this.dimBackgroundElement);
        }
        document.body.appendChild(this.overlayElement);
      }
    }, {
      key: "_setStyles",
      value: function _setStyles() {
        var styles = " \n      ".concat(this._setBackgroundOverlaystyles(), "\n      ").concat(this._getSurveyContainerStyles(), "\n      ").concat(this._getHeaderContainerStyles(), "\n      ").concat(this._getHeaderTopContainerStyles(), "\n      ").concat(this._getHeaderTopPaginationContainerStyles(), "\n      ").concat(this._getHeaderImageContainerStyles(), "\n      ").concat(this._getProgressBarStyles(), "\n      ").concat(this._getNumberedStepperStyles(), "\n      ").concat(this._getBackButtonStyles(), "\n      ").concat(this._getQandAcontainerStyles(), "\n      ").concat(this._getSuccessIconStyles(), "\n      ").concat(this._getNpsTopContainerStyles(), "\n      ").concat(this._getRatingBlockStyles(), "\n      ").concat(this.getNpsQandSContainerStyles(), "\n    ").replaceAll("\n", "").replace(/[\s]{2,999}/g, "");
        var styleNode = document.createElement("style");
        styleNode.innerHTML = styles;
        this.overlayElement.appendChild(styleNode);
      }
    }, {
      key: "_setBackgroundOverlaystyles",
      value: function _setBackgroundOverlaystyles() {
        var dimbackgroundStyles = "";
        if (this.enable_dimbackground) {
          dimbackgroundStyles = "\n      background:".concat(this.dimbackground.color, ";\n      opacity:").concat(this.dimbackground.opacity, ";\n      ");
        }
        var backgroundOverlayStyles = "\n    .apxor-survey-overlay".concat(this.cssPostFix, " {\n      width:100%;\n      height:100%;\n    }\n    .apxor-survey-dimbackground-overlay").concat(this.cssPostFix, " {\n      width:100%;\n      height:100%;\n      position:fixed;\n      top:0;\n      left:0;\n      z-index:999;\n      ").concat(dimbackgroundStyles, "\n      overflow: auto;\n    }");
        return backgroundOverlayStyles;
      }
    }, {
      key: "_getSurveyContainerStyles",
      value: function _getSurveyContainerStyles() {
        var surveyPositionOffset = this.enable_border ? this.border.width : 0;
        var topOffset = surveyPositionOffset;
        var leftOffset = surveyPositionOffset;
        var rightOffset = surveyPositionOffset;
        var bottomOffset = surveyPositionOffset;
        if (this.enable_padding) {
          topOffset = topOffset + this.padding.top;
          leftOffset = leftOffset + this.padding.left;
          rightOffset = rightOffset + this.padding.right;
          bottomOffset = bottomOffset + this.padding.bottom;
        }
        if (this.enable_margin) {
          topOffset = topOffset + this.margin.top;
          leftOffset = leftOffset + this.margin.left;
          rightOffset = rightOffset + this.margin.right;
          bottomOffset = bottomOffset + this.margin.bottom;
        }
        var containerPosition = "";
        switch (this.position.position) {
          case "top-left":
            containerPosition = "\n          top:".concat(topOffset, "px;\n          left:").concat(leftOffset, "px;\n        ");
            break;
          case "top-center":
            containerPosition = "\n          left:50%;\n          top:".concat(topOffset, "px;\n          -webkit-transform: translate(-50%, ").concat(topOffset * 0.1, "px);\n          -moz-transform: translate(-50%, ").concat(topOffset, "px);\n        ");
            break;
          case "top-right":
            containerPosition = "\n            top:".concat(topOffset, "px;\n            right:").concat(rightOffset, "px;\n          ");
            break;
          case "bottom-left":
            containerPosition = "\n          bottom:".concat(bottomOffset, "px;\n          left:").concat(leftOffset, "px;\n        ");
            break;
          case "bottom-center":
            containerPosition = "\n          left:50%;\n          bottom:".concat(bottomOffset, "px;\n          -webkit-transform: translate(-50%, ").concat(bottomOffset * 0.1, "px);\n          -moz-transform: translate(-50%, ").concat(bottomOffset, "px);\n        ");
            break;
          case "bottom-right":
            containerPosition = "\n          bottom:".concat(bottomOffset, "px;\n          right:").concat(rightOffset, "px;\n        ");
            break;
          case "left":
            containerPosition = "\n          left:".concat(leftOffset, "px;\n          top:50%;\n          -webkit-transform: translate(").concat(leftOffset * 0.1, "px, -50%);\n          -moz-transform: translate(").concat(leftOffset, "px, -50%);\n        ");
            break;
          case "right":
            containerPosition = "\n            right:".concat(rightOffset, "px;\n            top:50%;\n            -webkit-transform: translate(").concat(rightOffset * 0.1, "px, -50%);\n            -moz-transform: translate(").concat(rightOffset, "px, -50%);\n          ");
            break;
          default:
            containerPosition = "\n          left:50%;\n          top:50%;\n          -webkit-transform: translate(-50%, -50%);\n          -moz-transform: translate(-50%, -50%);\n        ";
            break;
        }
        var containerMargin = "";
        if (this.enable_margin) {
          containerMargin = "\n        margin:".concat(this.margin.top, "px ").concat(this.margin.right, "px ").concat(this.margin.bottom, "px ").concat(this.margin.left, "px;\n      ");
        }
        var containerPadding = "";
        if (this.enable_padding) {
          containerPadding = "\n        padding:".concat(this.padding.top, "px ").concat(this.padding.right, "px ").concat(this.padding.bottom, "px ").concat(this.padding.left, "px;\n      ");
        }
        var containerBorder = "";
        if (this.enable_border) {
          containerBorder = "\n        border-radius: ".concat(this.border.radius, "px;\n        border: ").concat(this.border.width, "px ").concat(this.border.style, " ").concat(this.border.color, ";\n      ");
        }
        var containerStyles = "\n    .apxor-survey-container".concat(this.cssPostFix, "{\n      width:").concat(this.width, ";\n      height:auto;\n      max-height:").concat(this.height, "%;\n      overflow:auto;\n      display:flex;\n      flex-direction:column;\n      background:").concat(this.background_color, ";\n      position:fixed;\n      z-index:999999;\n      transition:all .5s cubic-bezier(.96,.23,.07,.8);\n      ").concat(containerPosition, ";\n      ").concat(containerMargin, ";\n      ").concat(containerPadding, ";\n      ").concat(containerBorder, ";\n    }");
        return containerStyles;
      }
    }, {
      key: "_getHeaderContainerStyles",
      value: function _getHeaderContainerStyles() {
        var headerContainerStyles = "";
        if (this.enable_header) {
          var headerContainerMargin = "";
          if (this.header.enable_margin) {
            headerContainerMargin = "\n        margin:".concat(this.header.margin.top, "px ").concat(this.header.margin.right, "px ").concat(this.header.margin.bottom, "px ").concat(this.header.margin.left, "px;\n      ");
          }
          var headerContainerPadding = "";
          if (this.header.enable_padding) {
            headerContainerPadding = "\n        padding:".concat(this.header.padding.top, "px ").concat(this.header.padding.right, "px ").concat(this.header.padding.bottom, "px ").concat(this.header.padding.left, "px;\n      ");
          }
          var headerContainerBorder = "";
          if (this.header.enable_border) {
            headerContainerBorder = "\n        border-radius: ".concat(this.header.border.radius, "px;\n        border: ").concat(this.header.border.width, "px ").concat(this.header.border.style, " ").concat(this.header.border.color, ";\n      ");
          }
          var headerContainerGradient = "";
          if (this.header.enable_gradient) {
            if (this.header.enable_gradient) {
              headerContainerGradient = "\n          background-image:linear-gradient(".concat(this.header.gradient.direction, ", ").concat(this.header.gradient.colors[0], ", ").concat(this.header.gradient.colors[1], ");\n        ");
            }
          }
          var headerContainerBackgroundImage = "";
          if (this.header.enable_image) {
            var backgroundImage = this.header.image.path;
            if (this.header.image.enable_background_image) {
              headerContainerBackgroundImage = "background-image:url('".concat(backgroundImage, "');background-repeat:no-repeat;width:auto;background-size:cover;height:auto;");
            }
          }
          headerContainerStyles = "\n      .apxor-header-container".concat(this.cssPostFix, "{\n        display:flex;\n        flex-direction: column;\n        background:").concat(this.header.background_color, ";\n        ").concat(headerContainerMargin, ";\n        ").concat(headerContainerPadding, ";\n        ").concat(headerContainerBorder, ";\n        ").concat(headerContainerGradient, ";\n        ").concat(headerContainerBackgroundImage, ";\n      }");
        }
        return headerContainerStyles;
      }
    }, {
      key: "_getHeaderTopContainerStyles",
      value: function _getHeaderTopContainerStyles() {
        var headerTopContainerStyles = "";
        if (this.enable_header) {
          headerTopContainerStyles = "\n      .apxor-survey-header-top-container".concat(this.cssPostFix, "{\n        width:100%;\n        height:auto;\n      }");
        }
        return headerTopContainerStyles;
      }
    }, {
      key: "_getHeaderTopPaginationContainerStyles",
      value: function _getHeaderTopPaginationContainerStyles() {
        var headerTopPaginantionContainerStyles = "";
        if (this.enable_header) {
          var _this$header;
          var positionForPaginationButton = !this.header.enable_title && !this.header.enable_description && this.header.enable_image && !((_this$header = this.header) !== null && _this$header !== void 0 && (_this$header = _this$header.image) !== null && _this$header !== void 0 && _this$header.enable_background_image) ? "position:absolute;" : "position:relative;";
          var paginationMinimumheight = "";
          if (!this.header.enable_stepper) {
            if (this.header.enable_back_button && this.header.enable_close_button) {
              paginationMinimumheight = "\n          min-height:".concat(2 * Math.max(this.header.closebutton.height, this.header.backbutton.height), "px;\n        ");
            } else if (this.header.enable_back_button || this.header.enable_close_button) {
              paginationMinimumheight = "\n          min-height:".concat(2 * (this.header.closebutton.height || this.header.backbutton.height), "px;\n          ");
            }
          }
          headerTopPaginantionContainerStyles = "\n      .apxor-survey-pagination-button".concat(this.cssPostFix, "{\n        ").concat(paginationMinimumheight, "\n        ").concat(positionForPaginationButton, "\n        display:flex;\n        justify-content:center;\n        width:100%;\n        height:auto;\n      }");
        }
        return headerTopPaginantionContainerStyles;
      }
    }, {
      key: "_getHeaderImageContainerStyles",
      value: function _getHeaderImageContainerStyles() {
        var headerImageContainer = "";
        if (this.enable_header && this.header.enable_image) {
          //Image can be used as a background image. Styles are different in that case.
          if (this.header.image.enable_background_image) {
            headerImageContainer = "\n          .apxor-survey-header-image".concat(this.cssPostFix, "{\n            background:url('").concat(this.header.image.path, "') no-repeat 50% 50%;\n            box-shadow: inset ").concat(this.header.image.width, "px ").concat(this.header.image.height, "px 0px 0px ").concat(hexToRGB(this.header.image.background_image.mask_color, this.header.image.background_image.mask_opacity), ",inset -").concat(this.header.image.width, "px -").concat(this.header.image.height, "px 0px 0px ").concat(hexToRGB(this.header.image.background_image.mask_color, this.header.image.background_image.mask_opacity), ";\n        background-size:").concat(this.media_width, " ").concat(this.media_height, ";\n          }\n        ");
          } else {
            headerImageContainer = "\n        .apxor-survey-header-image-div".concat(this.cssPostFix, "{\n          display:flex;\n        }\n        .apxor-survey-header-image").concat(this.cssPostFix, "{\n          height: ").concat(this.media_height, ";\n          width: ").concat(this.media_width, ";\n        }\n      ");
          }
        }
        return headerImageContainer;
      }
    }, {
      key: "_getProgressBarStyles",
      value: function _getProgressBarStyles() {
        var progressBarStyles = "";
        if (this.enable_progressbar) {
          progressBarStyles = "\n      .apxor-survey-progress-bar".concat(this.cssPostFix, "{\n        position:relative;\n        width:100%;\n        height:").concat(this.progressbar.width, "px;\n        ").concat(this.progressbar.position === "top" ? "top:0px;" : "bottom:0px;", "\n        left:0px;\n        z-index:999999;\n        overflow:hidden;\n        cursor: pointer;\n        background:").concat(this.progressbar.remaining_color || "transparent", ";\n      }\n      .apxor-survey-bar").concat(this.cssPostFix, "{\n        width:100%;\n        height:100%;\n        background:").concat(this.progressbar.progress_color, ";\n      }");
        }
        return progressBarStyles;
      }
    }, {
      key: "_getNumberedStepperStyles",
      value: function _getNumberedStepperStyles() {
        var stepperStyle = "";
        var numberedStepperStyles = "";
        if (this.enable_header && this.header.enable_stepper) {
          numberedStepperStyles = "\n        font-family:".concat(this.header.stepper.pagination_text.font.family, ";\n        font-size: ").concat(this.header.stepper.pagination_text.font.size, "px;\n        font-style:").concat(this.header.stepper.pagination_text.font.style, ";\n        font-weight:").concat(this.header.stepper.pagination_text.font.weight, ";\n        color:").concat(this.header.stepper.pagination_text.color, ";\n      ");
          var stepperPaddingStyles = "";
          if (this.header.stepper.pagination_text.enable_padding) {
            stepperPaddingStyles = "\n      padding:".concat(this.header.stepper.pagination_text.padding.top, "px ").concat(this.header.stepper.pagination_text.padding.right, "px ").concat(this.header.stepper.pagination_text.padding.bottom, "px ").concat(this.header.stepper.pagination_text.padding.left, "px");
          }
          stepperStyle = "\n      .stepper-".concat(this.header.stepper.type, "{\n        ").concat(numberedStepperStyles, ";\n        ").concat(stepperPaddingStyles, ";\n      }");
        }
        return stepperStyle;
      }
    }, {
      key: "_getCloseButtonStyles",
      value: function _getCloseButtonStyles(CloseIconConfig) {
        var desc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
        var closeButtonStyles = "";
        var paddingForClosebutton = "";
        if (CloseIconConfig.enable_padding) {
          paddingForClosebutton = "\n        padding:".concat(CloseIconConfig.padding.top, "px ").concat(CloseIconConfig.padding.right, "px ").concat(CloseIconConfig.padding.bottom, "px ").concat(CloseIconConfig.padding.left, "px");
        }
        var marginForClosebutton = "";
        if (CloseIconConfig.enable_margin) {
          marginForClosebutton = "\n        margin:".concat(CloseIconConfig.margin.top, "px ").concat(CloseIconConfig.margin.right, "px ").concat(CloseIconConfig.margin.bottom, "px ").concat(CloseIconConfig.margin.left, "px");
        }
        var borderForClosebutton = "";
        if (CloseIconConfig.enable_border) {
          borderForClosebutton = "\n        border:".concat(CloseIconConfig.border.width, "px ").concat(CloseIconConfig.border.style, " ").concat(CloseIconConfig.border.color, ";\n        border-radius:").concat(CloseIconConfig.border.radius, "px");
        }
        var positionForClosebutton = "";
        if (CloseIconConfig !== null && CloseIconConfig !== void 0 && CloseIconConfig.position) {
          if (CloseIconConfig.position.position === "top-right") {
            positionForClosebutton = "\n          right:0px;\n          -webkit-transform:translate(-".concat(CloseIconConfig.position.offset.skid, "px,").concat(CloseIconConfig.position.offset.distance, "px);\n        ");
          } else {
            positionForClosebutton = "\n          left:0px;\n          -webkit-transform:translate(-".concat(CloseIconConfig.position.offset.skid, "px,").concat(CloseIconConfig.position.offset.distance, "px);\n          ");
          }
        }
        closeButtonStyles = "\n      .apxor-".concat(desc, "close-button").concat(this.cssPostFix, "{\n        position:absolute;\n        display:flex;\n        text-align:center;\n        top:0px;\n        cursor:pointer;\n        ").concat(positionForClosebutton, ";\n        ").concat(paddingForClosebutton, ";\n        ").concat(marginForClosebutton, ";\n        ").concat(borderForClosebutton, ";\n      }").replaceAll("\n", "").replace(/[\s]{2,999}/g, "");
        var styleNode = document.createElement("style");
        styleNode.innerHTML = closeButtonStyles;
        this.overlayElement.appendChild(styleNode);
        return closeButtonStyles;
      }
    }, {
      key: "_getBackButtonStyles",
      value: function _getBackButtonStyles() {
        var backButtonStyles = "";
        if (this.enable_header && this.header.enable_back_button) {
          var _this$header$backbutt;
          var paddingForBackbutton = "";
          if (this.header.backbutton.enable_padding) {
            paddingForBackbutton = "\n        padding:".concat(this.header.backbutton.padding.top, "px ").concat(this.header.backbutton.padding.right, "px ").concat(this.header.backbutton.padding.bottom, "px ").concat(this.header.backbutton.padding.left, "px");
          }
          var marginForBackbutton = "";
          if (this.header.backbutton.enable_margin) {
            marginForBackbutton = "\n        margin:".concat(this.header.backbutton.margin.top, "px ").concat(this.header.backbutton.margin.right, "px ").concat(this.header.backbutton.margin.bottom, "px ").concat(this.header.backbutton.margin.left, "px");
          }
          var borderForBackbutton = "";
          if (this.header.backbutton.enable_border) {
            borderForBackbutton = "\n        border:".concat(this.header.backbutton.border.width, "px ").concat(this.header.backbutton.border.style, " ").concat(this.header.backbutton.border.color, ";\n        border-radius:").concat(this.header.backbutton.border.radius, "px");
          }
          var positionForBackbutton = "";
          if ((_this$header$backbutt = this.header.backbutton) !== null && _this$header$backbutt !== void 0 && _this$header$backbutt.position) {
            if (this.header.backbutton.position.position === "top-left") {
              positionForBackbutton = "\n          left:0px;\n          -webkit-transform:translate(".concat(this.header.backbutton.position.offset.skid, "px,").concat(this.header.backbutton.position.offset.distance, "px)\n        ");
            } else {
              positionForBackbutton = "\n          right:0px;";
            }
          }
          backButtonStyles = "\n      .apxor-back-button".concat(this.cssPostFix, "{\n        position:absolute;\n        display:flex;\n        cursor:pointer;\n        text-align:center;\n        top:0px;\n        ").concat(positionForBackbutton, ";\n        ").concat(paddingForBackbutton, ";\n        ").concat(marginForBackbutton, ";\n        ").concat(borderForBackbutton, ";\n      }");
        }
        return backButtonStyles;
      }
    }, {
      key: "_getQandAcontainerStyles",
      value: function _getQandAcontainerStyles() {
        var marginForQandA = "";
        if (this.survey.enable_margin) {
          marginForQandA = "\n      margin:".concat(this.survey.margin.top, "px ").concat(this.survey.margin.right, "px ").concat(this.survey.margin.bottom, "px ").concat(this.survey.margin.left, "px\n      ");
        }
        var paddingForQandA = "";
        if (this.survey.enable_padding) {
          paddingForQandA = "\n      padding:".concat(this.survey.padding.top, "px ").concat(this.survey.padding.right, "px ").concat(this.survey.padding.bottom, "px ").concat(this.survey.padding.left, "px\n      ");
        }
        var borderForQandA = "";
        if (this.survey.enable_border) {
          borderForQandA = "\n        border-radius: ".concat(this.survey.border.radius, "px;\n        border: ").concat(this.survey.border.width, "px ").concat(this.survey.border.style, " ").concat(this.survey.border.color, ";\n      ");
        }
        var gradientForQandA = "";
        if (this.survey.enable_gradient) {
          gradientForQandA = "\n        background-image:linear-gradient(".concat(this.survey.gradient.direction, ", ").concat(this.survey.gradient.colors[0], ", ").concat(this.survey.gradient.colors[1], ");\n      ");
        }
        var QandAContainerStyles = "\n    .apxor-survey-QandA-container".concat(this.cssPostFix, "{\n      background-color:").concat(this.survey.background_color, ";\n      ").concat(marginForQandA, ";\n      ").concat(paddingForQandA, ";\n      ").concat(borderForQandA, ";\n      ").concat(gradientForQandA, ";\n      overflow:auto;\n    }");
        return QandAContainerStyles;
      }
    }, {
      key: "_getAnswerContainerStyles",
      value: function _getAnswerContainerStyles() {
        var _this$answer;
        var answerContainerStyles = "\n    .apxor-survey-answer-container".concat(this.cssPostFix, "{\n      display:flex;\n      flex-direction:column;\n      background:").concat((_this$answer = this.answer) === null || _this$answer === void 0 ? void 0 : _this$answer.background_color, "\n    }").replaceAll("\n", "").replace(/[\s]{2,999}/g, "");
        var styleNode = document.createElement("style");
        styleNode.innerHTML = answerContainerStyles;
        this.overlayElement.appendChild(styleNode);
      }
    }, {
      key: "_getSuccessIconStyles",
      value: function _getSuccessIconStyles() {
        var successIconStyles = "";
        if (this.enable_success_message && this.success_message.enable_icon) {
          var marginForSuccessIcon = "";
          var successIcon = this.success_message.icon;
          if (successIcon.enable_margin) {
            marginForSuccessIcon = "\n      margin:".concat(successIcon.margin.top, "px ").concat(successIcon.margin.right, "px ").concat(successIcon.margin.bottom, "px ").concat(successIcon.margin.left, "px\n      ");
          }
          var paddingForSuccessIcon = "";
          if (successIcon.enable_padding) {
            paddingForSuccessIcon = "\n      padding:".concat(successIcon.padding.top, "px ").concat(successIcon.padding.right, "px ").concat(successIcon.padding.bottom, "px ").concat(successIcon.padding.left, "px\n      ");
          }
          var borderForSuccessIcon = "";
          if (successIcon.enable_border) {
            borderForSuccessIcon = "\n        border-radius: ".concat(successIcon.border.radius, "px;\n        border: ").concat(successIcon.border.width, "px ").concat(successIcon.border.style, " ").concat(successIcon.border.color, ";\n      ");
          }
          successIconStyles = "\n      .apxor-success-icon-container".concat(this.cssPostFix, "{\n        text-align:center;\n      }\n      .apxor-success-icon-content").concat(this.cssPostFix, "{\n        height:").concat(successIcon.height, "px;\n        width:").concat(successIcon.width, "px;\n        ").concat(marginForSuccessIcon, ";\n        ").concat(paddingForSuccessIcon, ";\n        ").concat(borderForSuccessIcon, ";\n      }");
        }
        return successIconStyles;
      }
    }, {
      key: "_setBottomButtonStyles",
      value: function _setBottomButtonStyles() {
        var marginForbutton = "";
        if (this.footer.enable_margin) {
          marginForbutton = "\n      margin:".concat(this.footer.margin.top, "px ").concat(this.footer.margin.right, "px ").concat(this.footer.margin.bottom, "px ").concat(this.footer.margin.left, "px\n      ");
        }
        var paddingForbutton = "";
        if (this.footer.enable_padding) {
          paddingForbutton = "\n      padding:".concat(this.footer.padding.top, "px ").concat(this.footer.padding.right, "px ").concat(this.footer.padding.bottom, "px ").concat(this.footer.padding.left, "px\n      ");
        }
        var borderForButton = "";
        if (this.footer.enable_border) {
          borderForButton = "\n        border-radius: ".concat(this.footer.border.radius, "px;\n        border: ").concat(this.footer.border.width, "px ").concat(this.footer.border.style, " ").concat(this.footer.border.color, ";\n      ");
        }
        var gradientForButton = "";
        if (this.footer.enable_gradient) {
          gradientForButton = "\n        background-image:linear-gradient(".concat(this.footer.gradient.direction, ", ").concat(this.footer.gradient.colors[0], ", ").concat(this.footer.gradient.colors[1], ");\n      ");
        }
        var buttonStyles = "\n    .apxor-survey-button-container".concat(this.cssPostFix, "{\n      display:flex;\n      justify-content:center;\n      background:").concat(this.footer.background_color, ";\n      ").concat(marginForbutton, ";\n      ").concat(paddingForbutton, ";\n      ").concat(borderForButton, ";\n      ").concat(gradientForButton, ";\n    }\n    ").replaceAll("\n", "").replace(/[\s]{2,999}/g, "");
        var styleNode = document.createElement("style");
        styleNode.innerHTML = buttonStyles;
        this.overlayElement.appendChild(styleNode);
      }
    }, {
      key: "_getQuestionContainerStyles",
      value: function _getQuestionContainerStyles(questionConfig) {
        var marginForQuestionContainer = "";
        if (questionConfig.enable_margin) {
          marginForQuestionContainer = "\n      margin:".concat(questionConfig.margin.top, "px ").concat(questionConfig.margin.right, "px ").concat(questionConfig.margin.bottom, "px ").concat(questionConfig.margin.left, "px\n      ");
        }
        var paddingForQuestionContainer = "";
        if (questionConfig.enable_padding) {
          paddingForQuestionContainer = "\n      padding:".concat(questionConfig.padding.top, "px ").concat(questionConfig.padding.right, "px ").concat(questionConfig.padding.bottom, "px ").concat(questionConfig.padding.left, "px\n      ");
        }
        var questionContainerStyles = "\n    .apxor-survey-question-container-".concat(questionConfig.id).concat(this.cssPostFix, "{\n      background:").concat(questionConfig.background_color, ";\n      ").concat(marginForQuestionContainer, ";\n      ").concat(paddingForQuestionContainer, ";\n    }").replaceAll("\n", "").replace(/[\s]{2,999}/g, "");
        var styleNode = document.createElement("style");
        styleNode.innerHTML = questionContainerStyles;
        this.overlayElement.appendChild(styleNode);
      }
    }, {
      key: "_getTitleStyles",
      value: function _getTitleStyles(titleConfig, about) {
        var marginForTitle = "";
        if (titleConfig.enable_margin) {
          marginForTitle = "\n      margin:".concat(titleConfig.margin.top, "px ").concat(titleConfig.margin.right, "px ").concat(titleConfig.margin.bottom, "px ").concat(titleConfig.margin.left, "px\n      ");
        }
        var paddingForTitle = "";
        if (titleConfig.enable_padding) {
          paddingForTitle = "\n      padding:".concat(titleConfig.padding.top, "px ").concat(titleConfig.padding.right, "px ").concat(titleConfig.padding.bottom, "px ").concat(titleConfig.padding.left, "px\n      ");
        }
        var titleStyles = "\n    .apxor-survey-".concat(about, "-div").concat(this.cssPostFix, "{\n      text-align:").concat(titleConfig.alignment, ";\n      background-color:").concat(titleConfig.background_color, ";\n      ").concat(marginForTitle, ";\n      ").concat(paddingForTitle, ";\n    }").replaceAll("\n", "").replace(/[\s]{2,999}/g, "");
        var styleNode = document.createElement("style");
        styleNode.innerHTML = titleStyles;
        this.overlayElement.appendChild(styleNode);
      }
    }, {
      key: "_getDescriptionStyles",
      value: function _getDescriptionStyles(descriptionConfig, about) {
        var marginForDescription = "";
        if (descriptionConfig.enable_margin) {
          marginForDescription = "\n      margin:".concat(descriptionConfig.margin.top, "px ").concat(descriptionConfig.margin.right, "px ").concat(descriptionConfig.margin.bottom, "px ").concat(descriptionConfig.margin.left, "px\n      ");
        }
        var paddingForDescription = "";
        if (descriptionConfig.enable_padding) {
          paddingForDescription = "\n      padding:".concat(descriptionConfig.padding.top, "px ").concat(descriptionConfig.padding.right, "px ").concat(descriptionConfig.padding.bottom, "px ").concat(descriptionConfig.padding.left, "px\n      ");
        }
        var descriptionstyles = "\n    .apxor-survey-".concat(about, "-div").concat(this.cssPostFix, "{\n      text-align:").concat(descriptionConfig.alignment, ";\n      background-color:").concat(descriptionConfig.background_color, ";\n      ").concat(marginForDescription, ";\n      ").concat(paddingForDescription, ";\n    }").replaceAll("\n", "").replace(/[\s]{2,999}/g, "");
        var styleNode = document.createElement("style");
        styleNode.innerHTML = descriptionstyles;
        this.overlayElement.appendChild(styleNode);
        return descriptionstyles;
      }
    }, {
      key: "_getChoiceStyles",
      value: function _getChoiceStyles(answerConfig, choiceConfig, type) {
        var marginForChoiceContainer = "";
        if (answerConfig.enable_margin) {
          marginForChoiceContainer = "\n      margin:".concat(answerConfig.margin.top, "px ").concat(answerConfig.margin.right, "px ").concat(answerConfig.margin.bottom, "px ").concat(answerConfig.margin.left, "px\n      ");
        }
        var paddingForChoiceContainer = "";
        if (answerConfig.enable_padding) {
          paddingForChoiceContainer = "\n      padding:".concat(answerConfig.padding.top, "px ").concat(answerConfig.padding.right, "px ").concat(answerConfig.padding.bottom, "px ").concat(answerConfig.padding.left + 40, "px\n      ");
        }
        var borderForChoices = "";
        if (choiceConfig.enable_border) {
          borderForChoices = "\n      border-radius:".concat(choiceConfig.border.radius, "px;\n      border:").concat(choiceConfig.border.width, "px ").concat(choiceConfig.border.style, " ").concat(choiceConfig.border.inactive_color);
        }
        var fontStylesForChoices = "\n      font-size:".concat(answerConfig.font.size, "px;\n      font-family:").concat(answerConfig.font.family, ";\n      font-style:").concat(answerConfig.font.style, ";\n      font-weight:").concat(answerConfig.font.weight, ";\n    ");
        choiceConfig.color_active;
          var color_inactive = choiceConfig.color_inactive,
          radio_color_active = choiceConfig.radio_color_active,
          radio_color_inactive = choiceConfig.radio_color_inactive;
          choiceConfig.bg_color_active;
          var bg_color_inactive = choiceConfig.bg_color_inactive;
        var choiceStyles = "\n    .apx-lc".concat(this.cssPostFix, " {\n      display: flex;\n      align-items:center;\n      position: relative;\n      background: ").concat(bg_color_inactive, ";\n      cursor: pointer;\n      color: ").concat(color_inactive, ";\n      ").concat(fontStylesForChoices, ";\n      ").concat(borderForChoices, ";\n      ").concat(marginForChoiceContainer, ";\n      ").concat(paddingForChoiceContainer, ";\n      -webkit-user-select: none;\n      -moz-user-select: none;\n      -ms-user-select: none;\n      user-select: none;\n    }\n  \n    .apx-lc").concat(this.cssPostFix, " input {\n      position: absolute;\n      opacity: 0;\n      cursor: pointer;\n      width: 0;\n      height: 0;\n    }\n  \n    .apx-i").concat(this.cssPostFix, " {\n      position: absolute;\n      left: 12px;\n      height: 16px;\n      width: 16px;\n      display:flex;\n      justify-content:center;\n      align-items:center;\n      border: 1px solid ").concat(radio_color_inactive, ";\n      background-color: white;\n      border-radius:").concat(type === "single_choice" ? "50%" : 0, ";\n    }\n  \n    .apx-lc").concat(this.cssPostFix, ":hover input ~ .apx-i").concat(this.cssPostFix, " {\n      border: 1px solid ").concat(radio_color_active, ";\n    }\n\n    .apx-lc").concat(this.cssPostFix, " input:checked ~ .apx-i").concat(this.cssPostFix, " {\n      background: ").concat(type !== "single_choice" ? radio_color_active : "", ";\n      border: 1px solid ").concat(radio_color_active, ";\n    }\n  \n    .apx-i").concat(this.cssPostFix, ":after {\n      content: \"\";\n      position: absolute;\n      display: none;\n    }\n  \n    .apx-lc").concat(this.cssPostFix, " input:checked ~ .apx-i").concat(this.cssPostFix, ":after {\n      display: block;\n    }\n\n    .apx-lc").concat(this.cssPostFix, " .apx-i").concat(this.cssPostFix, ":after {\n      width: ").concat(type === "single_choice" ? 10 : 5, "px;\n      height: ").concat(type === "single_choice" ? 10 : 10, "px;\n      border-radius: ").concat(type === "single_choice" ? "50%" : "0", ";\n      background: ").concat(type === "single_choice" ? radio_color_active : "transparent", ";\n      border: ").concat(type === "single_choice" ? "none" : "solid white", ";\n      border-width: ").concat(type === "single_choice" ? "unset" : "0 3px 3px 0", ";\n      -webkit-transform: ").concat(type === "single_choice" ? "unset" : "rotate(45deg)", ";\n      -ms-transform: ").concat(type === "single_choice" ? "unset" : "rotate(45deg)", ";\n      transform: ").concat(type === "single_choice" ? "unset" : "rotate(45deg)", ";\n    }\n    ").replaceAll("\n", "").replace(/[\s]{2,999}/g, "");
        var styleNode = document.createElement("style");
        styleNode.innerHTML = choiceStyles;
        this.overlayElement.appendChild(styleNode);
      }
    }, {
      key: "_getScrollStyles",
      value: function _getScrollStyles(scrollConfig, about) {
        var scrollborderStyles = "";
        if (scrollConfig.enable_border) {
          scrollborderStyles = "\n        border-top: ".concat(scrollConfig.border.width, "px ").concat(scrollConfig.border.style, " ").concat(scrollConfig.border.color, ";\n        border-bottom : ").concat(scrollConfig.border.width, "px ").concat(scrollConfig.border.style, " ").concat(scrollConfig.border.color, ";\n      ");
        }
        var scrollStyles = "\n      .apxor-survey-".concat(about, "-scroll").concat(this.cssPostFix, " {\n        overflow:scroll; \n        overflow-x: hidden;\n        height:").concat(scrollConfig.height, "px;\n        ").concat(scrollborderStyles, ";\n      }").replaceAll("\n", "").replace(/[\s]{2,999}/g, "");
        var styleNode = document.createElement("style");
        styleNode.innerHTML = scrollStyles;
        this.overlayElement.appendChild(styleNode);
        return scrollStyles;
      }
    }, {
      key: "_getBottomButtonsStyles",
      value: function _getBottomButtonsStyles() {
        var visibilityOfPrevButton = "";
        if (this.index === 0) {
          visibilityOfPrevButton = "\n      visibility:hidden;\n      ";
        }
        var bottomButtonStyling = "\n    #apxor-survey_bottom-prev-button{\n      ".concat(visibilityOfPrevButton, "\n    }\n    #apxor-survey_bottom-next-button{\n      pointer-events:none;\n      opacity:0.5;\n    }\n    #apxor-survey_bottom-submit-button{\n      pointer-events:none;\n      opacity:0.5;\n    }\n    ");
        return bottomButtonStyling;
      }
    }, {
      key: "_setSurveyContent",
      value: function _setSurveyContent() {
        this._createSurveyContainer();
        if (this.enable_survey_request) {
          this._setSurveyRequestStyles();
          this._createSurveyRequestContent();
        } else {
          this._createProgressBar();
          this._createHeaderContainer();
          this._createQuestionAndAnswerContainer();
          this._createQuestionContainer();
          this._createAnswerContainer();
          this._createButtonContainer();
          if (!this.surveylaunched) {
            this._logSurveyAppEvent("apx_survey_launched", {
              apx_survey_id: this.configId,
              apx_survey_name: this.name,
              apx_survey_type: true
            });
          }
          this._logSurveyAppEvent("apx_survey_question_asked", {
            apx_question_id: this.QandAArray[this.index].question.id,
            apx_question_name: "",
            apx_question_type: this.QandAArray[this.index].answer.answer_mode,
            apx_question_position: this.index + 1,
            apx_survey_id: this.configId,
            apx_survey_name: this.name,
            apx_survey_type: true
          });
        }
      }
    }, {
      key: "_createSurveyContainer",
      value: function _createSurveyContainer() {
        this.surveyContainer = document.createElement("div");
        this.surveyContainer.classList.add("apxor-survey-container".concat(this.cssPostFix));
        this.overlayElement.appendChild(this.surveyContainer);
      }
    }, {
      key: "_setSurveyRequestStyles",
      value: function _setSurveyRequestStyles() {
        var styles = " \n    ".concat(this._getSurveyRequestContainerStyles(), "\n    ").concat(this._getSurveyRequestIconStyles(), "  \n    ").concat(this._getSurveyRequestButtonsStyles(), "\n    ").replaceAll("\n", "").replace(/[\s]{2,999}/g, "");
        var styleNode = document.createElement("style");
        styleNode.innerHTML = styles;
        this.overlayElement.appendChild(styleNode);
      }
    }, {
      key: "_getSurveyRequestContainerStyles",
      value: function _getSurveyRequestContainerStyles() {
        var surveyRequestContainerStyles = "\n    .apxor-survey-request-styles".concat(this.cssPostFix, "{\n      display:flex;\n      flex-direction:column;\n      align-items:center;\n    }");
        return surveyRequestContainerStyles;
      }
    }, {
      key: "_getSurveyRequestIconStyles",
      value: function _getSurveyRequestIconStyles() {
        var iconStyles = "";
        if (this.surveyrequest.enable_icon) {
          var iconBorderStyles = "";
          if (this.surveyrequest.icon.enable_border) {
            iconBorderStyles = "\n            border-radius:".concat(this.surveyrequest.icon.border.radius, "%;\n            border:").concat(this.surveyrequest.icon.border.width, "px ").concat(this.surveyrequest.icon.border.style, " ").concat(this.surveyrequest.icon.border.color, ";\n        ");
          }
          var iconMarginStyles = "";
          if (this.surveyrequest.icon.enable_margin) {
            iconMarginStyles = "\n          margin-top:".concat(this.surveyrequest.icon.margin.top, "px;\n          margin-bottom:").concat(this.surveyrequest.icon.margin.bottom, "px;\n          margin-left:").concat(this.surveyrequest.icon.margin.left, "px;\n          margin-right:").concat(this.surveyrequest.icon.margin.right, "px;\n        ");
          }
          var iconPaddingStyles = "";
          if (this.surveyrequest.icon.enable_padding) {
            iconPaddingStyles = "\n          padding-top:".concat(this.surveyrequest.icon.padding.top, "px;\n          padding-bottom:").concat(this.surveyrequest.icon.padding.bottom, "px;\n          padding-left:").concat(this.surveyrequest.icon.padding.left, "px;\n          padding-right:").concat(this.surveyrequest.icon.padding.right, "px;\n        ");
          }
          iconStyles = "\n        .apxor-survey-request-icon-container".concat(this.cssPostFix, "} {\n          text-align:").concat(this.surveyrequest.icon.alignment, ";\n        }\n        .apxor-survey-request-icon-content").concat(this.cssPostFix, " {\n          height: ").concat(this.surveyrequest.icon.height, "px;\n          width: ").concat(this.surveyrequest.icon.width, "px;\n          ").concat(iconBorderStyles, "\n          ").concat(iconMarginStyles, "\n          ").concat(iconPaddingStyles, "\n        }\n      ");
        }
        return iconStyles;
      }
    }, {
      key: "_getSurveyRequestButtonsStyles",
      value: function _getSurveyRequestButtonsStyles() {
        var surveyRequestButtonsStyling = "\n    .apxor-survey-request-buttons".concat(this.cssPostFix, "{\n      display:flex;\n      flex-direction:column;\n      align-items:center;\n    }");
        return surveyRequestButtonsStyling;
      }
    }, {
      key: "_createSurveyRequestContent",
      value: function _createSurveyRequestContent() {
        this._createSurveyRequestContainer();
        this._setSurveyRequestContent();
      }
    }, {
      key: "_createSurveyRequestContainer",
      value: function _createSurveyRequestContainer() {
        this.surveyRequestContainer = document.createElement("div");
        this.surveyRequestContainer.classList.add("apxor-survey-request-styles".concat(this.cssPostFix));
        this.surveyContainer.appendChild(this.surveyRequestContainer);
      }
    }, {
      key: "_setSurveyRequestContent",
      value: function _setSurveyRequestContent() {
        var _this$surveyrequest, _this$is_response_bas, _this$survey3;
        if (this.surveyrequest.enable_close_button) {
          this._getCloseButtonStyles(this.surveyrequest.closebutton, "dialog");
          this.surveyRequestContainer.appendChild(this._setCloseButton(this.surveyrequest.closebutton, "dialog"));
        }
        if (this.surveyrequest.enable_icon) {
          var iconDiv = document.createElement("div");
          iconDiv.classList.add("apxor-survey-request-icon-container".concat(this.cssPostFix));
          var iconElement = document.createElement("img");
          iconElement.src = this.surveyrequest.icon.path;
          iconElement.classList.add("apxor-survey-request-icon-content".concat(this.cssPostFix));
          iconDiv.appendChild(iconElement);
          this.surveyRequestContainer.appendChild(iconDiv);
        }
        if (this.surveyrequest.enable_title) {
          this._getTitleStyles(this.surveyrequest.title, "survey-request-title");
          this.surveyRequestContainer.appendChild(this._setTitleContent(this.surveyrequest.title, "survey-request-title", ""));
        }
        if (this.surveyrequest.enable_description) {
          this._getDescriptionStyles(this.surveyrequest.description, "survey-request-description");
          this.surveyRequestContainer.appendChild(this._setDescriptionContent(this.surveyrequest.description, "survey-request-description", ""));
        }
        if ((_this$surveyrequest = this.surveyrequest) !== null && _this$surveyrequest !== void 0 && _this$surveyrequest.buttons && this.surveyrequest.buttons.length !== 0) {
          this.surveyRequestButtons = document.createElement("div");
          this.surveyRequestButtons.classList.add("apxor-survey-request-buttons".concat(this.cssPostFix));
          this.surveyRequestButtons.appendChild(this._setButtons(this.surveyrequest.buttons));
          this.surveyRequestContainer.appendChild(this.surveyRequestButtons);
        }
        this._logSurveyAppEvent("apx_survey_dialog_launched", {
          apx_survey_id: this.configId,
          apx_survey_name: this.name,
          apx_survey_type: ((_this$is_response_bas = this === null || this === void 0 ? void 0 : this.is_response_based_survey) !== null && _this$is_response_bas !== void 0 ? _this$is_response_bas : this === null || this === void 0 || (_this$survey3 = this.survey) === null || _this$survey3 === void 0 ? void 0 : _this$survey3.is_response_based_survey) ? "response_based" : "default"
        });
      }
    }, {
      key: "_createProgressBar",
      value: function _createProgressBar() {
        if (this.enable_progressbar) {
          this.surveyContainer.appendChild(this._setProgressBar());
        }
      }
    }, {
      key: "_createHeaderContainer",
      value: function _createHeaderContainer() {
        if (this.enable_header) {
          var headerContainer = document.createElement("div");
          headerContainer.classList.add("apxor-header-container".concat(this.cssPostFix));
          headerContainer.appendChild(this.createTopContainer());
          if (this.header.enable_title) {
            this._getTitleStyles(this.header.title, "header-title");
            headerContainer.appendChild(this._setTitleContent(this.header.title, "header-title", this.index));
          }
          if (this.header.enable_description) {
            this._getDescriptionStyles(this.header.description, "header-description");
            headerContainer.appendChild(this._setDescriptionContent(this.header.description, "header-description", this.index));
          }
          if (this.header.enable_image) {
            if (this.header.image.enable_background_image) {
              headerContainer.classList.add("apxor-survey-header-image".concat(this.cssPostFix));
            } else {
              var imgDiv = document.createElement("div");
              imgDiv.classList.add("apxor-survey-header-image-div".concat(this.cssPostFix));
              var imgElement = document.createElement("img");
              imgElement.src = this.header.image.path;
              imgElement.classList.add("apxor-survey-header-image".concat(this.cssPostFix));
              imgDiv.appendChild(imgElement);
              headerContainer.appendChild(imgDiv);
            }
          }
          this.surveyContainer.appendChild(headerContainer);
        }
      }
    }, {
      key: "createTopContainer",
      value: function createTopContainer() {
        var topHeaderContainer = document.createElement("div");
        topHeaderContainer.classList.add("apxor-survey-header-top-container".concat(this.cssPostFix));
        var topPaginationAndButtonContainer = document.createElement("div");
        topPaginationAndButtonContainer.classList.add("apxor-survey-pagination-button".concat(this.cssPostFix));
        if (this.enable_header && this.header.enable_stepper) {
          this.header.stepper.index = this.index + 1;
          this.header.stepper.length = this.QandAArray.length;
          var carousel = document.createElement("div");
          carousel.className = "stepper" + "-" + this.header.stepper.type;
          carousel.innerHTML = setCarousel(this.header.stepper.type, this.header.stepper);
          topPaginationAndButtonContainer.appendChild(carousel);
        }
        if (this.header.enable_close_button) {
          this._getCloseButtonStyles(this.header.closebutton);
          var close = this._setCloseButton(this.header.closebutton);
          topPaginationAndButtonContainer.appendChild(close);
        }
        if (this.header.enable_back_button && this.index !== 0) {
          var back_button = this._setBackButton();
          topPaginationAndButtonContainer.appendChild(back_button);
        }
        topHeaderContainer.appendChild(topPaginationAndButtonContainer);
        return topHeaderContainer;
      }
    }, {
      key: "_createQuestionAndAnswerContainer",
      value: function _createQuestionAndAnswerContainer() {
        if (this.index < this.QandAArray.length && this.index >= 0) {
          this.QandAContainer = document.createElement("div");
          this.QandAContainer.classList.add("apxor-survey-QandA-container".concat(this.cssPostFix));
          this.surveyContainer.appendChild(this.QandAContainer);
        }
      }
    }, {
      key: "_createQuestionContainer",
      value: function _createQuestionContainer() {
        this.question = this.QandAArray[this.index].question;
        this.questionContainer = document.createElement("div");
        this._getQuestionContainerStyles(this.question);
        this.questionContainer.classList.add("apxor-survey-question-container-".concat(this.question.id).concat(this.cssPostFix));
        if (this.question.enable_title) {
          this._getTitleStyles(this.question.title, "question-title");
          this.questionContainer.appendChild(this._setTitleContent(this.question.title, "question-title", this.question.id));
        }
        if (this.question.enable_description) {
          this._getDescriptionStyles(this.question.description, "question-description");
          this.questionContainer.appendChild(this._setDescriptionContent(this.question.description, "question-description", this.question.id));
        }
        this.QandAContainer.appendChild(this.questionContainer);
      }
    }, {
      key: "_createAnswerContainer",
      value: function _createAnswerContainer() {
        var _this$QandAArray$this,
          _this$QandAArray$this2,
          _this2 = this;
        this.answer_mode = (_this$QandAArray$this = this.QandAArray[this.index]) === null || _this$QandAArray$this === void 0 ? void 0 : _this$QandAArray$this.answer.answer_mode;
        this.answer = (_this$QandAArray$this2 = this.QandAArray[this.index]) === null || _this$QandAArray$this2 === void 0 ? void 0 : _this$QandAArray$this2.answer;
        this.footer = this.QandAArray[this.index].footer;
        this.anyActiveChoices = false;
        this.answerContainer = document.createElement("div");
        this._getAnswerContainerStyles();
        this.answerContainer.classList.add("apxor-survey-answer-container".concat(this.cssPostFix));
        var otherChoiceFound = false;
        if (this.answer_mode === "single_choice" || this.answer_mode === "multi_choice") {
          var _this$QandAArray$this3;
          this.choices = (_this$QandAArray$this3 = this.QandAArray[this.index]) === null || _this$QandAArray$this3 === void 0 || (_this$QandAArray$this3 = _this$QandAArray$this3.answer) === null || _this$QandAArray$this3 === void 0 ? void 0 : _this$QandAArray$this3.choices;
          var otherInputFeild = "";
          var _this$choices = this.choices;
            _this$choices.randomize_choices;
            var color_active = _this$choices.color_active,
            color_inactive = _this$choices.color_inactive;
            _this$choices.radio_color_active;
            _this$choices.radio_color_inactive;
            var bg_color_active = _this$choices.bg_color_active,
            bg_color_inactive = _this$choices.bg_color_inactive,
            _this$choices$choice_ = _this$choices.choice_border_active,
            choice_border_active = _this$choices$choice_ === void 0 ? "" : _this$choices$choice_,
            _this$choices$choice_2 = _this$choices.choice_border_inactive,
            choice_border_inactive = _this$choices$choice_2 === void 0 ? "" : _this$choices$choice_2,
            list = _this$choices.list;
          this._getChoiceStyles(this.answer, this.choices, this.answer_mode);
          var setOptionColor = function setOptionColor(node, checked) {
            node.style.color = checked ? color_active : color_inactive;
          };
          var setOptionBackgroundColor = function setOptionBackgroundColor(node, checked) {
            var color = checked ? bg_color_active : bg_color_inactive;
            node.style.background = color;
          };
          var setOutLineColor = function setOutLineColor(node, checked) {
            if (_this2.choices.enable_border) {
              node.style.border = checked ? "".concat(_this2.choices.border.width, "px ").concat(_this2.choices.border.style, " ").concat(choice_border_active || _this2.choices.border.color) : "".concat(_this2.choices.border.width, "px ").concat(_this2.choices.border.style, " ").concat(choice_border_inactive || _this2.choices.border.inactive_color);
            }
          };
          list.forEach(function (choice, index) {
            var choiceNode = document.createElement("label");
            choiceNode.className = "apx-lc".concat(_this2.cssPostFix);
            choiceNode.innerText = choice.value;
            var input = document.createElement("input");
            input.name = input.type = _this2.answer_mode === "single_choice" ? "radio" : "checkbox";
            input.checked = choice.is_selected;
            var span = document.createElement("span");
            span.className = "apx-i".concat(_this2.cssPostFix);
            choiceNode.appendChild(input);
            choiceNode.appendChild(span);
            _this2.anyActiveChoices = _this2.anyActiveChoices || choice.is_selected;
            // If the choice is already selected, apply the CSS styles properly
            setOptionBackgroundColor(choiceNode, choice.is_selected);
            setOptionColor(choiceNode, choice.is_selected);
            setOutLineColor(choiceNode, choice.is_selected);
            if (choice.is_other) {
              _this2.getTextAreaNodeStyles(_this2.answer, "other");
              otherInputFeild = _this2.getTextAreaNode(_this2.answer.input_text, choice.other_answer, "other");
              otherChoiceFound = true;
              // Listen on user input and update the answer directly in `choice` instance
              otherInputFeild.style.visibility = "hidden";
              otherInputFeild.addEventListener("input", function (e) {
                choice.other_answer = e.target.value;
              });
            }
            if (choice.is_selected && choice.is_other) {
              otherInputFeild.style.visibility = "visible";
            }
            if (_this2.answer_mode === "multi_choice") {
              // Listen on the change event for this choice
              // and based on the actions, update the CSS rules
              input.setAttribute("apx-key", "checked");
              input.setAttribute("apx-ci", index + "");
              input.onchange = function () {
                var anyChoiceSelectedFlag = false;
                document.querySelectorAll('input[apx-key="checked"]').forEach(function (node, i) {
                  var checked = node.checked;
                  list[i].is_selected = checked;
                  if (checked) {
                    anyChoiceSelectedFlag = true;
                  }
                  setOptionColor(node.parentNode, checked);
                  setOptionBackgroundColor(node.parentNode, checked);
                  setOutLineColor(node.parentNode, checked);
                  if (list[i].is_other) {
                    otherInputFeild.style.visibility = checked ? "visible" : "hidden";
                  }
                });
                _this2.changeButtonColor(anyChoiceSelectedFlag);
              };
            } else {
              input.setAttribute("apx-key", "radio");
              input.setAttribute("apx-ci", index + "");
              input.onchange = function () {
                // Whenever the radio button is selected, browser takes care of
                // de-selecting the other radio buttons. But, we have to take care
                // of business logic of updating the `choice` state properly
                var anyChoiceSelectedFlag = false;
                document.querySelectorAll('input[apx-key="radio"]').forEach(function (node, i) {
                  var checked = node.checked;
                  list[i].is_selected = checked;
                  if (checked) {
                    anyChoiceSelectedFlag = true;
                  }
                  setOptionColor(node.parentNode, checked);
                  setOptionBackgroundColor(node.parentNode, checked);
                  setOutLineColor(node.parentNode, checked);
                  if (list[i].is_other) {
                    otherInputFeild.style.visibility = checked ? "visible" : "hidden";
                  }
                });
                _this2.changeButtonColor(anyChoiceSelectedFlag);
              };
            }
            _this2.answerContainer.appendChild(choiceNode);
            if (otherChoiceFound) {
              _this2.answerContainer.appendChild(otherInputFeild);
            }
          });
          if (this.answer.enable_scroll) {
            var about = "choices";
            this._getScrollStyles(this.answer.scroll, about);
            this.answerContainer.classList.add("apxor-survey-".concat(about, "-scroll").concat(this.cssPostFix));
          }
          this.QandAContainer.appendChild(this.answerContainer);
        } else if (this.answer_mode === "text") {
          this.getTextAreaNodeStyles(this.answer, "text");
          var textAreaNode = this.getTextAreaNode(this.answer.input_text, this.answer.text_answer, "text");
          if (this.answer.text_answer !== "") {
            this.anyActiveChoices = true;
          }
          textAreaNode.addEventListener("input", function (e) {
            _this2.answer.text_answer = e.target.value;
            if (e.target.value && e.target.value.length > 0) {
              _this2.answer.is_answered = true;
              _this2.anyActiveChoices = true;
            } else {
              _this2.anyActiveChoices = false;
            }
            _this2.changeButtonColor(_this2.anyActiveChoices);
          });
          this.answerContainer.appendChild(textAreaNode);
          this.QandAContainer.appendChild(this.answerContainer);
        } else if (this.answer_mode === "rating") {
          var _this$QandAArray$this4, _this$rating, _this$rating2, _this$rating3;
          this.rating = (_this$QandAArray$this4 = this.QandAArray[this.index]) === null || _this$QandAArray$this4 === void 0 || (_this$QandAArray$this4 = _this$QandAArray$this4.answer) === null || _this$QandAArray$this4 === void 0 ? void 0 : _this$QandAArray$this4.rating;
          this.reactions = (_this$rating = this.rating) === null || _this$rating === void 0 ? void 0 : _this$rating.reactions;
          this.ratingButtons = this.rating.ratingbuttons;
          this.QandSArray = (_this$rating2 = this.rating) === null || _this$rating2 === void 0 ? void 0 : _this$rating2.QandSArray;
          this.ratingLabels = (_this$rating3 = this.rating) === null || _this$rating3 === void 0 ? void 0 : _this$rating3.ratingLabels;
          this.npsContainer = document.createElement("div");
          this._getNpscontainerStyles(this.QandAArray[this.index].answer);
          this.npsContainer.classList.add("apxor-survey-nps-container".concat(this.cssPostFix));

          //Nps-TopContainer contains message,image.
          this._getNpsTopContainerElementStyles();
          this.npsTopContainer = document.createElement("div");
          this.npsTopContainer.classList.add("apxor-survey-nps-topcontainer".concat(this.cssPostFix));
          this.npsContainer.appendChild(this.npsTopContainer);
          var ratingDiv = document.createElement("div");
          ratingDiv.classList.add("apxor-survey-ratingdiv".concat(this.cssPostFix));
          if (this.ratingButtons.type !== "slider") {
            var topRatingDiv = document.createElement("div");
            topRatingDiv.classList.add("apxor-survey-topratingdiv".concat(this.cssPostFix));
            var bottomRatingDiv = document.createElement("div");
            bottomRatingDiv.classList.add("apxor-survey-bottomratingdiv".concat(this.cssPostFix));
            if (this.ratingButtons.type === "numbered") {
              this._getRatingNumberButtonStyles(this.ratingButtons);
            } else if (this.ratingButtons.type === "radio") {
              this._getRatingRadioButtonStyles(this.ratingButtons);
            } else if (this.ratingButtons.type === "star") {
              this.getStarButtonStyling(this.ratingButtons);
            } else if (this.ratingButtons.type === "emoji") {
              this.getEmojiButtonStyling(this.ratingButtons);
            }
            if (this.rating.enable_labels) {
              this.getRatingLabelsStyling(this.ratingButtons, this.ratingLabels);
            }
            var count = 0; // to split the button.
            this.ratingButtons.buttons.forEach(function (ratingitem, ind) {
              count++;
              _this2.anyActiveChoices = _this2.anyActiveChoices || _this2.ratingButtons.selected_rating[ind] !== -1;
              var buttonDiv = document.createElement("div");
              buttonDiv.setAttribute("apx-survey-key", "rating");
              if (_this2.ratingButtons.type === "radio") {
                _this2.radioButtonContainer = document.createElement("div");
                _this2.radioButtonContainer.classList.add("apxor-survey-radio-button-container-".concat(ind, "-styling").concat(_this2.cssPostFix));
                _this2.radioButtonContainer.appendChild(buttonDiv);
              }
              if (_this2.ratingButtons.type === "numbered") {
                buttonDiv.classList.add("apxor-survey-buttondiv-".concat(ind, "-").concat(_this2.cssPostFix));
                buttonDiv.innerText = ratingitem.value;
              } else if (_this2.ratingButtons.type === "radio") {
                buttonDiv.classList.add("apxor-survey-radiobutton-".concat(ind, "-").concat(_this2.cssPostFix));
                _this2.radioInnerDiv = document.createElement("div");
                _this2.radioInnerDiv.classList.add("apxor-survey-radiobutton-inner-".concat(ind, "-").concat(_this2.cssPostFix));
                _this2.radioInnerDiv.classList.add("apxor-survey-radiobutton-inner-".concat(ind, "-hidden-").concat(_this2.cssPostFix));
                buttonDiv.appendChild(_this2.radioInnerDiv);
                _this2.textForRadioButton = document.createElement("div");
                _this2.textForRadioButton.setAttribute("apx-survey-radio-test", "rating-text");
                _this2.textForRadioButton.classList.add("apxor-survey-radiobutton-text-".concat(ind, "-").concat(_this2.cssPostFix));
                _this2.textForRadioButton.innerText = ratingitem.value;
                _this2.radioButtonContainer.appendChild(_this2.textForRadioButton);
              } else if (_this2.ratingButtons.type === "star") {
                buttonDiv.classList.add("apxor-survey-starbutton-".concat(ind).concat(_this2.cssPostFix));
                var filled_color = "";
                var stroke_color = "";
                if (_this2.ratingButtons.enable_colors) {
                  filled_color = "white";
                  stroke_color = _this2.ratingButtons.buttons[ind].color;
                } else if (_this2.ratingButtons.enable_box_model) {
                  filled_color = _this2.ratingButtons.color_inactive;
                  stroke_color = _this2.ratingButtons.box_model.inactive_color;
                } else {
                  filled_color = _this2.ratingButtons.color_inactive;
                  stroke_color = "transparent";
                }
                buttonDiv.innerHTML = _this2.getStarSvg(36, 36, filled_color, stroke_color);
              } else if (_this2.ratingButtons.type === "emoji") {
                buttonDiv.classList.add("apxor-survey-emoji-buttondiv-".concat(ind, "-").concat(_this2.cssPostFix));
                buttonDiv.innerText = ratingitem.emoji;
              }
              if (_this2.ratingButtons.split_line && count <= 6) {
                if (_this2.ratingButtons.type === "radio") {
                  topRatingDiv.appendChild(_this2.radioButtonContainer);
                } else {
                  topRatingDiv.appendChild(buttonDiv);
                }
              } else {
                if (_this2.ratingButtons.type === "radio") {
                  bottomRatingDiv.appendChild(_this2.radioButtonContainer);
                } else {
                  bottomRatingDiv.appendChild(buttonDiv);
                }
              }
              //call when the button is clicked.
              buttonDiv.onclick = function (e) {
                var anyChoiceSelectedFlag = false;
                var flag = false;
                //this check is when we click the same button.
                if (_this2.ratingButtons.selected_rating[ind] === 1) {
                  anyChoiceSelectedFlag = false;
                  flag = true;
                  if (_this2.rating.enable_reaction) {
                    _this2.npsTopContainer.innerHTML = "";
                    _this2.npsTopContainerMessage.innerHTML = "";
                  }
                  if (_this2.rating.enable_qands) {
                    _this2.QandSContainer.innerHTML = "";
                    _this2.resetQandSState(_this2.ratingButtons.prev_selected_button);
                  }
                  _this2.ratingButtons.prev_selected_button = -1;
                }
                /*
                  if "enable_colors" is true, taking given color as respective button-color.
                  and making every button opacity to 0.3 if any button is clicked
                */
                var nodeList = document.querySelectorAll('div[apx-survey-key="rating"]');
                var radioButtonsTextNodeList = [];
                if (_this2.ratingButtons.type === "radio") {
                  radioButtonsTextNodeList = document.querySelectorAll("div[apx-survey-radio-test=\"rating-text\"]");
                }
                document.querySelectorAll('div[apx-survey-key="rating"]').forEach(function (node, i) {
                  if (i === ind && _this2.ratingButtons.selected_rating[i] !== 1) {
                    anyChoiceSelectedFlag = true;
                    if (_this2.ratingButtons.type === "numbered") {
                      if (!_this2.ratingButtons.enable_colors) {
                        node.classList.add("apxor-survey-buttondiv-selected-".concat(i, "-").concat(_this2.cssPostFix));
                      } else {
                        node.classList.remove("apxor-survey-buttondiv-unselected");
                      }
                    }
                    if (_this2.ratingButtons.type === "radio") {
                      node.classList.add("apxor-survey-radiobutton-selected-".concat(i, "-").concat(_this2.cssPostFix));
                      node.firstChild.classList.remove("apxor-survey-radiobutton-inner-".concat(i, "-hidden-").concat(_this2.cssPostFix));
                      radioButtonsTextNodeList[i].classList.add("apxor-survey-radiobutton-text-".concat(i, "-selected-").concat(_this2.cssPostFix));
                      _this2.ratingButtons.SelectedRadioButton = i;
                    }
                    if (_this2.ratingButtons.type === "star") {
                      for (var j = i; j >= 0; j--) {
                        nodeList[j].firstChild.remove();
                        var _filled_color = "";
                        var _stroke_color = "";
                        if (_this2.ratingButtons.enable_colors) {
                          _filled_color = _this2.ratingButtons.buttons[j].color;
                          _stroke_color = _this2.ratingButtons.buttons[j].color;
                        } else if (_this2.ratingButtons.enable_box_model) {
                          _filled_color = _this2.ratingButtons.color_active;
                          _stroke_color = _this2.ratingButtons.box_model.active_color;
                        } else {
                          _filled_color = _this2.ratingButtons.color_active;
                          _stroke_color = "transparent";
                        }
                        nodeList[j].innerHTML = _this2.getStarSvg(36, 36, _filled_color, _stroke_color);
                        nodeList[j].classList.add("apxor-survey-starbutton-active-".concat(j).concat(_this2.cssPostFix));
                      }
                    }
                    if (_this2.ratingButtons.type === "emoji") {
                      node.classList.add("apxor-survey-emoji-buttondiv-active-".concat(i, "-").concat(_this2.cssPostFix));
                      node.classList.remove("apxor-survey-emoji-buttondiv-inactive-".concat(i, "-").concat(_this2.cssPostFix));
                    }
                    if (_this2.rating.enable_reaction) {
                      _this2.createReactionAndMessageContainer(i);
                    }
                    if (_this2.rating.enable_qands) {
                      _this2.resetQandSState(_this2.ratingButtons.prev_selected_button);
                      _this2.createQansSContainer(i);
                    }
                    _this2.ratingButtons.selected_rating[i] = 1;
                    _this2.ratingButtons.prev_selected_button = i;
                  } else {
                    if (_this2.ratingButtons.enable_colors && _this2.ratingButtons.type === "numbered") {
                      if (flag) {
                        node.classList.remove("apxor-survey-buttondiv-unselected");
                      } else {
                        node.classList.add("apxor-survey-buttondiv-unselected");
                      }
                    } else {
                      if (_this2.ratingButtons.type === "numbered") {
                        node.classList.remove("apxor-survey-buttondiv-selected-".concat(i, "-").concat(_this2.cssPostFix));
                      } else if (_this2.ratingButtons.type === "radio") {
                        node.classList.remove("apxor-survey-radiobutton-selected-".concat(i, "-").concat(_this2.cssPostFix));
                        radioButtonsTextNodeList[i].classList.remove("apxor-survey-radiobutton-text-".concat(i, "-selected-").concat(_this2.cssPostFix));
                        if (_this2.ratingButtons.prevSelectedRadioButton === i) {
                          node.firstChild.classList.add("apxor-survey-radiobutton-inner-".concat(i, "-hidden-").concat(_this2.cssPostFix));
                        }
                      } else if (_this2.ratingButtons.type === "star") {
                        node.firstChild.remove();
                        var _filled_color2 = "";
                        var _stroke_color2 = "";
                        if (_this2.ratingButtons.enable_colors) {
                          _filled_color2 = "white";
                          _stroke_color2 = _this2.ratingButtons.buttons[i].color;
                        } else if (_this2.ratingButtons.enable_box_model) {
                          _filled_color2 = _this2.ratingButtons.color_inactive;
                          _stroke_color2 = _this2.ratingButtons.box_model.inactive_color;
                        } else {
                          _filled_color2 = _this2.ratingButtons.color_inactive;
                          _stroke_color2 = "transparent";
                        }
                        node.innerHTML = _this2.getStarSvg(36, 36, _filled_color2, _stroke_color2);
                        node.classList.remove("apxor-survey-starbutton-active-".concat(i).concat(_this2.cssPostFix));
                      } else if (_this2.ratingButtons.type === "emoji") {
                        if (flag) {
                          node.classList.remove("apxor-survey-emoji-buttondiv-active-".concat(i, "-").concat(_this2.cssPostFix));
                          node.classList.remove("apxor-survey-emoji-buttondiv-inactive-".concat(i, "-").concat(_this2.cssPostFix));
                        } else {
                          node.classList.remove("apxor-survey-emoji-buttondiv-active-".concat(i, "-").concat(_this2.cssPostFix));
                          if (_this2.ratingButtons.enable_fade || _this2.ratingButtons.enable_shadow) {
                            node.classList.add("apxor-survey-emoji-buttondiv-inactive-".concat(i, "-").concat(_this2.cssPostFix));
                          } else {
                            node.classList.remove("apxor-survey-emoji-buttondiv-inactive-".concat(i, "-").concat(_this2.cssPostFix));
                          }
                        }
                      }
                    }
                    _this2.ratingButtons.selected_rating[i] = -1;
                  }
                });
                _this2.ratingButtons.prevSelectedRadioButton = _this2.ratingButtons.SelectedRadioButton;
                _this2.ratingButtons.SelectedRadioButton = -1;
                _this2.changeButtonColor(anyChoiceSelectedFlag);
              };
            });
            if (this.rating.enable_labels) {
              this.firstlabelelement = document.createElement("div");
              this.firstlabelelement.classList.add("apxor-survey-rating-first-label-styles-".concat(this.cssPostFix));
              this._getTitleStyles(this.ratingLabels.first_rating.text, "first-label-text");
              this.firstlabelelement.appendChild(this._setTitleContent(this.ratingLabels.first_rating.text, "first-label-text", ""));
              this.lastlabelelement = document.createElement("div");
              this.lastlabelelement.classList.add("apxor-survey-rating-last-label-styles-".concat(this.cssPostFix));
              this._getTitleStyles(this.ratingLabels.last_rating.text, "last-label-text");
              this.lastlabelelement.appendChild(this._setTitleContent(this.ratingLabels.last_rating.text, "last-label-text", ""));
            }
            if (count > 6 && this.ratingButtons.split_line) {
              if (this.rating.enable_labels) {
                topRatingDiv.appendChild(this.firstlabelelement);
                bottomRatingDiv.appendChild(this.lastlabelelement);
              }
              ratingDiv.appendChild(topRatingDiv);
              ratingDiv.appendChild(bottomRatingDiv);
            } else {
              if (this.rating.enable_labels) {
                bottomRatingDiv.appendChild(this.firstlabelelement);
                bottomRatingDiv.appendChild(this.lastlabelelement);
              }
              ratingDiv.appendChild(bottomRatingDiv);
            }
            this.npsContainer.appendChild(ratingDiv);
          } else {
            this.getSliderStyles();
            var range = document.createElement("div");
            range.className = "range";
            var sliderValueContainer = document.createElement("div");
            sliderValueContainer.className = "sliderValue";
            var valueOfSlider = document.createElement("span");
            valueOfSlider.innerText = 10;
            valueOfSlider.className = "ValueOfSlider";
            sliderValueContainer.appendChild(valueOfSlider);
            range.appendChild(sliderValueContainer);
            var field = document.createElement("div");
            field.className = "field";
            var input = document.createElement("input");
            input.name = input.type = "range";
            input.min = this.ratingButtons.start;
            input.max = this.ratingButtons.end;
            input.value = this.ratingButtons.prev_selected_button === -1 ? this.ratingButtons.start : this.ratingButtons.prev_selected_button;
            input.step = 1;
            field.appendChild(input);
            range.appendChild(field);
            ratingDiv.appendChild(range);
            input.oninput = function () {
              var value = input.value;
              valueOfSlider.textContent = value;
              valueOfSlider.style.left = 100 / _this2.ratingButtons.length * (value - _this2.ratingButtons.start) + "%";
              valueOfSlider.classList.add("show");
              if (_this2.rating.enable_qands) {
                _this2.resetQandSState(_this2.ratingButtons.prev_selected_button);
                _this2.createQansSContainer(value);
              }
              _this2.ratingButtons.selected_rating[value] = 1;
              if (_this2.ratingButtons.prev_selected_button !== -1) {
                _this2.ratingButtons.selected_rating[_this2.ratingButtons.prev_selected_button] = -1;
              }
              _this2.ratingButtons.prev_selected_button = value;
              _this2.changeButtonColor(true);
            };
            input.onblur = function () {
              valueOfSlider.classList.remove("show");
            };
            this.npsContainer.appendChild(ratingDiv);
          }
          this.npsTopContainerMessage = document.createElement("div");
          this.npsTopContainerMessage.classList.add("apxor-survey-nps-topcontainer-message".concat(this.cssPostFix));
          this.npsContainer.appendChild(this.npsTopContainerMessage);

          //QandSContainer containes question, suggestions, inputField
          this._getNpsQandSContainerElementStyles();
          this.QandSContainer = document.createElement("div");
          this.QandSContainer.classList.add("apxor-survey-nps-qands-container".concat(this.cssPostFix));
          this.npsContainer.appendChild(this.QandSContainer);
          this.answerContainer.appendChild(this.npsContainer);
          this.QandAContainer.appendChild(this.answerContainer);
          if (this.ratingButtons.selected_rating.includes(1)) {
            if (this.ratingButtons.type !== "slider") {
              var buttonNodes = document.querySelectorAll('div[apx-survey-key="rating"]');
              var radioButtonsTextNodeList = [];
              if (this.ratingButtons.type === "radio") {
                radioButtonsTextNodeList = document.querySelectorAll("div[apx-survey-radio-test=\"rating-text\"]");
              }
              var selectedIndex = this.ratingButtons.selected_rating.indexOf(1);
              buttonNodes.forEach(function (node, i) {
                if (i === selectedIndex) {
                  if (_this2.ratingButtons.type === "numbered") {
                    if (!_this2.ratingButtons.enable_colors) {
                      node.classList.add("apxor-survey-buttondiv-selected-".concat(i, "-").concat(_this2.cssPostFix));
                    } else {
                      node.classList.remove("apxor-survey-buttondiv-unselected");
                    }
                  }
                  if (_this2.ratingButtons.type === "radio") {
                    node.classList.add("apxor-survey-radiobutton-selected-".concat(i, "-").concat(_this2.cssPostFix));
                    node.firstChild.classList.remove("apxor-survey-radiobutton-inner-".concat(i, "-hidden-").concat(_this2.cssPostFix));
                    radioButtonsTextNodeList[i].classList.add("apxor-survey-radiobutton-text-".concat(i, "-selected-").concat(_this2.cssPostFix));
                    _this2.ratingButtons.SelectedRadioButton = i;
                  }
                  if (_this2.ratingButtons.type === "star") {
                    for (var j = i; j >= 0; j--) {
                      buttonNodes[j].firstChild.remove();
                      var filled_color = "";
                      var stroke_color = "";
                      if (_this2.ratingButtons.enable_colors) {
                        filled_color = _this2.ratingButtons.buttons[j].color;
                        stroke_color = _this2.ratingButtons.buttons[j].color;
                      } else if (_this2.ratingButtons.enable_box_model) {
                        filled_color = _this2.ratingButtons.color_active;
                        stroke_color = _this2.ratingButtons.box_model.active_color;
                      } else {
                        filled_color = _this2.ratingButtons.color_active;
                        stroke_color = "transparent";
                      }
                      buttonNodes[j].innerHTML = _this2.getStarSvg(36, 36, filled_color, stroke_color);
                      buttonNodes[j].classList.add("apxor-survey-starbutton-active-".concat(j).concat(_this2.cssPostFix));
                    }
                  }
                  if (_this2.ratingButtons.type === "emoji") {
                    node.classList.add("apxor-survey-emoji-buttondiv-active-".concat(i, "-").concat(_this2.cssPostFix));
                    node.classList.remove("apxor-survey-emoji-buttondiv-inactive-".concat(i, "-").concat(_this2.cssPostFix));
                  }
                  if (_this2.rating.enable_reaction) {
                    _this2.createReactionAndMessageContainer(i);
                  }
                  if (_this2.rating.enable_qands) {
                    _this2.createQansSContainer(i);
                  }
                  _this2.ratingButtons.prev_selected_button = i;
                } else {
                  if (_this2.ratingButtons.enable_colors && _this2.ratingButtons.type === "numbered") {
                    node.classList.add("apxor-survey-buttondiv-unselected");
                  } else {
                    if (_this2.ratingButtons.type === "numbered") {
                      node.classList.remove("apxor-survey-buttondiv-selected-".concat(i, "-").concat(_this2.cssPostFix));
                    } else if (_this2.ratingButtons.type === "radio") {
                      node.classList.remove("apxor-survey-radiobutton-selected-".concat(i, "-").concat(_this2.cssPostFix));
                      if (_this2.ratingButtons.prevSelectedRadioButton === i) {
                        node.firstChild.classList.add("apxor-survey-radiobutton-inner-".concat(i, "-hidden-").concat(_this2.cssPostFix));
                      }
                    } else if (_this2.ratingButtons.type === "star") {
                      node.firstChild.remove();
                      var _filled_color3 = "";
                      var _stroke_color3 = "";
                      if (_this2.ratingButtons.enable_colors) {
                        _filled_color3 = "white";
                        _stroke_color3 = _this2.ratingButtons.buttons[i].color;
                      } else if (_this2.ratingButtons.enable_box_model) {
                        _filled_color3 = _this2.ratingButtons.color_inactive;
                        _stroke_color3 = _this2.ratingButtons.box_model.inactive_color;
                      } else {
                        _filled_color3 = _this2.ratingButtons.color_inactive;
                        _stroke_color3 = "transparent";
                      }
                      node.innerHTML = _this2.getStarSvg(36, 36, _filled_color3, _stroke_color3);
                      node.classList.remove("apxor-survey-starbutton-active-".concat(i).concat(_this2.cssPostFix));
                    } else if (_this2.ratingButtons.type === "emoji") {
                      node.classList.remove("apxor-survey-emoji-buttondiv-active-".concat(i, "-").concat(_this2.cssPostFix));
                      if (_this2.ratingButtons.enable_fade || _this2.ratingButtons.enable_shadow) {
                        node.classList.add("apxor-survey-emoji-buttondiv-inactive-".concat(i, "-").concat(_this2.cssPostFix));
                      } else {
                        node.classList.remove("apxor-survey-emoji-buttondiv-inactive-".concat(i, "-").concat(_this2.cssPostFix));
                      }
                    }
                  }
                }
              });
            }
            if (this.ratingButtons.type === "slider") {
              if (this.rating.enable_qands) {
                this.createQansSContainer(this.ratingButtons.prev_selected_button);
                this.anyActiveChoices = true;
              }
            }
          }
        }
      }
    }, {
      key: "getSliderStyles",
      value: function getSliderStyles() {
        var SliderStyling = "\n    .range{\n      height: 80px;\n      width: 380px;\n      background: #fff;\n      border-radius: 10px;\n      padding: 0 65px 0 45px;\n      background:transparent;\n    }\n    .sliderValue{\n      position: relative;\n      width: 100%;\n    }\n    .sliderValue span{\n      position: absolute;\n      text-align:center;\n      height: 45px;\n      width: 45px;\n      transform: translateX(-50%) scale(0);\n      font-weight: 500;\n      top: -40px;\n      line-height: 55px;\n      z-index: 2;\n      color: #fff;\n      transform-origin: bottom;\n      transition: transform 0.3s ease-in-out;\n    }\n    .sliderValue span.show{\n      transform: translateX(-50%) scale(1);\n    }\n    .sliderValue span:after{\n      position: absolute;\n      content: '';\n      height: 100%;\n      width: 100%;\n      background: #664AFF;\n      border: 3px solid #fff;\n      z-index: -1;\n      left: 50%;\n      transform: translateX(-50%) rotate(45deg);\n      border-bottom-left-radius: 50%;\n      box-shadow: 0px 0px 8px rgba(0,0,0,0.1);\n      border-top-left-radius: 50%;\n      border-top-right-radius: 50%;\n    }\n    .field{\n      display: flex;\n      align-items: center;\n      justify-content: center;\n      height: 100%;\n      position: relative;\n    }\n    \n    .range input{\n      -webkit-appearance: none;\n      width: 100%;\n      height: 8px;\n      background: #ddd;\n      border-radius: 5px;\n      outline: none;\n      border: none;\n      z-index: 2222;\n    }\n    .range input::-webkit-slider-thumb{\n      -webkit-appearance: none;\n      width: 20px;\n      height: 20px;\n      background: red;\n      border-radius: 50%;\n      background: #664AFF;\n      border: 1px solid #664AFF;\n      cursor: pointer;\n    }\n    .range input::-moz-range-thumb{\n      -webkit-appearance: none;\n      width: 20px;\n      height: 20px;\n      background: red;\n      border-radius: 50%;\n      background: #664AFF;\n      border: 1px solid #664AFF;\n      cursor: pointer;\n    }\n    .range input::-moz-range-progress{\n      background: #664AFF; //this progress background is only shown on Firefox\n    }".replaceAll("\n", "").replace(/[\s]{2,999}/g, "");
        var styleNode = document.createElement("style");
        styleNode.innerHTML = SliderStyling;
        this.overlayElement.appendChild(styleNode);
        return SliderStyling;
      }
    }, {
      key: "resetQandSState",
      value: function resetQandSState(ind) {
        if (ind === -1) {
          return;
        }
        this.rating.stateOfQandS[ind].suggestion = [];
        this.rating.stateOfQandS[ind].input_field = "";
      }
    }, {
      key: "createQansSContainer",
      value: function createQansSContainer(buttonIndex) {
        var _this3 = this;
        this.QandSContainer.innerHTML = "";
        var QandSArrayIndex = this.getcurrentQandSArrayIndexFromQandSPaths(this.rating, parseInt(this.ratingButtons.start_from_index + buttonIndex));
        // buttonIndex = this.ratingButtons.start_from_index + buttonIndex;
        if (QandSArrayIndex === -1) {
          return;
        }
        var QandSElementContainer = document.createElement("div");
        QandSElementContainer.setAttribute("apx-survey-key", "qands-element");
        QandSElementContainer.classList.add("apxor-survey-nps-qands-container-element-".concat(QandSArrayIndex, "-").concat(buttonIndex, "-").concat(this.cssPostFix));
        var QuestionContainer = document.createElement("div");
        QuestionContainer.classList.add("apxor-survey-nps-qands-question-container".concat(this.cssPostFix));
        if (this.QandSArray[QandSArrayIndex].question.enable_title) {
          this._getTitleStyles(this.QandSArray[QandSArrayIndex].question.title, "nps-question-title-".concat(QandSArrayIndex, "-").concat(buttonIndex));
          QuestionContainer.appendChild(this._setTitleContent(this.QandSArray[QandSArrayIndex].question.title, "nps-question-title-".concat(QandSArrayIndex, "-").concat(buttonIndex), this.configId));
        }
        if (this.QandSArray[QandSArrayIndex].question.enable_description) {
          this._getDescriptionStyles(this.QandSArray[QandSArrayIndex].question.description, "nps-question-description-".concat(QandSArrayIndex, "-").concat(buttonIndex));
          QuestionContainer.appendChild(this._setDescriptionContent(this.QandSArray[QandSArrayIndex].question.description, "nps-question-description-".concat(QandSArrayIndex, "-").concat(buttonIndex), this.configId));
        }
        var SuggestionContainer = document.createElement("div");
        SuggestionContainer.classList.add("apxor-survey-nps-qands-suggestion-container".concat(this.cssPostFix));
        if (this.QandSArray[QandSArrayIndex].enable_suggestion) {
          this._getNpsSuggestionElementStyles(this.QandSArray[QandSArrayIndex].suggestion, QandSArrayIndex, buttonIndex);
          this.QandSArray[QandSArrayIndex].suggestion.text.forEach(function (element, indexOfsuggestion) {
            var suggestionElement = document.createElement("div");
            suggestionElement.classList.add("apxor-survey-nps-qands-".concat(QandSArrayIndex, "-").concat(buttonIndex, "-suggestion-").concat(indexOfsuggestion, "-").concat(_this3.cssPostFix));
            if (_this3.rating.stateOfQandS[buttonIndex].suggestion.includes(indexOfsuggestion)) suggestionElement.classList.add("apxor-survey-nps-qands-".concat(QandSArrayIndex, "-").concat(buttonIndex, "-suggestion-").concat(indexOfsuggestion, "-selected-").concat(_this3.cssPostFix));
            suggestionElement.setAttribute("apx-nps-survey-key", "suggestion");
            suggestionElement.innerText = element;
            suggestionElement.onclick = function () {
              document.querySelectorAll("div[apx-nps-survey-key=\"suggestion\"]").forEach(function (node, nodeindex) {
                if (indexOfsuggestion === nodeindex) {
                  if (_this3.rating.stateOfQandS[buttonIndex].suggestion.includes(indexOfsuggestion)) {
                    node.classList.remove("apxor-survey-nps-qands-".concat(QandSArrayIndex, "-").concat(buttonIndex, "-suggestion-").concat(nodeindex, "-selected-").concat(_this3.cssPostFix));
                    var n = _this3.rating.stateOfQandS[buttonIndex].suggestion.indexOf(indexOfsuggestion);
                    _this3.rating.stateOfQandS[buttonIndex].suggestion.splice(n, 1);
                  } else {
                    node.classList.add("apxor-survey-nps-qands-".concat(QandSArrayIndex, "-").concat(buttonIndex, "-suggestion-").concat(nodeindex, "-selected-").concat(_this3.cssPostFix));
                    _this3.rating.stateOfQandS[buttonIndex].suggestion.push(indexOfsuggestion);
                  }
                }
              });
            };
            SuggestionContainer.appendChild(suggestionElement);
          });
        }
        var inputTextContainer = document.createElement("div");
        inputTextContainer.classList.add("apxor-survey-nps-qands-inputtextfield-container".concat(this.cssPostFix));
        if (this.QandSArray[QandSArrayIndex].enable_input_text && Object.keys(this.answer.input_text).length !== 0) {
          this.getTextAreaNodeStyles(this.answer, "qands");
          var input_text_field = this.getTextAreaNode(this.answer.input_text, this.rating.stateOfQandS[buttonIndex].input_field, "qands");
          input_text_field.addEventListener("input", function (e) {
            _this3.rating.stateOfQandS[buttonIndex].input_field = e.target.value;
          });
          inputTextContainer.appendChild(input_text_field);
        }
        QandSElementContainer.appendChild(QuestionContainer);
        QandSElementContainer.appendChild(SuggestionContainer);
        QandSElementContainer.appendChild(inputTextContainer);
        this.QandSContainer.appendChild(QandSElementContainer);
      }
    }, {
      key: "createReactionAndMessageContainer",
      value: function createReactionAndMessageContainer(buttonIndex) {
        this.npsTopContainer.innerHTML = "";
        this.npsTopContainerMessage.innerHTML = "";
        var reactionsArrayIndex = this.getReactionIndexFromReactionPath(this.rating, parseInt(this.ratingButtons.start_from_index + buttonIndex));
        if (reactionsArrayIndex === -1) {
          return;
        }
        var npsTopContainerElement = document.createElement("div");
        npsTopContainerElement.setAttribute("apx-survey-key", "rating-message");
        npsTopContainerElement.classList.add("apxor-survey-nps-topcontainer-element-".concat(reactionsArrayIndex, "-").concat(this.ratingButtons.start_from_index + buttonIndex, "-").concat(this.cssPostFix));
        var npsTopContainerTextElement = document.createElement("div");
        npsTopContainerTextElement.classList.add("apxor-survey-nps-topcontainer-text-element-".concat(reactionsArrayIndex, "-").concat(this.ratingButtons.start_from_index + buttonIndex, "-").concat(this.cssPostFix));
        if (this.reactions[reactionsArrayIndex].enable_text && this.reactions[reactionsArrayIndex].text_position === "above_image") {
          this._getTitleStyles(this.reactions[reactionsArrayIndex].text, "reaction-text-".concat(reactionsArrayIndex));
          npsTopContainerTextElement.appendChild(this._setTitleContent(this.reactions[reactionsArrayIndex].text, "reaction-text-".concat(reactionsArrayIndex), ""));
          npsTopContainerElement.appendChild(npsTopContainerTextElement);
        }
        var npsTopContainerImageElement = document.createElement("div");
        npsTopContainerImageElement.classList.add("apxor-survey-nps-topcontainer-image-element-".concat(reactionsArrayIndex, "-").concat(this.cssPostFix));
        if (this.reactions[reactionsArrayIndex].enable_image) {
          this._getNpsTopImageStyles(this.reactions[reactionsArrayIndex].image, reactionsArrayIndex);
          var imgElement = document.createElement("img");
          imgElement.src = this.reactions[reactionsArrayIndex].image.path;
          imgElement.classList.add("apxor-survey-npstopcontainer-image-".concat(reactionsArrayIndex));
          npsTopContainerImageElement.appendChild(imgElement);
        }
        npsTopContainerElement.appendChild(npsTopContainerImageElement);
        if (this.reactions[reactionsArrayIndex].enable_text && this.reactions[reactionsArrayIndex].text_position === "below_image") {
          this._getTitleStyles(this.reactions[reactionsArrayIndex].text, "reaction-text-".concat(reactionsArrayIndex));
          npsTopContainerTextElement.appendChild(this._setTitleContent(this.reactions[reactionsArrayIndex].text, "reaction-text-".concat(reactionsArrayIndex), ""));
          npsTopContainerElement.appendChild(npsTopContainerTextElement);
        }
        if (this.reactions[reactionsArrayIndex].enable_text && this.reactions[reactionsArrayIndex].text_position === "below_buttons") {
          this._getTitleStyles(this.reactions[reactionsArrayIndex].text, "reaction-text-".concat(reactionsArrayIndex));
          npsTopContainerTextElement.appendChild(this._setTitleContent(this.reactions[reactionsArrayIndex].text, "reaction-text-".concat(reactionsArrayIndex), ""));
          this.npsTopContainerMessage.appendChild(npsTopContainerTextElement);
        }
        this.npsTopContainer.appendChild(npsTopContainerElement);
      }
    }, {
      key: "changeButtonColor",
      value: function changeButtonColor(flag) {
        if (this.QandAArray[this.index].is_required) {
          if (flag) {
            if (document.getElementById("apxor-survey_bottom-next-button")) {
              var nextButton = document.getElementById("apxor-survey_bottom-next-button");
              nextButton.style.pointerEvents = "visible";
              nextButton.style.background = "".concat(this.buttonColorObject["next"].active_color);
            }
            if (document.getElementById("apxor-survey_bottom-submit-button")) {
              var submitButton = document.getElementById("apxor-survey_bottom-submit-button");
              submitButton.style.pointerEvents = "visible";
              submitButton.style.background = "".concat(this.buttonColorObject["submit"].active_color);
            }
          } else {
            if (document.getElementById("apxor-survey_bottom-next-button")) {
              var _nextButton = document.getElementById("apxor-survey_bottom-next-button");
              _nextButton.style.pointerEvents = "none";
              _nextButton.style.background = "".concat(this.buttonColorObject["next"].inactive_color);
            }
            if (document.getElementById("apxor-survey_bottom-submit-button")) {
              var _submitButton = document.getElementById("apxor-survey_bottom-submit-button");
              _submitButton.style.pointerEvents = "none";
              _submitButton.style.background = "".concat(this.buttonColorObject["submit"].inactive_color);
            }
          }
        }
      }
    }, {
      key: "getReactionIndexFromReactionPath",
      value: function getReactionIndexFromReactionPath(ratingConfig, buttonClick) {
        if (!ratingConfig.enable_reaction) {
          return -1;
        }
        var reaction_paths = ratingConfig.reaction_paths;
        var ind = -1;
        Object.keys(reaction_paths).forEach(function (key) {
          var path = reaction_paths[key];
          if (path.includes(buttonClick)) {
            ind = key;
          }
        });
        return ind;
      }
    }, {
      key: "getcurrentQandSArrayIndexFromQandSPaths",
      value: function getcurrentQandSArrayIndexFromQandSPaths(ratingConfig, buttonClick) {
        if (!ratingConfig.enable_qands) {
          return -1;
        }
        var qandsPaths = ratingConfig.qandsPaths;
        var ind = -1;
        Object.keys(qandsPaths).forEach(function (key) {
          var path = qandsPaths[key];
          if (path.includes(buttonClick)) {
            ind = key;
          }
        });
        return parseInt(ind);
      }
    }, {
      key: "_getNpscontainerStyles",
      value: function _getNpscontainerStyles(answerConfig) {
        var marginForNpsContainer = "";
        if (answerConfig.enable_margin) {
          marginForNpsContainer = "\n      margin:".concat(answerConfig.margin.top, "px ").concat(answerConfig.margin.right, "px ").concat(answerConfig.margin.bottom, "px ").concat(answerConfig.margin.left, "px\n      ");
        }
        var paddingForNpsContainer = "";
        if (answerConfig.enable_padding) {
          paddingForNpsContainer = "\n      padding:".concat(answerConfig.padding.top, "px ").concat(answerConfig.padding.right, "px ").concat(answerConfig.padding.bottom, "px ").concat(answerConfig.padding.left, "px\n      ");
        }
        var borderForNpsContainer = "";
        if (answerConfig.enable_border) {
          borderForNpsContainer = "\n      border:".concat(answerConfig.border.width, "px ").concat(answerConfig.border.style, " ").concat(answerConfig.border.color);
        }
        var npsContainerStyles = "\n    .apxor-survey-nps-container".concat(this.cssPostFix, "{\n      width:auto;\n      height:auto;\n      display:flex;\n      flex-direction:column;\n      align-items:center;\n      ").concat(marginForNpsContainer, ";\n      ").concat(paddingForNpsContainer, ";\n      ").concat(borderForNpsContainer, ";\n    }").replaceAll("\n", "").replace(/[\s]{2,999}/g, "");
        var styleNode = document.createElement("style");
        styleNode.innerHTML = npsContainerStyles;
        this.overlayElement.appendChild(styleNode);
        return npsContainerStyles;
      }
    }, {
      key: "_getNpsTopContainerStyles",
      value: function _getNpsTopContainerStyles() {
        var npsTopContainerStyling = "\n    .apxor-survey-nps-topcontainer".concat(this.cssPostFix, "{\n      width:100%;\n      height:auto;\n      display:flex;\n      flex-direction:column;\n      align-items:center;\n      position:relative;\n      margin:8px 0px 8px 0px;\n    }\n    .apxor-survey-nps-topcontainer-message").concat(this.cssPostFix, "{\n      width:100%;\n      height:auto;\n      display:flex;\n      flex-direction:column;\n      align-items:center;\n      position:relative;\n      margin:8px 0px 8px 0px;\n    }");
        return npsTopContainerStyling;
      }
    }, {
      key: "_getNpsTopImageStyles",
      value: function _getNpsTopImageStyles(imageConfig, ind) {
        var imageStyles = "";
        var imageBorderStyles = "";
        if (imageConfig.enable_border) {
          imageBorderStyles = "\n        border-radius:".concat(imageConfig.border.radius, "%;\n        border:").concat(imageConfig.border.width, "px ").concat(imageConfig.border.style, " ").concat(imageConfig.border.color, ";\n        ");
        }
        var imageMarginStyles = "";
        if (imageConfig.enable_margin) {
          imageMarginStyles = "\n      margin:".concat(imageConfig.margin.top, "px ").concat(imageConfig.margin.right, "px ").concat(imageConfig.margin.bottom, "px ").concat(imageConfig.margin.left, "px;\n      ");
        }
        imageStyles = "\n      .apxor-survey-nps-topcontainer-image-element-".concat(ind, "-").concat(this.cssPostFix, "{\n        width:100%;\n        height:100%;\n        text-align:").concat(imageConfig.position, ";\n        margin:4px 0px 4px 0px;\n      }\n      .apxor-survey-npstopcontainer-image-").concat(ind, "{\n        height: ").concat(imageConfig.height, "px;\n        width: ").concat(imageConfig.width, "px;\n        ").concat(imageBorderStyles, ";\n        ").concat(imageMarginStyles, ";\n      }").replaceAll("\n", "").replace(/[\s]{2,999}/g, "");
        var styleNode = document.createElement("style");
        styleNode.innerHTML = imageStyles;
        this.overlayElement.appendChild(styleNode);
        return imageStyles;
      }
    }, {
      key: "_getRatingBlockStyles",
      value: function _getRatingBlockStyles() {
        var ratingBlockStyling = "\n    .apxor-survey-ratingdiv".concat(this.cssPostFix, "{\n      display:flex;\n      flex-direction:column;\n      align-items:center;\n      width:100%;\n      height:auto;\n      margin:24px 0px 24px 0px;\n    }\n    .apxor-survey-topratingdiv").concat(this.cssPostFix, "{\n      position:relative;\n      display:flex;\n      align-items:center;\n      justify-content:center;\n      width:auto;\n      height:auto;\n    }\n    .apxor-survey-bottomratingdiv").concat(this.cssPostFix, "{\n      position:relative;\n      display:flex;\n      align-items:center;\n      justify-content:center;\n      width:auto;\n      height:auto;\n    }");
        return ratingBlockStyling;
      }
    }, {
      key: "_getRatingNumberButtonStyles",
      value: function _getRatingNumberButtonStyles(ratingButtonConfig) {
        var fontForButtons = "";
        if (ratingButtonConfig !== null && ratingButtonConfig !== void 0 && ratingButtonConfig.font) {
          fontForButtons = "\n        font-size:".concat(ratingButtonConfig.font.size, "px;\n        font-family:").concat(ratingButtonConfig.font.family, ";\n        font-style:").concat(ratingButtonConfig.font.style, ";\n        font-weight:").concat(ratingButtonConfig.font.weight, ";\n      ");
        }
        var marginForButtons = "";
        if (ratingButtonConfig.enable_margin) {
          marginForButtons = "\n      margin:".concat(ratingButtonConfig.margin.top, "px ").concat(ratingButtonConfig.margin.right, "px ").concat(ratingButtonConfig.margin.bottom, "px ").concat(ratingButtonConfig.margin.left, "px;\n      ");
        }
        var paddingForButtons = "";
        if (ratingButtonConfig.enable_padding) {
          paddingForButtons = "\n      padding:".concat(ratingButtonConfig.padding.top, "px ").concat(ratingButtonConfig.padding.right, "px ").concat(ratingButtonConfig.padding.bottom, "px ").concat(ratingButtonConfig.padding.left, "px;\n      ");
        }
        var borderForButtons = "";
        if (ratingButtonConfig.enable_border) {
          borderForButtons = "\n        border:".concat(ratingButtonConfig.border.width, "px ").concat(ratingButtonConfig.border.style, " ").concat(ratingButtonConfig.border.inactive_color, ";\n        border-radius:").concat(ratingButtonConfig.border.radius, "px;\n      ");
        }
        var borderForActiveButtons = "";
        if (ratingButtonConfig.enable_border) {
          borderForActiveButtons = "\n        border:".concat(ratingButtonConfig.border.width, "px ").concat(ratingButtonConfig.border.style, " ").concat(ratingButtonConfig.border.color, ";\n        border-radius:").concat(ratingButtonConfig.border.radius, "px;\n      ");
        }
        var stylingForRatingButtons = "";
        for (var i = 0; i < ratingButtonConfig.buttons.length; i++) {
          stylingForRatingButtons += "\n      .apxor-survey-buttondiv-".concat(i, "-").concat(this.cssPostFix, "{\n        cursor:pointer;\n        position:relative;\n        display: flex;\n        justify-content: space-evenly;\n        align-items: center;\n        width: ").concat(ratingButtonConfig.width, "px;\n        height: ").concat(ratingButtonConfig.height, "px;\n        ").concat(fontForButtons, ";\n        ").concat(marginForButtons, ";\n        ").concat(paddingForButtons, ";\n        ").concat(borderForButtons, ";\n        color:").concat(ratingButtonConfig.color_inactive, ";\n        background-color: ").concat(ratingButtonConfig.enable_colors ? ratingButtonConfig.buttons[i].color : ratingButtonConfig.bg_color_inactive, ";\n      }\n      .apxor-survey-buttondiv-selected-").concat(i, "-").concat(this.cssPostFix, "{\n        background:").concat(ratingButtonConfig.bg_color_active, "!important;\n        color:").concat(ratingButtonConfig.color_active, " !important;\n        ").concat(borderForActiveButtons, ";\n      }");
        }
        var ratingButtonStyling = "\n      .apxor-survey-buttondiv-unselected{\n        opacity:0.3!important;\n      }\n      ".concat(stylingForRatingButtons, ";\n      ").replaceAll("\n", "").replace(/[\s]{2,999}/g, "");
        var styleNode = document.createElement("style");
        styleNode.innerHTML = ratingButtonStyling;
        this.overlayElement.appendChild(styleNode);
        return ratingButtonStyling;
      }
    }, {
      key: "_getRatingRadioButtonStyles",
      value: function _getRatingRadioButtonStyles(ratingButtonConfig) {
        var _this4 = this;
        var fontStylesForRatingButtons = "";
        if (ratingButtonConfig.font) {
          fontStylesForRatingButtons = "\n      font-size:".concat(ratingButtonConfig.font.size, "px;\n      font-family:").concat(ratingButtonConfig.font.family, ";\n      font-style:").concat(ratingButtonConfig.font.style, ";\n      font-weight:").concat(ratingButtonConfig.font.weight, ";\n      ");
        }
        var marginForRatingButtons = "";
        if (ratingButtonConfig.enable_margin) {
          marginForRatingButtons = "\n      margin:".concat(ratingButtonConfig.margin.top, "px ").concat(ratingButtonConfig.margin.right, "px ").concat(ratingButtonConfig.margin.bottom, "px ").concat(ratingButtonConfig.margin.left, "px;\n      ");
        }
        var paddingForRatingButtons = "";
        if (ratingButtonConfig.enable_padding) {
          paddingForRatingButtons = "\n      padding:".concat(ratingButtonConfig.padding.top, "px ").concat(ratingButtonConfig.padding.right, "px ").concat(ratingButtonConfig.padding.bottom, "px ").concat(ratingButtonConfig.padding.left, "px;\n      ");
        }
        var stylingForRatingRadioButtons = "";
        ratingButtonConfig.buttons.forEach(function (button, i) {
          stylingForRatingRadioButtons += "\n      .apxor-survey-radio-button-container-".concat(i, "-styling").concat(_this4.cssPostFix, "{\n        width:auto;\n        height:auto;\n        display:flex;\n        flex-direction:column;\n        justify-content:center;\n        align-items:center;\n        gap:4px;\n        ").concat(marginForRatingButtons, ";\n        ").concat(paddingForRatingButtons, ";\n      }\n      .apxor-survey-radiobutton-").concat(i, "-").concat(_this4.cssPostFix, "{\n        cursor:pointer;\n        position:relative;\n        display: flex;\n        justify-content: center;\n        align-items: center;\n        width: ").concat(ratingButtonConfig.width, "px;\n        height: ").concat(ratingButtonConfig.height, "px;\n        margin:0px 2px 0px 2px;\n        border-radius:50px;\n        border:2px solid ").concat(ratingButtonConfig.bg_color_inactive, ";\n      }\n      .apxor-survey-radiobutton-selected-").concat(i, "-").concat(_this4.cssPostFix, "{\n        border:2px solid ").concat(ratingButtonConfig.bg_color_active, ";\n      }\n      .apxor-survey-radiobutton-inner-").concat(i, "-").concat(_this4.cssPostFix, "{\n        width:").concat(ratingButtonConfig.width - 10, "px;\n        height:").concat(ratingButtonConfig.height - 10, "px;\n        border-radius:50px;\n        background-color:").concat(ratingButtonConfig.bg_color_active, ";\n      }\n      .apxor-survey-radiobutton-inner-").concat(i, "-hidden-").concat(_this4.cssPostFix, "{\n        display:none;\n      }\n      .apxor-survey-radiobutton-text-").concat(i, "-").concat(_this4.cssPostFix, "{\n        ").concat(fontStylesForRatingButtons, ";\n        color:").concat(ratingButtonConfig.color_inactive, "\n      }\n      .apxor-survey-radiobutton-text-").concat(i, "-selected-").concat(_this4.cssPostFix, "{\n        color:").concat(ratingButtonConfig.color_active, "\n      }\n      ");
        });
        var ratingRadioButtonStyling = "\n    ".concat(stylingForRatingRadioButtons).replaceAll("\n", "").replace(/[\s]{2,999}/g, "");
        var styleNode = document.createElement("style");
        styleNode.innerHTML = ratingRadioButtonStyling;
        this.overlayElement.appendChild(styleNode);
        return ratingRadioButtonStyling;
      }
    }, {
      key: "getStarButtonStyling",
      value: function getStarButtonStyling(ratingbuttons) {
        var _this5 = this;
        var marginForButtons = "";
        if (ratingbuttons.enable_margin) {
          marginForButtons = "\n      margin:".concat(ratingbuttons.margin.top, "px ").concat(ratingbuttons.margin.right, "px ").concat(ratingbuttons.margin.bottom, "px ").concat(ratingbuttons.margin.left, "px\n      ");
        }
        if (ratingbuttons.enable_box_model) {
          ratingbuttons.border.color = ratingbuttons.box_model.active_color;
          ratingbuttons.border.inactive_color = ratingbuttons.box_model.inactive_color;
        }
        var buttonsInactiveBorder = "";
        var buttonsactiveBorder = "";
        if (ratingbuttons.enable_border) {
          buttonsInactiveBorder = "\n      border-radius:".concat(ratingbuttons.border.radius, "px;\n      border:").concat(ratingbuttons.border.width, "px ").concat(ratingbuttons.border.style, " ").concat(ratingbuttons.border.inactive_color, ";\n      ");
          buttonsactiveBorder = "\n      border-radius:".concat(ratingbuttons.border.radius, "px;\n      border:").concat(ratingbuttons.border.width, "px ").concat(ratingbuttons.border.style, " ").concat(ratingbuttons.border.color, ";\n      ");
        }
        var ButtonStyling = "";
        ratingbuttons.buttons.forEach(function (starRating, i) {
          ButtonStyling += "\n      .apxor-survey-starbutton-".concat(i).concat(_this5.cssPostFix, "{\n        position:relative;\n        width:auto;\n        display:flex;\n        justify-content:center;\n        align-items:center;\n        background:").concat(ratingbuttons.bg_color_inactive, ";\n        ").concat(buttonsInactiveBorder, ";\n        ").concat(marginForButtons, ";\n      }\n      .apxor-survey-starbutton-active-").concat(i).concat(_this5.cssPostFix, "{\n        background:").concat(ratingbuttons.bg_color_active, ";\n        ").concat(buttonsactiveBorder, ";\n      }");
        });
        var starButtonsDivStylings = "".concat(ButtonStyling, "\n    ").replaceAll("\n", "").replace(/[\s]{2,999}/g, "");
        var styleNode = document.createElement("style");
        styleNode.innerHTML = starButtonsDivStylings;
        this.overlayElement.appendChild(styleNode);
        return starButtonsDivStylings;
      }
    }, {
      key: "getEmojiButtonStyling",
      value: function getEmojiButtonStyling(ratingButtonConfig) {
        var _this6 = this;
        var marginForEmojiButton = "";
        if (ratingButtonConfig.enable_margin) {
          marginForEmojiButton = "\n        margin:".concat(ratingButtonConfig.margin.top, "px ").concat(ratingButtonConfig.margin.right, "px ").concat(ratingButtonConfig.margin.bottom, "px ").concat(ratingButtonConfig.margin.left, "px;\n      ");
        }
        var paddingForEmojiButton = "";
        if (ratingButtonConfig.enable_padding) {
          paddingForEmojiButton = "\n        padding:".concat(ratingButtonConfig.padding.top, "px ").concat(ratingButtonConfig.padding.right, "px ").concat(ratingButtonConfig.padding.bottom, "px ").concat(ratingButtonConfig.padding.left, "px;\n      ");
        }
        var borderForActiveEmojiButton = "";
        if (ratingButtonConfig.enable_border) {
          "\n        border: ".concat(ratingButtonConfig.border.width, "px ").concat(ratingButtonConfig.border.style, " ").concat(ratingButtonConfig.border.inactive_color, ";\n      ");
          borderForActiveEmojiButton = "\n      border: ".concat(ratingButtonConfig.border.width, "px ").concat(ratingButtonConfig.border.style, " ").concat(ratingButtonConfig.border.color, ";\n      ");
        }
        var shadowStylesForEmojiButton = "";
        if (ratingButtonConfig.enable_shadow) {
          shadowStylesForEmojiButton = "\n      text-shadow: ".concat(ratingButtonConfig.shadow.offset_x, "px ").concat(ratingButtonConfig.shadow.offset_y, "px 12px ").concat(ratingButtonConfig.shadow.color, ";\n      ");
        }
        var emojiActiveStyle = "";
        var emojiInactiveStyle = "";
        if (ratingButtonConfig.enable_fade) {
          emojiActiveStyle = "\n      opacity:1;\n      ";
          emojiInactiveStyle = "\n      opacity:0.5;\n      ";
        } else if (ratingButtonConfig.enable_shadow) {
          emojiActiveStyle = "\n      font-size:".concat(ratingButtonConfig.width + 4, "px;\n      ").concat(shadowStylesForEmojiButton, ";\n      ");
          emojiInactiveStyle = "\n      font-size:".concat(ratingButtonConfig.width - 4, "px;\n      ");
        } else {
          emojiActiveStyle = "\n      ".concat(borderForActiveEmojiButton, ";\n      background:").concat(ratingButtonConfig.bg_color_active, ";\n      ");
          emojiInactiveStyle = "\n      ";
        }
        var emojiButtonstyles = "";
        ratingButtonConfig.buttons.forEach(function (rating, i) {
          emojiButtonstyles += "\n      .apxor-survey-emoji-buttondiv-".concat(i, "-").concat(_this6.cssPostFix, "{\n        position:relative;\n        display:flex;\n        justify-content:center;\n        align-items:center;\n        font-size:").concat(ratingButtonConfig.width, "px;\n        ").concat(marginForEmojiButton, ";\n        ").concat(paddingForEmojiButton, ";\n      }\n      .apxor-survey-emoji-buttondiv-active-").concat(i, "-").concat(_this6.cssPostFix, "{\n        ").concat(emojiActiveStyle, ";\n      }\n      .apxor-survey-emoji-buttondiv-inactive-").concat(i, "-").concat(_this6.cssPostFix, "{\n        ").concat(emojiInactiveStyle, ";\n      }\n      ");
        });
        var emojiButtonstyling = "";
        emojiButtonstyling = "\n    ".concat(emojiButtonstyles, "\n    ").replaceAll("\n", "").replace(/[\s]{2,999}/g, "");
        var styleNode = document.createElement("style");
        styleNode.innerHTML = emojiButtonstyling;
        this.overlayElement.appendChild(styleNode);
        return emojiButtonstyling;
      }
    }, {
      key: "getRatingLabelsStyling",
      value: function getRatingLabelsStyling(ratingButtonConfig, ratingLabelsConfig) {
        var marginForFirstlabels = 0;
        var marginForLastlabels = 0;
        if (ratingButtonConfig.enable_margin) {
          marginForFirstlabels = ratingButtonConfig.margin.left;
          marginForLastlabels = ratingButtonConfig.margin.right;
        }
        var ratingLabelStyles = "\n    .apxor-survey-rating-first-label-styles-".concat(this.cssPostFix, "{\n      position:absolute;\n      pointer-events:none;\n      ").concat(ratingLabelsConfig.first_rating.position === "top" ? "bottom:100%;" : "top:100%;", "\n      left:").concat(marginForFirstlabels, "px;\n    }\n    .apxor-survey-rating-last-label-styles-").concat(this.cssPostFix, "{\n      position:absolute;\n      pointer-events:none;\n      ").concat(ratingLabelsConfig.last_rating.position === "top" ? "bottom:100%;" : "top:100%;", "\n      right:").concat(marginForLastlabels, "px;\n    }\n    ").replaceAll("\n", "").replace(/[\s]{2,999}/g, "");
        var styleNode = document.createElement("style");
        styleNode.innerHTML = ratingLabelStyles;
        this.overlayElement.appendChild(styleNode);
        return ratingLabelStyles;
      }
    }, {
      key: "getStarSvg",
      value: function getStarSvg(width, height, filled_color) {
        var stroke_color = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "transparent";
        var starSvg = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"".concat(width, "\" height=\"").concat(height, "\" viewBox=\"0 0 36 33\" fill=\"none\">\n      <path d=\"M18 0L22.0413 12.4377H35.119L24.5389 20.1246L28.5801 32.5623L18 24.8754L7.41987 32.5623L11.4611 20.1246L0.880983 12.4377H13.9587L18 0Z\" fill=\"").concat(filled_color, "\" stroke=\"").concat(stroke_color, "\"/>\n    </svg>\n    ");
        return starSvg;
      }
    }, {
      key: "getNpsQandSContainerStyles",
      value: function getNpsQandSContainerStyles() {
        var qandsStyling = "\n    .apxor-survey-nps-reactionandmessage-container".concat(this.cssPostFix, "{\n      width:100%;\n\n    }\n    .apxor-survey-nps-qands-container").concat(this.cssPostFix, "{\n      width:100%;\n      height:auto;\n      display:flex;\n      flex-direction:column;\n    }\n    .apxor-survey-nps-qands-question-container").concat(this.cssPostFix, "{\n      width:100%;\n      height:auto;\n      display:flex;\n      flex-direction:column;\n      margin:4px 0px 4px 0px;\n    }\n    .apxor-survey-nps-qands-suggestion-container").concat(this.cssPostFix, "{\n      display:flex;\n      flex-direction:row;\n      flex-wrap:wrap;\n      width:100%;\n      margin:4px 0px 4px 0px;\n    }\n    .apxor-survey-nps-qands-inputtextfield-container").concat(this.cssPostFix, "{\n      width:100%;\n      height:auto;\n      margin:4px 0px 4px 0px;\n    }");
        return qandsStyling;
      }
    }, {
      key: "_getNpsTopContainerElementStyles",
      value: function _getNpsTopContainerElementStyles() {
        var _this7 = this;
        if (!this.rating.enable_reaction && Object.keys(this.reactions).length === 0) {
          return;
        }
        var npsReactionAndMessageContainerElementStyling = "";
        this.reactions.forEach(function (reactionElement, ind) {
          for (var i = reactionElement.start; i <= reactionElement.end; i++) {
            npsReactionAndMessageContainerElementStyling += "\n        .apxor-survey-nps-topcontainer-element-".concat(ind, "-").concat(i, "-").concat(_this7.cssPostFix, "{\n          width:100%;\n          height:100%;\n          display:flex;\n          flex-direction:column;\n          align-items:center;\n        }\n        .apxor-survey-nps-topcontainer-text-element-").concat(ind, "-").concat(i, "-").concat(_this7.cssPostFix, "{\n          width:100%;\n          height:100%;\n          margin:4px 0px 4px 0px;\n        }");
          }
        });
        var reactionandmessageContainerElementsStyling = "\n    ".concat(npsReactionAndMessageContainerElementStyling, "\n    ;\n    ").replaceAll("\n", "").replace(/[\s]{2,999}/g, "");
        var styleNode = document.createElement("style");
        styleNode.innerHTML = reactionandmessageContainerElementsStyling;
        this.overlayElement.appendChild(styleNode);
        return reactionandmessageContainerElementsStyling;
      }
    }, {
      key: "_getNpsQandSContainerElementStyles",
      value: function _getNpsQandSContainerElementStyles() {
        var _this8 = this;
        if (!this.rating.enable_qands && Object.keys(this.QandSArray).length === 0) {
          return;
        }
        var npsQandSContainerElementStyling = "";
        this.QandSArray.forEach(function (qandsElement, ind) {
          for (var i = qandsElement.start; i <= qandsElement.end; i++) {
            npsQandSContainerElementStyling += "\n      .apxor-survey-nps-qands-container-element-".concat(ind, "-").concat(i, "-").concat(_this8.cssPostFix, "{\n        width:100%;\n        height:auto;\n        display:flex;\n        flex-direction:column;\n        align-items:center;\n      }\n      .apxor-survey-nps-qands-container-element-").concat(ind, "-").concat(i, "-hidden-").concat(_this8.cssPostFix, "{\n        display:none;\n      }");
          }
        });
        var QandSContainerElementsStyling = "\n    ".concat(npsQandSContainerElementStyling, "\n    ;\n    ").replaceAll("\n", "").replace(/[\s]{2,999}/g, "");
        var styleNode = document.createElement("style");
        styleNode.innerHTML = QandSContainerElementsStyling;
        this.overlayElement.appendChild(styleNode);
        return QandSContainerElementsStyling;
      }
    }, {
      key: "_getNpsSuggestionElementStyles",
      value: function _getNpsSuggestionElementStyles(suggestionConfig, qandsIndex, i) {
        var _this9 = this;
        var suggestionMargin = "";
        if (suggestionConfig.enable_margin) {
          suggestionMargin = "\n        margin:".concat(suggestionConfig.margin.top || 4, "px ").concat(suggestionConfig.margin.right || 4, "px ").concat(suggestionConfig.margin.bottom || 4, "px ").concat(suggestionConfig.margin.left || 4, "px;\n      ");
        } else {
          suggestionMargin = "\n        margin:0px 4px 0px 4px;\n        ";
        }
        var suggestionPadding = "";
        if (suggestionConfig.enable_padding) {
          suggestionPadding = "\n        padding:".concat(suggestionConfig.padding.top || 8, "px ").concat(suggestionConfig.padding.right || 16, "px ").concat(suggestionConfig.padding.bottom || 8, "px ").concat(suggestionConfig.padding.left || 16, "px;\n      ");
        } else {
          suggestionPadding = "\n        padding:8px 16px 8px 16px;\n        ";
        }
        var suggestionBorder = "";
        if (suggestionConfig.enable_border) {
          suggestionBorder = "\n        border-radius: ".concat(suggestionConfig.border.radius || 16, "px;\n        border: ").concat(suggestionConfig.border.width || 2, "px ").concat(suggestionConfig.border.style, " ").concat(suggestionConfig.border.color, ";\n      ");
        } else {
          suggestionBorder = "\n        border-radius: 16px;\n        border:2px solid black;\n      ";
        }
        var suggestionFontStyling = "";
        suggestionFontStyling = "\n      font-size:".concat(suggestionConfig.font.size, "px;\n      font-family:").concat(suggestionConfig.font.family, ";\n      font-style:").concat(suggestionConfig.font.style, ";\n      font-weight:").concat(suggestionConfig.font.weight, ";\n    ");
        var suggestionElementStyling = "";
        suggestionConfig.text.forEach(function (element, ind) {
          suggestionElementStyling += "\n      .apxor-survey-nps-qands-".concat(qandsIndex, "-").concat(i, "-suggestion-").concat(ind, "-").concat(_this9.cssPostFix, "{\n        color:").concat(suggestionConfig.color_inactive, ";\n        background:").concat(suggestionConfig.bg_color_inactive, ";\n        ").concat(suggestionPadding, ";\n        ").concat(suggestionMargin, ";\n        ").concat(suggestionBorder, ";\n        ").concat(suggestionFontStyling, ";\n      }\n      .apxor-survey-nps-qands-").concat(qandsIndex, "-").concat(i, "-suggestion-").concat(ind, "-selected-").concat(_this9.cssPostFix, "{\n        background:").concat(suggestionConfig.bg_color_active, "!important;\n        color:").concat(suggestionConfig.color_active, " !important;\n      }");
        });
        var suggestionElementsStyling = "\n    ".concat(suggestionElementStyling, ";\n    ").replaceAll("\n", "").replace(/[\s]{2,999}/g, "");
        var styleNode = document.createElement("style");
        styleNode.innerHTML = suggestionElementsStyling;
        this.overlayElement.appendChild(styleNode);
        return suggestionElementsStyling;
      }
    }, {
      key: "getTextAreaNodeStyles",
      value: function getTextAreaNodeStyles(answerConfig) {
        var desc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
        var marginForTextAreaContainer = "";
        if (answerConfig.enable_margin && desc !== "qands") {
          marginForTextAreaContainer = "\n      margin:".concat(answerConfig.margin.top, "px ").concat(answerConfig.margin.right, "px ").concat(answerConfig.margin.bottom, "px ").concat(answerConfig.margin.left, "px\n      ");
        }
        var paddingForTextAreaContent = "";
        if (answerConfig.enable_padding) {
          paddingForTextAreaContent = "\n      padding:".concat(answerConfig.padding.top, "px ").concat(answerConfig.padding.right, "px ").concat(answerConfig.padding.bottom, "px ").concat(answerConfig.padding.left, "px\n      ");
        }
        var borderForTextAreaContent = "";
        if (answerConfig.input_text.enable_border) {
          borderForTextAreaContent = "\n      border:".concat(answerConfig.input_text.border.width, "px ").concat(answerConfig.input_text.border.style, " ").concat(answerConfig.input_text.border.color, ";\n      border-radius:").concat(answerConfig.input_text.border.radius, "px;\n      ");
        }
        var fontStyles = "";
        if (answerConfig !== null && answerConfig !== void 0 && answerConfig.font) {
          fontStyles = "\n        font-size:".concat(answerConfig.font.size, "px;\n        font-family:").concat(answerConfig.font.family, ";\n        font-style:").concat(answerConfig.font.style, ";\n        font-weight:").concat(answerConfig.font.weight, ";\n      ");
        }
        var placeholderStyles = "";
        if (answerConfig.input_text.enable_placeholder) {
          placeholderStyles = "\n      color:".concat(answerConfig.input_text.placeholder.color, ";");
        }
        var textAreaContainerStyle = "\n      .apxor-survey-".concat(desc, "-textarea-container").concat(this.cssPostFix, "{\n        display:flex;\n        align-items:center;\n        position:relative;\n        ").concat(marginForTextAreaContainer, ";\n        -webkit-user-select: none;\n        -moz-user-select: none;\n        -ms-user-select: none;\n        user-select: none;\n      }\n      .apxor-survey-").concat(desc, "-textarea-content").concat(this.cssPostFix, "{\n        width:100%;\n        background-color:").concat(answerConfig.input_text.background_color, ";\n        color:").concat(answerConfig.input_text.text_color, ";\n        ").concat(fontStyles, ";\n        ").concat(paddingForTextAreaContent, ";\n        ").concat(borderForTextAreaContent, ";\n      }\n      .apxor-survey-").concat(desc, "-textarea-content").concat(this.cssPostFix, "::placeholder{\n        ").concat(placeholderStyles, ";\n      }\n    ").replaceAll("\n", "").replace(/[\s]{2,999}/g, "");
        var styleNode = document.createElement("style");
        styleNode.innerHTML = textAreaContainerStyle;
        this.overlayElement.appendChild(styleNode);
        return textAreaContainerStyle;
      }
    }, {
      key: "getTextAreaNode",
      value: function getTextAreaNode(inputConfig, inputData) {
        var desc = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "";
        if (Object.keys(inputConfig).length === 0) {
          return;
        }
        var max_characters = inputConfig.max_characters;
        var _inputConfig$placehol = inputConfig.placeholder,
          text = _inputConfig$placehol.text;
          _inputConfig$placehol.color;
        var textAreaContainer = document.createElement("div");
        textAreaContainer.classList.add("apxor-survey-".concat(desc, "-textarea-container").concat(this.cssPostFix));
        var textAreaNode = document.createElement("textarea");
        textAreaNode.classList.add("apxor-survey-".concat(desc, "-textarea-content").concat(this.cssPostFix));
        textAreaNode.setAttribute("placeholder", text);
        textAreaNode.setAttribute("maxlength", max_characters);
        textAreaNode.classList.add("apxor-survey-".concat(desc, "-textarea-content").concat(this.cssPostFix, "::placeholder"));
        if (inputData !== "" && inputData.trim() !== "") {
          textAreaNode.innerText = inputData;
        }
        textAreaContainer.appendChild(textAreaNode);
        return textAreaContainer;
      }
    }, {
      key: "_setCloseButton",
      value: function _setCloseButton(CloseIconConfig) {
        var _this10 = this;
        var desc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
        var closeButton = document.createElement("div");
        // Close button SVG is decided based on the type of the button in the config.
        if (CloseIconConfig.type === CLOSE_BUTTON_STYLE.NORMAL) {
          closeButton.innerHTML = getCloseSVG(CloseIconConfig.width, CloseIconConfig.height, CloseIconConfig.color);
        } else if (CloseIconConfig.type === CLOSE_BUTTON_STYLE.FILL) {
          if (CloseIconConfig.shape === "circle") {
            closeButton.innerHTML = getCloseWithCircleSVG(CloseIconConfig.width, CloseIconConfig.height, CloseIconConfig.fill_color, CloseIconConfig.color);
          } else {
            closeButton.innerHTML = getCloseWithRectangleSVG(CloseIconConfig.width, CloseIconConfig.height, CloseIconConfig.fill_color, CloseIconConfig.color);
          }
        } else {
          closeButton.innerHTML = "<img src=\"".concat(CloseIconConfig.path, "\" width=\"").concat(CloseIconConfig.width, "px\" height=\"").concat(CloseIconConfig.height, "px\"></img>");
        }
        closeButton.classList.add("apxor-".concat(desc, "close-button").concat(this.cssPostFix));
        closeButton.addEventListener("click", function () {
          document.body.removeChild(_this10.overlayElement);
          _this10.closeCallback();
          if (_this10.enable_survey_request) {
            _this10._logSurveyAppEvent("apx_survey_dialog_close_icon_clicked", {
              apx_survey_id: _this10.configId,
              apx_survey_name: _this10.name,
              apx_survey_type: true,
              apx_time_to_complete: 200
            });
          } else {
            _this10._logSurveyAppEvent("apx_survey_close_button_clicked", {
              apx_survey_id: _this10.configId,
              apx_survey_name: _this10.name,
              apx_survey_type: true,
              apx_time_to_complete: 200
            });
          }
          _this10._logSurveyQuestionEvent(_this10.index);
          _this10._submitSurveyResponses(false);
        });
        return closeButton;
      }
    }, {
      key: "_setBackButton",
      value: function _setBackButton() {
        var _this11 = this;
        if (this.enable_header && this.header.enable_back_button) {
          var backButton = document.createElement("div");
          if (this.header.backbutton.type === BACK_BUTTON_STYLE.NORMAL) {
            backButton.innerHTML = getBackSVG(this.header.backbutton.width, this.header.backbutton.height, this.header.backbutton.color);
          } else if (this.header.backbutton.type === BACK_BUTTON_STYLE.FILL) {
            backButton.innerHTML = getFilledBackArrowSvg(this.header.backbutton.width, this.header.backbutton.height, this.header.backbutton.fill_color);
          } else {
            backButton.innerHTML = "<img src=\"".concat(this.header.backbutton.path, "\" width=\"").concat(this.header.backbutton.width, "px\" height=\"").concat(this.header.backbutton.height, "px\"></img>");
          }
          backButton.classList.add("apxor-back-button".concat(this.cssPostFix));
          backButton.addEventListener("click", function () {
            document.body.removeChild(_this11.overlayElement);
            _this11._logSurveyAppEvent("apx_survey_back_button_clicked", {
              apx_question_id: _this11.QandAArray[_this11.index].question.id,
              apx_question_name: "",
              apx_question_type: _this11.QandAArray[_this11.index].answer.answer_mode,
              apx_question_position: _this11.index + 1,
              apx_survey_id: _this11.configId,
              apx_survey_name: _this11.name,
              apx_survey_type: true
            });
            _this11._logSurveyQuestionEvent(_this11.index);
            _this11.index = _this11.visitedQuestion.pop();
            if (_this11.index < 0) {
              _this11.closeCallback();
              return;
            }
            _this11.createSurvey();
            return;
          });
          return backButton;
        }
      }
    }, {
      key: "_setProgressBar",
      value: function _setProgressBar() {
        if (this.enable_progressbar) {
          var progressBar = document.createElement("div");
          progressBar.classList.add("apxor-survey-progress-bar".concat(this.cssPostFix));
          var bar = document.createElement("div");
          bar.classList.add("apxor-survey-bar".concat(this.cssPostFix));
          if (this.index <= this.QandAArray.length) {
            bar.style.transform = "translateX(".concat(-(100 - 100 / this.QandAArray.length * (this.index + 1)), "%)");
          } else {
            progressBar.style.visibility = "hidden";
          }
          progressBar.appendChild(bar);
          return progressBar;
        }
      }
    }, {
      key: "_setTitleContent",
      value: function _setTitleContent(titleConfig, about) {
        var id = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "";
        resolveDynamicText(titleConfig);
        var titleElement = document.createElement("div");
        titleElement.classList.add("apxor-survey-".concat(about, "-div").concat(this.cssPostFix));
        titleElement.appendChild(createNewTextElement(titleConfig, id, about));
        return titleElement;
      }
    }, {
      key: "_setDescriptionContent",
      value: function _setDescriptionContent(description, about) {
        var id = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "";
        resolveDynamicText(description);
        var descriptionElement = document.createElement("div");
        descriptionElement.classList.add("apxor-survey-".concat(about, "-div").concat(this.cssPostFix));
        descriptionElement.appendChild(createNewTextElement(description, id, about));
        return descriptionElement;
      }
    }, {
      key: "_createButtonContainer",
      value: function _createButtonContainer() {
        this.bottomButtonContainer = document.createElement("div");
        this.bottomButtonContainer.classList.add("apxor-survey-button-container".concat(this.cssPostFix));
        this._setBottomButtonStyles();
        this.bottomButtonContainer.appendChild(this._setButtons(this.footer.buttons));
        this.surveyContainer.appendChild(this.bottomButtonContainer);
        //this changeButtonColor() defines the color of the buttons while building them.
        this.changeButtonColor(this.anyActiveChoices);
      }
    }, {
      key: "_setButtons",
      value: function _setButtons(buttonsConfig) {
        var _this12 = this;
        this.buttonColorObject = {};
        buttonsConfig.forEach(function (buttonConfig, ind) {
          _this12.buttonColorObject[buttonConfig.action.type] = {
            active_color: buttonConfig.active_color,
            inactive_color: buttonConfig.inactive_color
          };
        });
        var Skip_Callback = function Skip_Callback(id, action) {
          _this12.visitedQuestion.push(_this12.index);
          document.body.removeChild(_this12.overlayElement);
          _this12._logSurveyAppEvent("apx_survey_skip_button_clicked", {
            apx_question_id: _this12.QandAArray[_this12.index].question.id,
            apx_question_name: "",
            apx_question_type: _this12.QandAArray[_this12.index].answer.answer_mode,
            apx_question_position: _this12.index + 1,
            apx_survey_id: _this12.configId,
            apx_survey_name: _this12.name,
            apx_survey_type: true
          });
          _this12._logSurveyQuestionEvent(_this12.index);
          if (_this12.index + 1 >= _this12.QandAArray.length) {
            _this12.closeCallback();
            return;
          }
          _this12.index += 1;
          _this12.createSurvey();
          return;
        };
        var next_Callback = function next_Callback(id, action) {
          _this12.visitedQuestion.push(_this12.index);
          document.body.removeChild(_this12.overlayElement);
          if (!_this12.survey.is_response_based_survey) {
            _this12._logSurveyQuestionEvent(_this12.index);
            if (_this12.index === _this12.QandAArray.length - 1) {
              // Send the response to server
              _this12.closeCallback();
              _this12._submitSurveyResponses(true);
            } else {
              // Display next question
              _this12.index += 1;
              _this12.createSurvey();
            }
          } else {
            _this12._logSurveyQuestionEvent(_this12.index);
            _this12.index = _this12._getNextQuestionByResponseBasedSurvey() ? _this12.index : _this12.index + 1;
            if (_this12.index === _this12.QandAArray.length) {
              _this12.closeCallback();
              _this12._submitSurveyResponses(true);
            } else {
              _this12.createSurvey();
            }
          }
        };
        var prev_Callback = function prev_Callback(id, action) {
          document.body.removeChild(_this12.overlayElement);
          _this12._logSurveyAppEvent("apx_survey_prev_button_clicked", {
            apx_question_id: _this12.QandAArray[_this12.index].question.id,
            apx_question_name: "",
            apx_question_type: _this12.QandAArray[_this12.index].answer.answer_mode,
            apx_question_position: _this12.index + 1,
            apx_survey_id: _this12.configId,
            apx_survey_name: _this12.name,
            apx_survey_type: true
          });
          _this12._logSurveyQuestionEvent(_this12.index);
          _this12.index = _this12.visitedQuestion.pop();
          if (_this12.index < 0) {
            _this12.closeCallback();
            return;
          }
          _this12.createSurvey();
          return;
        };
        var yes_Callback = function yes_Callback(id, action) {
          if (_this12.enable_survey_request) {
            _this12._logSurveyAppEvent("apx_survey_dialog_yes_clicked", {
              apx_survey_id: _this12.configId,
              apx_survey_name: _this12.name,
              apx_survey_type: true
            });
            document.body.removeChild(_this12.overlayElement);
            _this12.enable_survey_request = false;
            _this12.createSurvey();
          } else {
            _this12.visitedQuestion.push(_this12.index);
            document.body.removeChild(_this12.overlayElement);
            if (_this12.index + 1 >= _this12.QandAArray.length) {
              _this12.closeCallback();
              return;
            }
            _this12.index += 1;
            _this12.createSurvey();
          }
        };
        var no_Callback = function no_Callback(id, action) {
          if (_this12.enable_survey_request) {
            _this12._logSurveyAppEvent("apx_survey_dialog_no_clicked", {
              apx_survey_id: _this12.configId,
              apx_survey_name: _this12.name,
              apx_survey_type: true
            });
            document.body.removeChild(_this12.overlayElement);
            _this12.closeCallback();
            _this12.enable_survey_request = false;
          } else {
            document.body.removeChild(_this12.overlayElement);
            _this12.closeCallback();
          }
        };
        var dismiss_Callback = function dismiss_Callback(id, action) {
          document.body.removeChild(_this12.overlayElement);
          _this12.closeCallback();
        };
        var actionCallback = function actionCallback(id, action) {
          if (action === "next") {
            next_Callback();
          } else if (action === "prev") {
            prev_Callback();
          } else if (action === "submit") {
            next_Callback();
          } else if (action === "skip") {
            Skip_Callback();
          } else if (action === "yes") {
            yes_Callback();
          } else if (action === "no") {
            no_Callback();
          } else {
            dismiss_Callback();
          }
        };
        var actionHandler = {
          complete: actionCallback,
          _isCancelled: false,
          action: ""
        };
        var buttonsDirection = this.enable_survey_request ? "vertical" : this.direction.buttons;
        var Buttons = generateButtonsBlock(this.configId, this.name, {}, EVENT_PREFIX.SURVEY, buttonsConfig, buttonsDirection, "", "survey_bottom", actionHandler, false, this.uis, 0);
        return Buttons;
      }
    }, {
      key: "_getNextQuestionByResponseBasedSurvey",
      value: function _getNextQuestionByResponseBasedSurvey() {
        var _this$QandAArray$this5,
          _answer$textBasedQues,
          _this$QandAArray$this6,
          _this13 = this;
        var answer = this._getAnswerForQuestion(this.index);
        var answer_mode = (_this$QandAArray$this5 = this.QandAArray[this.index]) === null || _this$QandAArray$this5 === void 0 || (_this$QandAArray$this5 = _this$QandAArray$this5.answer) === null || _this$QandAArray$this5 === void 0 ? void 0 : _this$QandAArray$this5.answer_mode;
        var selectedOption = answer.answers.sort();
        var shortAnswer = [];
        shortAnswer.push((answer === null || answer === void 0 || (_answer$textBasedQues = answer.textBasedQuestionAnswers[0]) === null || _answer$textBasedQues === void 0 ? void 0 : _answer$textBasedQues.id) || "");
        var paths = (_this$QandAArray$this6 = this.QandAArray[this.index].question) === null || _this$QandAArray$this6 === void 0 ? void 0 : _this$QandAArray$this6.paths;
        var flag = false;
        switch (answer_mode) {
          case "single_choice":
          case "multi_choice":
            if (paths) {
              Object.keys(paths).forEach(function (key) {
                if (flag) {
                  return;
                }
                var questionPaths = paths[key];
                questionPaths.forEach(function (element) {
                  if (element.length === selectedOption.length && JSON.stringify(element.sort()) === JSON.stringify(selectedOption)) {
                    flag = true;
                    if (key === "-1") {
                      _this13.index = _this13.QandAArray.length;
                    } else {
                      _this13.index = _this13.questionids.indexOf(parseInt(key));
                    }
                    return;
                  }
                });
              });
            }
            break;
          case "text":
            if (paths) {
              Object.keys(paths).forEach(function (key) {
                if (flag) {
                  return;
                }
                var questionPaths = paths[key];
                questionPaths.forEach(function (element) {
                  if (element.length === shortAnswer.length && JSON.stringify(element.sort()) === JSON.stringify(shortAnswer)) {
                    flag = true;
                    if (key === "-1") {
                      _this13.index = _this13.QandAArray.length;
                    } else {
                      _this13.index = _this13.questionids.indexOf(parseInt(key));
                    }
                    return;
                  }
                });
              });
            }
            break;
        }
        return flag;
      }
    }, {
      key: "_enableSuccessMessageContainer",
      value: function _enableSuccessMessageContainer() {
        var _this14 = this;
        if (!this.enable_success_message) {
          return;
        }
        this._setBackgroundOverlay();
        this._setStyles();
        var successContainer = document.createElement("div");
        successContainer.classList.add("apxor-survey-container".concat(this.cssPostFix));
        successContainer.style.cssText = "height:".concat(this.height, "%;display:flex;flex-direction:column;justify-content:center;align-items:center;");
        // const successImage = document.createElement("div");
        // successImage.classList.add("apxor-success-icon-content");
        // successImage.innerHTML = `
        //   <div>
        //     ${getCheckMarkSVG(64, 64, "#A62020")}
        //   </div>
        // `;
        if (this.success_message.enable_icon) {
          var iconDiv = document.createElement("div");
          iconDiv.classList.add("apxor-success-icon-container".concat(this.cssPostFix));
          var iconElement = document.createElement("img");
          iconElement.src = this.success_message.icon.path;
          iconElement.classList.add("apxor-success-icon-content".concat(this.cssPostFix));
          iconDiv.appendChild(iconElement);
          successContainer.appendChild(iconDiv);
        }
        if (this.success_message.enable_description) {
          this._getDescriptionStyles(this.success_message.description, "success-message-description");
          successContainer.appendChild(this._setDescriptionContent(this.success_message.description, "success-message-description", this.index));
        }
        this.overlayElement.appendChild(successContainer);
        setTimeout(function () {
          document.body.removeChild(_this14.overlayElement);
        }, 4000);
      }
    }]);
    return NewSurveys;
  }();

  var STYLISED_EMOJI_5 = ["<svg width=\"35\" height=\"35\" viewBox=\"0 0 23 22\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n    <path d=\"M0 10.9046C0 4.88216 4.88188 3.24249e-05 10.9049 3.24249e-05C16.9267 3.24249e-05 21.8085 4.88216 21.8085 10.9046C21.8085 16.9269 16.9267 21.809 10.9049 21.809C4.88188 21.809 0 16.9269 0 10.9046Z\" fill=\"#E5510A\"/>\n    <path d=\"M7.6916 8.87557C7.6916 9.62346 7.33083 10.2299 6.88691 10.2299C6.44426 10.2299 6.0835 9.62346 6.0835 8.87557C6.0835 8.12768 6.44426 7.52116 6.88691 7.52116C7.33083 7.52116 7.6916 8.12768 7.6916 8.87557Z\" fill=\"black\"/>\n    <path d=\"M15.7255 8.87557C15.7255 9.62346 15.366 10.2299 14.9221 10.2299C14.4782 10.2299 14.1187 9.62346 14.1187 8.87557C14.1187 8.12768 14.4782 7.52116 14.9221 7.52116C15.366 7.52116 15.7255 8.12768 15.7255 8.87557Z\" fill=\"black\"/>\n    <path d=\"M9.15239 6.99092L8.42062 7.72205L5.98096 5.28226L6.71273 4.55126L9.15239 6.99092Z\" fill=\"black\"/>\n    <path d=\"M13.3882 7.72205L12.6577 6.99092L15.0974 4.55126L15.8279 5.28226L13.3882 7.72205Z\" fill=\"black\"/>\n    <path d=\"M7 16.4995C8 12.4995 13 10.4995 15 16.4998\" stroke=\"black\" stroke-linecap=\"round\"/>\n    </svg>", "<svg width=\"35\" height=\"35\" viewBox=\"0 0 23 22\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n    <path d=\"M0.808594 10.9046C0.808594 4.88216 5.69048 3.24249e-05 11.7135 3.24249e-05C17.7353 3.24249e-05 22.6171 4.88216 22.6171 10.9046C22.6171 16.9269 17.7353 21.809 11.7135 21.809C5.69048 21.809 0.808594 16.9269 0.808594 10.9046Z\" fill=\"#EA731D\"/>\n    <path d=\"M8.5002 8.87557C8.5002 9.62346 8.13942 10.2299 7.6955 10.2299C7.25286 10.2299 6.89209 9.62346 6.89209 8.87557C6.89209 8.12768 7.25286 7.52116 7.6955 7.52116C8.13942 7.52116 8.5002 8.12768 8.5002 8.87557Z\" fill=\"black\"/>\n    <path d=\"M16.5341 8.87557C16.5341 9.62346 16.1746 10.2299 15.7307 10.2299C15.2867 10.2299 14.9272 9.62346 14.9272 8.87557C14.9272 8.12768 15.2867 7.52116 15.7307 7.52116C16.1746 7.52116 16.5341 8.12768 16.5341 8.87557Z\" fill=\"black\"/>\n    <path d=\"M7.80859 16.4998C8.80859 12.4998 13.8086 10.4997 15.8086 16.5\" stroke=\"black\" stroke-linecap=\"round\"/>\n    </svg>", "<svg width=\"35\" height=\"35\" viewBox=\"0 0 23 22\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n    <path d=\"M0.234375 10.9046C0.234375 4.88216 5.11626 3.24249e-05 11.1393 3.24249e-05C17.161 3.24249e-05 22.0429 4.88216 22.0429 10.9046C22.0429 16.9269 17.161 21.809 11.1393 21.809C5.11626 21.809 0.234375 16.9269 0.234375 10.9046Z\" fill=\"#F8C94F\"/>\n    <path d=\"M7.92598 8.87557C7.92598 9.62346 7.5652 10.2299 7.12128 10.2299C6.67864 10.2299 6.31787 9.62346 6.31787 8.87557C6.31787 8.12768 6.67864 7.52116 7.12128 7.52116C7.5652 7.52116 7.92598 8.12768 7.92598 8.87557Z\" fill=\"black\"/>\n    <path d=\"M15.9599 8.87557C15.9599 9.62346 15.6004 10.2299 15.1564 10.2299C14.7125 10.2299 14.353 9.62346 14.353 8.87557C14.353 8.12768 14.7125 7.52116 15.1564 7.52116C15.6004 7.52116 15.9599 8.12768 15.9599 8.87557Z\" fill=\"black\"/>\n    <path d=\"M7.73438 15.5002C9.73438 15.4999 11.7344 15.4997 14.7344 15.5\" stroke=\"black\" stroke-linecap=\"round\"/>\n    </svg>", "<svg width=\"35\" height=\"35\" viewBox=\"0 0 23 22\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n    <path d=\"M0.46875 10.9046C0.46875 4.88216 5.35063 3.24249e-05 11.3737 3.24249e-05C17.3954 3.24249e-05 22.2773 4.88216 22.2773 10.9046C22.2773 16.9269 17.3954 21.809 11.3737 21.809C5.35063 21.809 0.46875 16.9269 0.46875 10.9046Z\" fill=\"#A3CF6A\"/>\n    <path d=\"M8.16035 8.87557C8.16035 9.62346 7.79958 10.2299 7.35566 10.2299C6.91301 10.2299 6.55225 9.62346 6.55225 8.87557C6.55225 8.12768 6.91301 7.52116 7.35566 7.52116C7.79958 7.52116 8.16035 8.12768 8.16035 8.87557Z\" fill=\"black\"/>\n    <path d=\"M16.1942 8.87557C16.1942 9.62346 15.8347 10.2299 15.3908 10.2299C14.9469 10.2299 14.5874 9.62346 14.5874 8.87557C14.5874 8.12768 14.9469 7.52116 15.3908 7.52116C15.8347 7.52116 16.1942 8.12768 16.1942 8.87557Z\" fill=\"black\"/>\n    <path d=\"M14.9688 13.375C14.4688 17.5002 7.96875 17.5003 7.46875 13.3751L14.9688 13.375Z\" fill=\"black\" stroke=\"black\" stroke-linecap=\"round\"/>\n    </svg>\n    ", "<svg width=\"35\" height=\"35\" viewBox=\"0 0 23 22\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n    <path d=\"M0.234375 10.9042C0.234375 4.8818 5.11626 -0.000333786 11.1393 -0.000333786C17.161 -0.000333786 22.0429 4.8818 22.0429 10.9042C22.0429 16.9266 17.161 21.8086 11.1393 21.8086C5.11626 21.8086 0.234375 16.9266 0.234375 10.9042Z\" fill=\"#7BB65C\"/>\n    <path d=\"M14.7344 13.3748C14.2344 17.5 7.73438 17.5 7.23438 13.3749L14.7344 13.3748Z\" fill=\"#646A6E\" stroke=\"#646A6E\" stroke-linecap=\"round\"/>\n    <path d=\"M9.63644 8.10736L9.63732 8.09652C9.63732 7.41374 9.14286 6.78855 8.40031 6.78855C7.81043 6.78855 7.46866 7.21257 7.35155 7.60952C7.23531 7.21257 6.89266 6.78855 6.30278 6.78855C5.56023 6.78855 5.06665 7.41374 5.06665 8.09652V8.10736C5.06318 8.25596 5.06665 9.76759 7.35068 10.9997V11L7.35155 10.9998V11L7.35241 10.9998V11V10.9997C9.63731 9.76759 9.64078 8.25596 9.63644 8.10736Z\" fill=\"#646A6E\"/>\n    <path d=\"M17.3357 8.10736V8.09652C17.3357 7.41374 16.8421 6.78855 16.0995 6.78855C15.5097 6.78855 15.1679 7.21257 15.0508 7.60952C14.9345 7.21257 14.5919 6.78855 14.002 6.78855C13.2595 6.78855 12.7659 7.41374 12.7659 8.09652V8.10736C12.7624 8.25596 12.7659 9.76759 15.0499 10.9997V11L15.0508 10.9998V11L15.0516 10.9998V11V10.9997C17.3365 9.76759 17.34 8.25596 17.3357 8.10736Z\" fill=\"#646A6E\"/>\n    </svg>"];
  var STYLISED_EMOJI_10 = ["<svg width=\"35\" height=\"35\" viewBox=\"0 0 23 22\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n    <path d=\"M0 10.9046C0 4.88216 4.88188 3.24249e-05 10.9049 3.24249e-05C16.9267 3.24249e-05 21.8085 4.88216 21.8085 10.9046C21.8085 16.9269 16.9267 21.809 10.9049 21.809C4.88188 21.809 0 16.9269 0 10.9046Z\" fill=\"#E5510A\"/>\n    <path d=\"M7.6916 8.87557C7.6916 9.62346 7.33083 10.2299 6.88691 10.2299C6.44426 10.2299 6.0835 9.62346 6.0835 8.87557C6.0835 8.12768 6.44426 7.52116 6.88691 7.52116C7.33083 7.52116 7.6916 8.12768 7.6916 8.87557Z\" fill=\"black\"/>\n    <path d=\"M15.7255 8.87557C15.7255 9.62346 15.366 10.2299 14.9221 10.2299C14.4782 10.2299 14.1187 9.62346 14.1187 8.87557C14.1187 8.12768 14.4782 7.52116 14.9221 7.52116C15.366 7.52116 15.7255 8.12768 15.7255 8.87557Z\" fill=\"black\"/>\n    <path d=\"M9.15239 6.99092L8.42062 7.72205L5.98096 5.28226L6.71273 4.55126L9.15239 6.99092Z\" fill=\"black\"/>\n    <path d=\"M13.3882 7.72205L12.6577 6.99092L15.0974 4.55126L15.8279 5.28226L13.3882 7.72205Z\" fill=\"black\"/>\n    <path d=\"M7 16.4995C8 12.4995 13 10.4995 15 16.4998\" stroke=\"black\" stroke-linecap=\"round\"/>\n    </svg>", "<svg width=\"35\" height=\"35\" viewBox=\"0 0 23 22\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n    <path d=\"M0.808594 10.9046C0.808594 4.88216 5.69048 3.24249e-05 11.7135 3.24249e-05C17.7353 3.24249e-05 22.6171 4.88216 22.6171 10.9046C22.6171 16.9269 17.7353 21.809 11.7135 21.809C5.69048 21.809 0.808594 16.9269 0.808594 10.9046Z\" fill=\"#EA731D\"/>\n    <path d=\"M8.5002 8.87557C8.5002 9.62346 8.13942 10.2299 7.6955 10.2299C7.25286 10.2299 6.89209 9.62346 6.89209 8.87557C6.89209 8.12768 7.25286 7.52116 7.6955 7.52116C8.13942 7.52116 8.5002 8.12768 8.5002 8.87557Z\" fill=\"black\"/>\n    <path d=\"M16.5341 8.87557C16.5341 9.62346 16.1746 10.2299 15.7307 10.2299C15.2867 10.2299 14.9272 9.62346 14.9272 8.87557C14.9272 8.12768 15.2867 7.52116 15.7307 7.52116C16.1746 7.52116 16.5341 8.12768 16.5341 8.87557Z\" fill=\"black\"/>\n    <path d=\"M7.80859 16.4998C8.80859 12.4998 13.8086 10.4997 15.8086 16.5\" stroke=\"black\" stroke-linecap=\"round\"/>\n    </svg>", "<svg width=\"35\" height=\"35\" viewBox=\"0 0 23 22\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n    <path d=\"M0.617188 10.9046C0.617188 4.88216 5.49907 3.24249e-05 11.5221 3.24249e-05C17.5439 3.24249e-05 22.4257 4.88216 22.4257 10.9046C22.4257 16.9269 17.5439 21.809 11.5221 21.809C5.49907 21.809 0.617188 16.9269 0.617188 10.9046Z\" fill=\"#EA8F4D\"/>\n    <path d=\"M8.30879 8.87557C8.30879 9.62346 7.94802 10.2299 7.50409 10.2299C7.06145 10.2299 6.70068 9.62346 6.70068 8.87557C6.70068 8.12768 7.06145 7.52116 7.50409 7.52116C7.94802 7.52116 8.30879 8.12768 8.30879 8.87557Z\" fill=\"black\"/>\n    <path d=\"M16.3427 8.87557C16.3427 9.62346 15.9832 10.2299 15.5393 10.2299C15.0953 10.2299 14.7358 9.62346 14.7358 8.87557C14.7358 8.12768 15.0953 7.52116 15.5393 7.52116C15.9832 7.52116 16.3427 8.12768 16.3427 8.87557Z\" fill=\"black\"/>\n    <path d=\"M7.61719 15.4999C8.95052 13.0405 13.1172 11.9999 15.6172 15.5\" stroke=\"black\" stroke-linecap=\"round\"/>\n    </svg>", "<svg width=\"35\" height=\"35\" viewBox=\"0 0 23 22\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n    <path d=\"M0.425781 10.9046C0.425781 4.88216 5.30767 3.24249e-05 11.3307 3.24249e-05C17.3524 3.24249e-05 22.2343 4.88216 22.2343 10.9046C22.2343 16.9269 17.3524 21.809 11.3307 21.809C5.30767 21.809 0.425781 16.9269 0.425781 10.9046Z\" fill=\"#F1B052\"/>\n    <path d=\"M8.11738 8.87557C8.11738 9.62346 7.75661 10.2299 7.31269 10.2299C6.87004 10.2299 6.50928 9.62346 6.50928 8.87557C6.50928 8.12768 6.87004 7.52116 7.31269 7.52116C7.75661 7.52116 8.11738 8.12768 8.11738 8.87557Z\" fill=\"black\"/>\n    <path d=\"M16.1513 8.87557C16.1513 9.62346 15.7918 10.2299 15.3479 10.2299C14.9039 10.2299 14.5444 9.62346 14.5444 8.87557C14.5444 8.12768 14.9039 7.52116 15.3479 7.52116C15.7918 7.52116 16.1513 8.12768 16.1513 8.87557Z\" fill=\"black\"/>\n    <path d=\"M8.42578 15.5002C9.92578 14.0001 12.4258 14.0001 13.9258 15.5001\" stroke=\"black\" stroke-linecap=\"round\"/>\n    </svg>", "<svg width=\"35\" height=\"35\" viewBox=\"0 0 23 22\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n    <path d=\"M0.234375 10.9046C0.234375 4.88216 5.11626 3.24249e-05 11.1393 3.24249e-05C17.161 3.24249e-05 22.0429 4.88216 22.0429 10.9046C22.0429 16.9269 17.161 21.809 11.1393 21.809C5.11626 21.809 0.234375 16.9269 0.234375 10.9046Z\" fill=\"#F8C94F\"/>\n    <path d=\"M7.92598 8.87557C7.92598 9.62346 7.5652 10.2299 7.12128 10.2299C6.67864 10.2299 6.31787 9.62346 6.31787 8.87557C6.31787 8.12768 6.67864 7.52116 7.12128 7.52116C7.5652 7.52116 7.92598 8.12768 7.92598 8.87557Z\" fill=\"black\"/>\n    <path d=\"M15.9599 8.87557C15.9599 9.62346 15.6004 10.2299 15.1564 10.2299C14.7125 10.2299 14.353 9.62346 14.353 8.87557C14.353 8.12768 14.7125 7.52116 15.1564 7.52116C15.6004 7.52116 15.9599 8.12768 15.9599 8.87557Z\" fill=\"black\"/>\n    <path d=\"M7.73438 15.5002C9.73438 15.4999 11.7344 15.4997 14.7344 15.5\" stroke=\"black\" stroke-linecap=\"round\"/>\n    </svg>", "<svg width=\"35\" height=\"35\" viewBox=\"0 0 23 22\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n    <path d=\"M0 10.9046C0 4.88216 4.88188 3.20353e-05 10.9049 3.20353e-05C16.9267 3.20353e-05 21.8085 4.88216 21.8085 10.9046C21.8085 16.9269 16.9267 21.809 10.9049 21.809C4.88188 21.809 0 16.9269 0 10.9046Z\" fill=\"#F8C94F\"/>\n    <path d=\"M7.6916 8.87557C7.6916 9.62346 7.33083 10.2299 6.88691 10.2299C6.44426 10.2299 6.0835 9.62346 6.0835 8.87557C6.0835 8.12768 6.44426 7.52116 6.88691 7.52116C7.33083 7.52116 7.6916 8.12768 7.6916 8.87557Z\" fill=\"black\"/>\n    <path d=\"M15.7255 8.87557C15.7255 9.62346 15.366 10.2299 14.9221 10.2299C14.4782 10.2299 14.1187 9.62346 14.1187 8.87557C14.1187 8.12768 14.4782 7.52116 14.9221 7.52116C15.366 7.52116 15.7255 8.12768 15.7255 8.87557Z\" fill=\"black\"/>\n    </svg>", "<svg width=\"35\" height=\"35\" viewBox=\"0 0 23 22\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n    <path d=\"M0.0429688 10.9046C0.0429688 4.88216 4.92485 3.24249e-05 10.9479 3.24249e-05C16.9696 3.24249e-05 21.8515 4.88216 21.8515 10.9046C21.8515 16.9269 16.9696 21.809 10.9479 21.809C4.92485 21.809 0.0429688 16.9269 0.0429688 10.9046Z\" fill=\"#F6DE4F\"/>\n    <path d=\"M7.73457 8.87557C7.73457 9.62346 7.3738 10.2299 6.92987 10.2299C6.48723 10.2299 6.12646 9.62346 6.12646 8.87557C6.12646 8.12768 6.48723 7.52116 6.92987 7.52116C7.3738 7.52116 7.73457 8.12768 7.73457 8.87557Z\" fill=\"black\"/>\n    <path d=\"M15.7685 8.87557C15.7685 9.62346 15.409 10.2299 14.965 10.2299C14.5211 10.2299 14.1616 9.62346 14.1616 8.87557C14.1616 8.12768 14.5211 7.52116 14.965 7.52116C15.409 7.52116 15.7685 8.12768 15.7685 8.87557Z\" fill=\"black\"/>\n    <path d=\"M13.543 14.3751C12.043 15.8751 9.54297 15.8751 8.04297 14.3751\" stroke=\"black\" stroke-linecap=\"round\"/>\n    </svg>", "<svg width=\"35\" height=\"35\" viewBox=\"0 0 23 22\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n    <path d=\"M0.851562 10.9046C0.851562 4.88216 5.73345 3.24249e-05 11.7565 3.24249e-05C17.7782 3.24249e-05 22.6601 4.88216 22.6601 10.9046C22.6601 16.9269 17.7782 21.809 11.7565 21.809C5.73345 21.809 0.851562 16.9269 0.851562 10.9046Z\" fill=\"#D7D55A\"/>\n    <path d=\"M8.54316 8.87557C8.54316 9.62346 8.18239 10.2299 7.73847 10.2299C7.29582 10.2299 6.93506 9.62346 6.93506 8.87557C6.93506 8.12768 7.29582 7.52116 7.73847 7.52116C8.18239 7.52116 8.54316 8.12768 8.54316 8.87557Z\" fill=\"black\"/>\n    <path d=\"M16.577 8.87557C16.577 9.62346 16.2176 10.2299 15.7736 10.2299C15.3297 10.2299 14.9702 9.62346 14.9702 8.87557C14.9702 8.12768 15.3297 7.52116 15.7736 7.52116C16.2176 7.52116 16.577 8.12768 16.577 8.87557Z\" fill=\"black\"/>\n    <path d=\"M15.3516 14.3749C13.8516 17.0001 9.85156 17.0002 7.85156 14.375\" stroke=\"black\" stroke-linecap=\"round\"/>\n    </svg>", "<svg width=\"35\" height=\"35\" viewBox=\"0 0 23 22\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n    <path d=\"M0.660156 10.9046C0.660156 4.88216 5.54204 3.24249e-05 11.5651 3.24249e-05C17.5868 3.24249e-05 22.4687 4.88216 22.4687 10.9046C22.4687 16.9269 17.5868 21.809 11.5651 21.809C5.54204 21.809 0.660156 16.9269 0.660156 10.9046Z\" fill=\"#B7CF6A\"/>\n    <path d=\"M8.35176 8.87557C8.35176 9.62346 7.99099 10.2299 7.54706 10.2299C7.10442 10.2299 6.74365 9.62346 6.74365 8.87557C6.74365 8.12768 7.10442 7.52116 7.54706 7.52116C7.99099 7.52116 8.35176 8.12768 8.35176 8.87557Z\" fill=\"black\"/>\n    <path d=\"M16.3856 8.87557C16.3856 9.62346 16.0262 10.2299 15.5822 10.2299C15.1383 10.2299 14.7788 9.62346 14.7788 8.87557C14.7788 8.12768 15.1383 7.52116 15.5822 7.52116C16.0262 7.52116 16.3856 8.12768 16.3856 8.87557Z\" fill=\"black\"/>\n    <path d=\"M15.1602 13.375C14.6602 17.5002 8.16016 17.5003 7.66016 13.3751\" stroke=\"black\" stroke-linecap=\"round\"/>\n    </svg>", "<svg width=\"35\" height=\"35\" viewBox=\"0 0 23 22\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n    <path d=\"M0.46875 10.9046C0.46875 4.88216 5.35063 3.24249e-05 11.3737 3.24249e-05C17.3954 3.24249e-05 22.2773 4.88216 22.2773 10.9046C22.2773 16.9269 17.3954 21.809 11.3737 21.809C5.35063 21.809 0.46875 16.9269 0.46875 10.9046Z\" fill=\"#A3CF6A\"/>\n    <path d=\"M8.16035 8.87557C8.16035 9.62346 7.79958 10.2299 7.35566 10.2299C6.91301 10.2299 6.55225 9.62346 6.55225 8.87557C6.55225 8.12768 6.91301 7.52116 7.35566 7.52116C7.79958 7.52116 8.16035 8.12768 8.16035 8.87557Z\" fill=\"black\"/>\n    <path d=\"M16.1942 8.87557C16.1942 9.62346 15.8347 10.2299 15.3908 10.2299C14.9469 10.2299 14.5874 9.62346 14.5874 8.87557C14.5874 8.12768 14.9469 7.52116 15.3908 7.52116C15.8347 7.52116 16.1942 8.12768 16.1942 8.87557Z\" fill=\"black\"/>\n    <path d=\"M14.9688 13.375C14.4688 17.5002 7.96875 17.5003 7.46875 13.3751L14.9688 13.375Z\" fill=\"black\" stroke=\"black\" stroke-linecap=\"round\"/>\n    </svg>", "<svg width=\"35\" height=\"35\" viewBox=\"0 0 23 22\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n    <path d=\"M0 10.9042C0 4.8818 4.88188 -0.000333786 10.9049 -0.000333786C16.9267 -0.000333786 21.8085 4.8818 21.8085 10.9042C21.8085 16.9266 16.9267 21.8086 10.9049 21.8086C4.88188 21.8086 0 16.9266 0 10.9042Z\" fill=\"#7BB65C\"/>\n    <path d=\"M14.5 13.3748C14 17.5 7.5 17.5 7 13.3749L14.5 13.3748Z\" fill=\"#646A6E\" stroke=\"#646A6E\" stroke-linecap=\"round\"/>\n    <path d=\"M9.40207 8.10736L9.40294 8.09652C9.40294 7.41374 8.90848 6.78855 8.16593 6.78855C7.57606 6.78855 7.23428 7.21257 7.11718 7.60952C7.00094 7.21257 6.65828 6.78855 6.06841 6.78855C5.32586 6.78855 4.83227 7.41374 4.83227 8.09652V8.10736C4.8288 8.25596 4.83227 9.76759 7.1163 10.9997V11L7.11718 10.9998V11L7.11804 10.9998V11V10.9997C9.40294 9.76759 9.40641 8.25596 9.40207 8.10736Z\" fill=\"#646A6E\"/>\n    <path d=\"M17.1013 8.10736V8.09652C17.1013 7.41374 16.6077 6.78855 15.8652 6.78855C15.2753 6.78855 14.9335 7.21257 14.8164 7.60952C14.7001 7.21257 14.3575 6.78855 13.7676 6.78855C13.0251 6.78855 12.5315 7.41374 12.5315 8.09652V8.10736C12.528 8.25596 12.5315 9.76759 14.8155 10.9997V11L14.8164 10.9998V11L14.8173 10.9998V11V10.9997C17.1022 9.76759 17.1056 8.25596 17.1013 8.10736Z\" fill=\"#646A6E\"/>\n    </svg>"];
  var STYLISED_EMOJI_GREY_10 = ["<svg width=\"35\" height=\"35\" viewBox=\"0 0 23 22\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n <path d=\"M0 10.9042C0 4.8818 4.88188 -0.000334176 10.9049 -0.000334176C16.9267 -0.000334176 21.8085 4.8818 21.8085 10.9042C21.8085 16.9266 16.9267 21.8086 10.9049 21.8086C4.88188 21.8086 0 16.9266 0 10.9042Z\" fill=\"#D9DCDE\"/>\n <path d=\"M7.69209 8.87521C7.69209 9.6231 7.33132 10.2295 6.88739 10.2295C6.44475 10.2295 6.08398 9.6231 6.08398 8.87521C6.08398 8.12732 6.44475 7.52079 6.88739 7.52079C7.33132 7.52079 7.69209 8.12732 7.69209 8.87521Z\" fill=\"#646A6F\"/>\n <path d=\"M15.726 8.87521C15.726 9.6231 15.3665 10.2295 14.9226 10.2295C14.4786 10.2295 14.1191 9.6231 14.1191 8.87521C14.1191 8.12732 14.4786 7.52079 14.9226 7.52079C15.3665 7.52079 15.726 8.12732 15.726 8.87521Z\" fill=\"#646A6F\"/>\n <path d=\"M9.1519 6.99055L8.42013 7.72168L5.98047 5.28189L6.71224 4.55089L9.1519 6.99055Z\" fill=\"#646A6F\"/>\n <path d=\"M13.3887 7.72168L12.6582 6.99055L15.0979 4.55089L15.8284 5.28189L13.3887 7.72168Z\" fill=\"#646A6F\"/>\n <path d=\"M7 16.4997C8 12.4996 13 10.4996 15 16.4999\" stroke=\"#646A6E\" stroke-linecap=\"round\"/>\n </svg>", "<svg width=\"35\" height=\"35\" viewBox=\"0 0 23 22\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n  <path d=\"M0.808594 10.9042C0.808594 4.8818 5.69048 -0.000334176 11.7135 -0.000334176C17.7353 -0.000334176 22.6171 4.8818 22.6171 10.9042C22.6171 16.9266 17.7353 21.8086 11.7135 21.8086C5.69048 21.8086 0.808594 16.9266 0.808594 10.9042Z\" fill=\"#D9DCDE\"/>\n  <path d=\"M8.50068 8.87521C8.50068 9.6231 8.13991 10.2295 7.69599 10.2295C7.25334 10.2295 6.89258 9.6231 6.89258 8.87521C6.89258 8.12732 7.25334 7.52079 7.69599 7.52079C8.13991 7.52079 8.50068 8.12732 8.50068 8.87521Z\" fill=\"#646A6F\"/>\n  <path d=\"M16.5346 8.87521C16.5346 9.6231 16.1751 10.2295 15.7312 10.2295C15.2872 10.2295 14.9277 9.6231 14.9277 8.87521C14.9277 8.12732 15.2872 7.52079 15.7312 7.52079C16.1751 7.52079 16.5346 8.12732 16.5346 8.87521Z\" fill=\"#646A6F\"/>\n  <path d=\"M7.80859 16.4997C8.80859 12.4996 13.8086 10.4996 15.8086 16.4999\" stroke=\"#646A6E\" stroke-linecap=\"round\"/>\n  </svg>", "<svg width=\"35\" height=\"35\" viewBox=\"0 0 23 22\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n  <path d=\"M0.617188 10.9042C0.617188 4.8818 5.49907 -0.000334176 11.5221 -0.000334176C17.5439 -0.000334176 22.4257 4.8818 22.4257 10.9042C22.4257 16.9266 17.5439 21.8086 11.5221 21.8086C5.49907 21.8086 0.617188 16.9266 0.617188 10.9042Z\" fill=\"#D9DCDE\"/>\n  <path d=\"M8.30928 8.87521C8.30928 9.6231 7.9485 10.2295 7.50458 10.2295C7.06194 10.2295 6.70117 9.6231 6.70117 8.87521C6.70117 8.12732 7.06194 7.52079 7.50458 7.52079C7.9485 7.52079 8.30928 8.12732 8.30928 8.87521Z\" fill=\"#646A6F\"/>\n  <path d=\"M16.3432 8.87521C16.3432 9.6231 15.9837 10.2295 15.5398 10.2295C15.0958 10.2295 14.7363 9.6231 14.7363 8.87521C14.7363 8.12732 15.0958 7.52079 15.5398 7.52079C15.9837 7.52079 16.3432 8.12732 16.3432 8.87521Z\" fill=\"#646A6F\"/>\n  <path d=\"M7.61719 15.4995C8.95052 13.0401 13.1172 11.9996 15.6172 15.4996\" stroke=\"#646A6E\" stroke-linecap=\"round\"/>\n  </svg>", "<svg width=\"35\" height=\"35\" viewBox=\"0 0 23 22\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n  <path d=\"M0.425781 10.9042C0.425781 4.8818 5.30767 -0.000333786 11.3307 -0.000333786C17.3524 -0.000333786 22.2343 4.8818 22.2343 10.9042C22.2343 16.9266 17.3524 21.8086 11.3307 21.8086C5.30767 21.8086 0.425781 16.9266 0.425781 10.9042Z\" fill=\"#D9DCDE\"/>\n  <path d=\"M8.11787 8.87521C8.11787 9.6231 7.7571 10.2295 7.31318 10.2295C6.87053 10.2295 6.50977 9.6231 6.50977 8.87521C6.50977 8.12732 6.87053 7.52079 7.31318 7.52079C7.7571 7.52079 8.11787 8.12732 8.11787 8.87521Z\" fill=\"#646A6F\"/>\n  <path d=\"M16.1518 8.87521C16.1518 9.6231 15.7923 10.2295 15.3483 10.2295C14.9044 10.2295 14.5449 9.6231 14.5449 8.87521C14.5449 8.12732 14.9044 7.52079 15.3483 7.52079C15.7923 7.52079 16.1518 8.12732 16.1518 8.87521Z\" fill=\"#646A6F\"/>\n  <path d=\"M8.42578 15.5001C9.92578 14 12.4258 14 13.9258 15.5\" stroke=\"#646A6E\" stroke-linecap=\"round\"/>\n  </svg>", "<svg width=\"35\" height=\"35\" viewBox=\"0 0 23 22\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n  <path d=\"M0.234375 10.9042C0.234375 4.8818 5.11626 -0.000333786 11.1393 -0.000333786C17.161 -0.000333786 22.0429 4.8818 22.0429 10.9042C22.0429 16.9266 17.161 21.8086 11.1393 21.8086C5.11626 21.8086 0.234375 16.9266 0.234375 10.9042Z\" fill=\"#D9DCDE\"/>\n  <path d=\"M7.92647 8.87521C7.92647 9.6231 7.56569 10.2295 7.12177 10.2295C6.67912 10.2295 6.31836 9.6231 6.31836 8.87521C6.31836 8.12732 6.67912 7.52079 7.12177 7.52079C7.56569 7.52079 7.92647 8.12732 7.92647 8.87521Z\" fill=\"#646A6F\"/>\n  <path d=\"M15.9603 8.87521C15.9603 9.6231 15.6009 10.2295 15.1569 10.2295C14.713 10.2295 14.3535 9.6231 14.3535 8.87521C14.3535 8.12732 14.713 7.52079 15.1569 7.52079C15.6009 7.52079 15.9603 8.12732 15.9603 8.87521Z\" fill=\"#646A6F\"/>\n  <path d=\"M7.73438 15.5003C9.73438 15.5 11.7344 15.4998 14.7344 15.5001\" stroke=\"#646A6E\" stroke-linecap=\"round\"/>\n  </svg>", "<svg width=\"35\" height=\"35\" viewBox=\"0 0 23 22\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n  <path d=\"M0.234375 10.9042C0.234375 4.8818 5.11626 -0.000333786 11.1393 -0.000333786C17.161 -0.000333786 22.0429 4.8818 22.0429 10.9042C22.0429 16.9266 17.161 21.8086 11.1393 21.8086C5.11626 21.8086 0.234375 16.9266 0.234375 10.9042Z\" fill=\"#D9DCDE\"/>\n  <path d=\"M7.92647 8.87521C7.92647 9.6231 7.56569 10.2295 7.12177 10.2295C6.67912 10.2295 6.31836 9.6231 6.31836 8.87521C6.31836 8.12732 6.67912 7.52079 7.12177 7.52079C7.56569 7.52079 7.92647 8.12732 7.92647 8.87521Z\" fill=\"#646A6F\"/>\n  <path d=\"M15.9603 8.87521C15.9603 9.6231 15.6009 10.2295 15.1569 10.2295C14.713 10.2295 14.3535 9.6231 14.3535 8.87521C14.3535 8.12732 14.713 7.52079 15.1569 7.52079C15.6009 7.52079 15.9603 8.12732 15.9603 8.87521Z\" fill=\"#646A6F\"/>\n  </svg>", "<svg width=\"35\" height=\"35\" viewBox=\"0 0 23 22\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n  <path d=\"M0.0429688 10.9042C0.0429688 4.8818 4.92485 -0.000333786 10.9479 -0.000333786C16.9696 -0.000333786 21.8515 4.8818 21.8515 10.9042C21.8515 16.9266 16.9696 21.8086 10.9479 21.8086C4.92485 21.8086 0.0429688 16.9266 0.0429688 10.9042Z\" fill=\"#D9DCDE\"/>\n  <path d=\"M7.73506 8.87521C7.73506 9.6231 7.37429 10.2295 6.93036 10.2295C6.48772 10.2295 6.12695 9.6231 6.12695 8.87521C6.12695 8.12732 6.48772 7.52079 6.93036 7.52079C7.37429 7.52079 7.73506 8.12732 7.73506 8.87521Z\" fill=\"#646A6F\"/>\n  <path d=\"M15.7689 8.87521C15.7689 9.6231 15.4095 10.2295 14.9655 10.2295C14.5216 10.2295 14.1621 9.6231 14.1621 8.87521C14.1621 8.12732 14.5216 7.52079 14.9655 7.52079C15.4095 7.52079 15.7689 8.12732 15.7689 8.87521Z\" fill=\"#646A6F\"/>\n  <path d=\"M13.543 14.3749C12.043 15.875 9.54297 15.875 8.04297 14.375\" stroke=\"#646A6E\" stroke-linecap=\"round\"/>\n  </svg>", "<svg width=\"35\" height=\"35\" viewBox=\"0 0 23 22\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n  <path d=\"M0.851562 10.9042C0.851562 4.8818 5.73345 -0.000333786 11.7565 -0.000333786C17.7782 -0.000333786 22.6601 4.8818 22.6601 10.9042C22.6601 16.9266 17.7782 21.8086 11.7565 21.8086C5.73345 21.8086 0.851562 16.9266 0.851562 10.9042Z\" fill=\"#D9DCDE\"/>\n  <path d=\"M8.54365 8.87521C8.54365 9.6231 8.18288 10.2295 7.73896 10.2295C7.29631 10.2295 6.93555 9.6231 6.93555 8.87521C6.93555 8.12732 7.29631 7.52079 7.73896 7.52079C8.18288 7.52079 8.54365 8.12732 8.54365 8.87521Z\" fill=\"#646A6F\"/>\n  <path d=\"M16.5775 8.87521C16.5775 9.6231 16.218 10.2295 15.7741 10.2295C15.3302 10.2295 14.9707 9.6231 14.9707 8.87521C14.9707 8.12732 15.3302 7.52079 15.7741 7.52079C16.218 7.52079 16.5775 8.12732 16.5775 8.87521Z\" fill=\"#646A6F\"/>\n  <path d=\"M15.3516 14.3748C13.8516 17 9.85156 17 7.85156 14.3749\" stroke=\"#646A6E\" stroke-linecap=\"round\"/>\n  </svg>", "<svg width=\"35\" height=\"35\" viewBox=\"0 0 23 22\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n  <path d=\"M0.660156 10.9042C0.660156 4.8818 5.54204 -0.000333786 11.5651 -0.000333786C17.5868 -0.000333786 22.4687 4.8818 22.4687 10.9042C22.4687 16.9266 17.5868 21.8086 11.5651 21.8086C5.54204 21.8086 0.660156 16.9266 0.660156 10.9042Z\" fill=\"#D9DCDE\"/>\n  <path d=\"M8.35225 8.87521C8.35225 9.6231 7.99147 10.2295 7.54755 10.2295C7.10491 10.2295 6.74414 9.6231 6.74414 8.87521C6.74414 8.12732 7.10491 7.52079 7.54755 7.52079C7.99147 7.52079 8.35225 8.12732 8.35225 8.87521Z\" fill=\"#646A6F\"/>\n  <path d=\"M16.3861 8.87521C16.3861 9.6231 16.0266 10.2295 15.5827 10.2295C15.1388 10.2295 14.7793 9.6231 14.7793 8.87521C14.7793 8.12732 15.1388 7.52079 15.5827 7.52079C16.0266 7.52079 16.3861 8.12732 16.3861 8.87521Z\" fill=\"#646A6F\"/>\n  <path d=\"M15.1602 13.3748C14.6602 17.5 8.16016 17.5 7.66016 13.3749\" stroke=\"#646A6E\" stroke-linecap=\"round\"/>\n  </svg>", "<svg width=\"35\" height=\"35\" viewBox=\"0 0 23 22\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n  <path d=\"M0.46875 10.9042C0.46875 4.8818 5.35063 -0.000333786 11.3737 -0.000333786C17.3954 -0.000333786 22.2773 4.8818 22.2773 10.9042C22.2773 16.9266 17.3954 21.8086 11.3737 21.8086C5.35063 21.8086 0.46875 16.9266 0.46875 10.9042Z\" fill=\"#D9DCDE\"/>\n  <path d=\"M8.16084 8.87521C8.16084 9.6231 7.80007 10.2295 7.35614 10.2295C6.9135 10.2295 6.55273 9.6231 6.55273 8.87521C6.55273 8.12732 6.9135 7.52079 7.35614 7.52079C7.80007 7.52079 8.16084 8.12732 8.16084 8.87521Z\" fill=\"#646A6F\"/>\n  <path d=\"M16.1947 8.87521C16.1947 9.6231 15.8352 10.2295 15.3913 10.2295C14.9474 10.2295 14.5879 9.6231 14.5879 8.87521C14.5879 8.12732 14.9474 7.52079 15.3913 7.52079C15.8352 7.52079 16.1947 8.12732 16.1947 8.87521Z\" fill=\"#646A6F\"/>\n  <path d=\"M14.9688 13.3748C14.4688 17.5 7.96875 17.5 7.46875 13.3749L14.9688 13.3748Z\" fill=\"#646A6E\" stroke=\"#646A6E\" stroke-linecap=\"round\"/>\n  </svg>", "<svg width=\"35\" height=\"35\" viewBox=\"0 0 23 22\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n  <path d=\"M0 10.9042C0 4.8818 4.88188 -0.000333786 10.9049 -0.000333786C16.9267 -0.000333786 21.8085 4.8818 21.8085 10.9042C21.8085 16.9266 16.9267 21.8086 10.9049 21.8086C4.88188 21.8086 0 16.9266 0 10.9042Z\" fill=\"#D9DCDE\"/>\n  <path d=\"M14.5 13.3748C14 17.5 7.5 17.5 7 13.3749L14.5 13.3748Z\" fill=\"#646A6E\" stroke=\"#646A6E\" stroke-linecap=\"round\"/>\n  <path d=\"M9.40207 8.10736L9.40294 8.09652C9.40294 7.41374 8.90848 6.78855 8.16593 6.78855C7.57606 6.78855 7.23428 7.21257 7.11718 7.60952C7.00094 7.21257 6.65828 6.78855 6.06841 6.78855C5.32586 6.78855 4.83227 7.41374 4.83227 8.09652V8.10736C4.8288 8.25596 4.83227 9.76759 7.1163 10.9997V11L7.11718 10.9998V11L7.11804 10.9998V11V10.9997C9.40294 9.76759 9.40641 8.25596 9.40207 8.10736Z\" fill=\"#646A6E\"/>\n  <path d=\"M17.1013 8.10736V8.09652C17.1013 7.41374 16.6077 6.78855 15.8652 6.78855C15.2753 6.78855 14.9335 7.21257 14.8164 7.60952C14.7001 7.21257 14.3575 6.78855 13.7676 6.78855C13.0251 6.78855 12.5315 7.41374 12.5315 8.09652V8.10736C12.528 8.25596 12.5315 9.76759 14.8155 10.9997V11L14.8164 10.9998V11L14.8173 10.9998V11V10.9997C17.1022 9.76759 17.1056 8.25596 17.1013 8.10736Z\" fill=\"#646A6E\"/>\n  </svg>"];
  var STYLISED_EMOJI_GREY_5 = ["<svg width=\"35\" height=\"35\" viewBox=\"0 0 23 22\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M0 10.9042C0 4.8818 4.88188 -0.000334176 10.9049 -0.000334176C16.9267 -0.000334176 21.8085 4.8818 21.8085 10.9042C21.8085 16.9266 16.9267 21.8086 10.9049 21.8086C4.88188 21.8086 0 16.9266 0 10.9042Z\" fill=\"#D9DCDE\"/>\n<path d=\"M7.69209 8.87521C7.69209 9.6231 7.33132 10.2295 6.88739 10.2295C6.44475 10.2295 6.08398 9.6231 6.08398 8.87521C6.08398 8.12732 6.44475 7.52079 6.88739 7.52079C7.33132 7.52079 7.69209 8.12732 7.69209 8.87521Z\" fill=\"#646A6F\"/>\n<path d=\"M15.726 8.87521C15.726 9.6231 15.3665 10.2295 14.9226 10.2295C14.4786 10.2295 14.1191 9.6231 14.1191 8.87521C14.1191 8.12732 14.4786 7.52079 14.9226 7.52079C15.3665 7.52079 15.726 8.12732 15.726 8.87521Z\" fill=\"#646A6F\"/>\n<path d=\"M9.1519 6.99055L8.42013 7.72168L5.98047 5.28189L6.71224 4.55089L9.1519 6.99055\" fill=\"#646A6F\"/>\n<path d=\"M13.3887 7.72168L12.6582 6.99055L15.0979 4.55089L15.8284 5.28189L13.3887 7.72168\" fill=\"#646A6F\"/>\n<path d=\"M7 16.4997C8 12.4996 13 10.4996 15 16.4999\" stroke=\"#646A6E\" stroke-linecap=\"round\"/>\n</svg>", "<svg width=\"35\" height=\"35\" viewBox=\"0 0 23 22\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M0.808594 10.9042C0.808594 4.8818 5.69048 -0.000333786 11.7135 -0.000333786C17.7353 -0.000333786 22.6171 4.8818 22.6171 10.9042C22.6171 16.9266 17.7353 21.8086 11.7135 21.8086C5.69048 21.8086 0.808594 16.9266 0.808594 10.9042Z\" fill=\"#D9DCDE\"/>\n<path d=\"M8.50068 8.87521C8.50068 9.6231 8.13991 10.2295 7.69599 10.2295C7.25334 10.2295 6.89258 9.6231 6.89258 8.87521C6.89258 8.12732 7.25334 7.52079 7.69599 7.52079C8.13991 7.52079 8.50068 8.12732 8.50068 8.87521Z\" fill=\"#646A6F\"/>\n<path d=\"M16.5346 8.87521C16.5346 9.6231 16.1751 10.2295 15.7312 10.2295C15.2872 10.2295 14.9277 9.6231 14.9277 8.87521C14.9277 8.12732 15.2872 7.52079 15.7312 7.52079C16.1751 7.52079 16.5346 8.12732 16.5346 8.87521Z\" fill=\"#646A6F\"/>\n<path d=\"M7.80859 15.4995C9.14193 13.0401 13.3086 11.9996 15.8086 15.4996\" stroke=\"#646A6E\" stroke-linecap=\"round\"/>\n</svg>", "<svg width=\"35\" height=\"35\" viewBox=\"0 0 23 22\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M0.617188 10.9042C0.617188 4.8818 5.49907 -0.000333786 11.5221 -0.000333786C17.5439 -0.000333786 22.4257 4.8818 22.4257 10.9042C22.4257 16.9266 17.5439 21.8086 11.5221 21.8086C5.49907 21.8086 0.617188 16.9266 0.617188 10.9042Z\" fill=\"#D9DCDE\"/>\n<path d=\"M8.30928 8.87521C8.30928 9.6231 7.9485 10.2295 7.50458 10.2295C7.06194 10.2295 6.70117 9.6231 6.70117 8.87521C6.70117 8.12732 7.06194 7.52079 7.50458 7.52079C7.9485 7.52079 8.30928 8.12732 8.30928 8.87521Z\" fill=\"#646A6F\"/>\n<path d=\"M16.3432 8.87521C16.3432 9.6231 15.9837 10.2295 15.5398 10.2295C15.0958 10.2295 14.7363 9.6231 14.7363 8.87521C14.7363 8.12732 15.0958 7.52079 15.5398 7.52079C15.9837 7.52079 16.3432 8.12732 16.3432 8.87521Z\" fill=\"#646A6F\"/>\n<path d=\"M8.11719 15.5003C10.1172 15.5 12.1172 15.4998 15.1172 15.5001\" stroke=\"#646A6E\" stroke-linecap=\"round\"/>\n</svg>", "<svg width=\"35\" height=\"35\" viewBox=\"0 0 23 22\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M0.425781 10.9042C0.425781 4.8818 5.30767 -0.000333786 11.3307 -0.000333786C17.3524 -0.000333786 22.2343 4.8818 22.2343 10.9042C22.2343 16.9266 17.3524 21.8086 11.3307 21.8086C5.30767 21.8086 0.425781 16.9266 0.425781 10.9042Z\" fill=\"#D9DCDE\"/>\n<path d=\"M8.11787 8.87521C8.11787 9.6231 7.7571 10.2295 7.31318 10.2295C6.87053 10.2295 6.50977 9.6231 6.50977 8.87521C6.50977 8.12732 6.87053 7.52079 7.31318 7.52079C7.7571 7.52079 8.11787 8.12732 8.11787 8.87521Z\" fill=\"#646A6F\"/>\n<path d=\"M16.1518 8.87521C16.1518 9.6231 15.7923 10.2295 15.3483 10.2295C14.9044 10.2295 14.5449 9.6231 14.5449 8.87521C14.5449 8.12732 14.9044 7.52079 15.3483 7.52079C15.7923 7.52079 16.1518 8.12732 16.1518 8.87521Z\" fill=\"#646A6F\"/>\n<path d=\"M14.9258 13.3748C14.4258 17.5 7.92578 17.5 7.42578 13.3749L14.9258 13.3748Z\" fill=\"#646A6E\" stroke=\"#646A6E\" stroke-linecap=\"round\"/>\n</svg>", "<svg width=\"35\" height=\"35\" viewBox=\"0 0 23 22\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M0.234375 10.9042C0.234375 4.8818 5.11626 -0.000333786 11.1393 -0.000333786C17.161 -0.000333786 22.0429 4.8818 22.0429 10.9042C22.0429 16.9266 17.161 21.8086 11.1393 21.8086C5.11626 21.8086 0.234375 16.9266 0.234375 10.9042Z\" fill=\"#D9DCDE\"/>\n<path d=\"M14.7344 13.3748C14.2344 17.5 7.73438 17.5 7.23438 13.3749L14.7344 13.3748Z\" fill=\"#646A6E\" stroke=\"#646A6E\" stroke-linecap=\"round\"/>\n<path d=\"M9.63644 8.10736L9.63732 8.09652C9.63732 7.41374 9.14286 6.78855 8.40031 6.78855C7.81043 6.78855 7.46866 7.21257 7.35155 7.60952C7.23531 7.21257 6.89266 6.78855 6.30278 6.78855C5.56023 6.78855 5.06665 7.41374 5.06665 8.09652V8.10736C5.06318 8.25596 5.06665 9.76759 7.35068 10.9997V11L7.35155 10.9998V11L7.35241 10.9998V11V10.9997C9.63731 9.76759 9.64078 8.25596 9.63644 8.10736Z\" fill=\"#646A6E\"/>\n<path d=\"M17.3357 8.10736V8.09652C17.3357 7.41374 16.8421 6.78855 16.0995 6.78855C15.5097 6.78855 15.1679 7.21257 15.0508 7.60952C14.9345 7.21257 14.5919 6.78855 14.002 6.78855C13.2595 6.78855 12.7659 7.41374 12.7659 8.09652V8.10736C12.7624 8.25596 12.7659 9.76759 15.0499 10.9997V11L15.0508 10.9998V11L15.0516 10.9998V11V10.9997C17.3365 9.76759 17.34 8.25596 17.3357 8.10736Z\" fill=\"#646A6E\"/>\n</svg>"];

  function hexToRgb(hex) {
    // Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
    var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
    hex = hex.replace(shorthandRegex, function (m, r, g, b) {
      return r + r + g + g + b + b;
    });
    var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? {
      r: parseInt(result[1], 16),
      g: parseInt(result[2], 16),
      b: parseInt(result[3], 16)
    } : null;
  }

  /**
   * Dialog Root
   *  > Dialog Content
   *    > Questions / request for survey --> This will be changed dynamically as the survey progresses
   *  > Dialog Styles
   */
  var createDialog = function createDialog(width, min_height, onDismiss, _ref, _ref2) {
    var dim_background = _ref.dim_background,
      dim_bg_color = _ref.dim_bg_color,
      dim_bg_opacity = _ref.dim_bg_opacity,
      position = _ref.position;
    var question_background_color = _ref2.question_background_color;
    var dialogRoot = document.createElement("div");
    dialogRoot.setAttribute("id", APX_OVERLAY);
    var styleNode = document.createElement("style");
    var justifyContent = "center";
    var alignItems = "center";
    switch (position) {
      case "bottom-left":
        justifyContent = "flex-start";
        alignItems = "flex-end";
        break;
      case "bottom-right":
        justifyContent = "flex-end";
        alignItems = "flex-end";
        break;
      case "top-left":
        justifyContent = "flex-start";
        alignItems = "flex-start";
        break;
      case "top-right":
        justifyContent = "flex-end";
        alignItems = "flex-start";
        break;
    }
    var bg_color = "none";
    if (dim_background) {
      var rgb = hexToRgb(dim_bg_color);
      bg_color = "rgb(".concat(rgb.r, ", ").concat(rgb.g, ", ").concat(rgb.b, ", ").concat(dim_bg_opacity, ")");
    }
    styleNode.innerHTML = "\n#apx-oly {\n  width:100%;height:100%;position:fixed;top:0;left:0;background-color:".concat(bg_color, ";\n  display:flex;justify-content:").concat(justifyContent, ";align-items:").concat(alignItems, ";border-radius:3px;z-index:99999999\n}\n#apx-oly > * {font-family: inherit;box-sizing:unset}\n.apx-dlg-c {\n  width:").concat(width, "px;max-height:").concat(window.innerHeight, "px;overflow: auto;min-height:").concat(min_height, "%;background:").concat(question_background_color, ";z-index:99999999;opacity:0;position:relative;visibility:hidden;\n  transition:all 500ms cubic-bezier(0, -0.37, 0, 2.06);top:-15px;border-radius:3px;margin:20px\n}\n.apx-dlg-c.open {opacity:1;visibility:visible;top:0}\n  ").replaceAll("\n", "").replace(/[\s]{2,999}/g, "");
    var dialogContent = document.createElement("div");
    dialogContent.setAttribute("id", APX_DIALOG_CONTENT);
    dialogContent.classList.add(APX_DIALOG_CONTENT);
    dialogRoot.appendChild(dialogContent);
    dialogRoot.appendChild(styleNode);
    dialogRoot[SURVEY_ON_DISMISS] = onDismiss;
    document.body.appendChild(dialogRoot);
    return dialogRoot;
  };
  var getImage = function getImage(icon, width, height) {
    if (!icon || icon === "" || width === 0 || height === 0) {
      return "";
    }
    return "<img id=\"apx_icon\" src=\"".concat(icon, "\" style=\"width:").concat(width, "px;height:").concat(height, "px;\">");
  };

  /**
   * > Dialog Content
   *    > Image
   *    > Title
   *    > Yes Button
   *    > No Button
   */
  var generateRequestSurvey = function generateRequestSurvey(dialog_config) {
    var _dialog_config$icon_n = dialog_config.icon_name,
      icon_name = _dialog_config$icon_n === void 0 ? "" : _dialog_config$icon_n,
      _dialog_config$title = dialog_config.title,
      title = _dialog_config$title === void 0 ? "Some dummy title" : _dialog_config$title,
      _dialog_config$yes_te = dialog_config.yes_text,
      yes_text = _dialog_config$yes_te === void 0 ? "Yes" : _dialog_config$yes_te,
      _dialog_config$icon_w = dialog_config.icon_width,
      icon_width = _dialog_config$icon_w === void 0 ? 180 : _dialog_config$icon_w,
      _dialog_config$icon_h = dialog_config.icon_height,
      icon_height = _dialog_config$icon_h === void 0 ? 100 : _dialog_config$icon_h,
      _dialog_config$no_tex = dialog_config.no_text,
      no_text = _dialog_config$no_tex === void 0 ? "No, thanks" : _dialog_config$no_tex,
      _dialog_config$dialog = dialog_config.dialog_background_color,
      dialog_background_color = _dialog_config$dialog === void 0 ? "#FFF" : _dialog_config$dialog,
      _dialog_config$title_ = dialog_config.title_color,
      title_color = _dialog_config$title_ === void 0 ? "#3C3C3C" : _dialog_config$title_,
      _dialog_config$yes_bu = dialog_config.yes_button_bg_color,
      yes_button_bg_color = _dialog_config$yes_bu === void 0 ? "#017DFD" : _dialog_config$yes_bu,
      _dialog_config$yes_bu2 = dialog_config.yes_button_text_color,
      yes_button_text_color = _dialog_config$yes_bu2 === void 0 ? "#FFF" : _dialog_config$yes_bu2,
      _dialog_config$no_but = dialog_config.no_button_text_color,
      no_button_text_color = _dialog_config$no_but === void 0 ? "#017DFD" : _dialog_config$no_but;
    var common_styles = function common_styles() {
      var size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 12;
      var weight = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 500;
      return "line-height:20px;letter-spacing:0.005em;font-size:".concat(size, "px;font-weight:").concat(weight, ";");
    };
    return "\n  <div style=\"display:flex;flex-direction:column;height:100%;width:100%;background-color:".concat(dialog_background_color, ";align-items:center;padding-top:20px;border-radius:3px\">\n  ").concat(getImage(icon_name, icon_width, icon_height), "<span style=\"").concat(common_styles(16, 600), "text-align:center;color:").concat(title_color, ";margin:12px 0px;\">").concat(title, "</span>\n  <button id=\"").concat(APX_DIALOG_YES, "\" style=\"").concat(common_styles(14, 500), "color:").concat(yes_button_text_color, ";background-color:").concat(yes_button_bg_color, ";border-radius:2px;border:none;padding:8px 20px;margin-bottom:10px;cursor:pointer\">").concat(yes_text, "</button>\n  <button id=\"").concat(APX_DIALOG_NO, "\" style=\"").concat(common_styles(14, 500), "color:").concat(no_button_text_color, ";background:none;border:none;cursor:pointer;margin-bottom:20px\">").concat(no_text, "</button>\n  </div>\n  ");
  };
  var getTextAreaCSS = function getTextAreaCSS(placeholder_text_color) {
    return "\n  .apx-ta:focus {\n    border: none;\n    outline: none;\n  }\n  .apx-ta::placeholder {\n    color: ".concat(placeholder_text_color, ";\n    opacity: 0.5;\n  }\n  ");
  };
  var getSurveyOptionCSS = function getSurveyOptionCSS(type, bg_color_active, bg_color_inactive, text_color_active, text_color_inactive, option_bg_type) {
    return "\n  .apx-lc {\n    display: flex;\n    align-items:center;\n    position: relative;\n    background: ".concat(option_bg_type === "outline" ? "unset" : option_bg_type === "filled" ? bg_color_inactive : "unset", ";\n    border: ").concat(option_bg_type === "outline" ? "1px solid " + bg_color_inactive : option_bg_type === "filled" ? bg_color_inactive : "unset", ";\n    padding: ").concat(option_bg_type !== "none" ? "10px 10px 10px 35px" : "0px 0px 0px 35px", ";\n    margin-bottom: 12px;\n    font-family: inherit;\n    top: 10px;\n    cursor: pointer;\n    font-size: 18px;\n    color: ").concat(text_color_inactive, ";\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    -ms-user-select: none;\n    user-select: none;\n  }\n\n  .apx-lc input {\n    position: absolute;\n    opacity: 0;\n    cursor: pointer;\n    width: 0;\n    height: 0;\n  }\n\n  .apx-i {\n    position: absolute;\n    display:flex;\n    align-items:center;\n    justify-content:center;\n    left: 6px;\n    height: 14px;\n    width: 14px;\n    border: 1px solid ").concat(text_color_inactive, ";\n    background-color: white;\n    border-radius: ").concat(type === ANSWER_TYPES.SINGLE_CHOICE ? "50%" : 0, ";\n  }\n\n  .apx-lc:hover input ~ .apx-i {\n    border: 1px solid ").concat(text_color_active, ";\n  }\n\n  .apx-lc input:checked ~ .apx-i {\n    background-color: ").concat(bg_color_active, ";\n    border: 1px solid ").concat(text_color_active, ";\n  }\n\n  .apx-i:after {\n    content: \"\";\n    position: absolute;\n    display: none;\n  }\n\n  .apx-lc input:checked ~ .apx-i:after {\n    display: block;\n  }\n\n  .apx-lc .apx-i:after {\n    top: ").concat(type === ANSWER_TYPES.SINGLE_CHOICE ? 2 : 1, "px;\n    left: ").concat(type === ANSWER_TYPES.SINGLE_CHOICE ? 2 : 4, "px;\n    width: ").concat(type === ANSWER_TYPES.SINGLE_CHOICE ? 10 : 4, "px;\n    height: ").concat(type === ANSWER_TYPES.SINGLE_CHOICE ? 10 : 8, "px;\n    border-radius: ").concat(type === ANSWER_TYPES.SINGLE_CHOICE ? "50%" : "0", ";\n    background: ").concat(type === ANSWER_TYPES.SINGLE_CHOICE ? text_color_active : "transparent", ";\n    border: ").concat(type === ANSWER_TYPES.SINGLE_CHOICE ? "none" : "solid white", ";\n    border-width: ").concat(type === ANSWER_TYPES.SINGLE_CHOICE ? "unset" : "0 3px 3px 0", ";\n    -webkit-transform: ").concat(type === ANSWER_TYPES.SINGLE_CHOICE ? "unset" : "rotate(45deg)", ";\n    -ms-transform: ").concat(type === ANSWER_TYPES.SINGLE_CHOICE ? "unset" : "rotate(45deg)", ";\n    transform: ").concat(type === ANSWER_TYPES.SINGLE_CHOICE ? "unset" : "rotate(45deg)", ";\n  }\n  ");
  };

  /**
   * > Dialog Content
   *    > Question Root
   *      > Header
   *        >  Prev -- Counter -- Close
   */
  var createSurveyHeaderNode = function createSurveyHeaderNode(layoutConfig, index, totalQuestionsLength, is_response_based_survey) {
    var cancel_button_color = layoutConfig.cancel_button_color,
      previous_button_color = layoutConfig.previous_button_color;
    var prevButton = document.createElement("button");
    var closeButton = document.createElement("button");
    prevButton.disabled = index === 0;
    prevButton.setAttribute("type", "button");
    prevButton.className = "apx-b apx-pr";
    prevButton.innerHTML = "<style>.apx-pr::before{content:'\\2190';font-size:22px;color:".concat(previous_button_color).concat(index === 0 ? "54" : "", ";}.apx-pr{cursor:").concat(index === 0 ? "no-drop" : "pointer", ";visibility:").concat(index === 0 ? "hidden" : "visible", ";margin-top:-6px}</style>");
    closeButton.className = "apx-b apx-cb";
    closeButton.setAttribute("type", "button");
    closeButton.innerHTML = "<style>.apx-cb::before{content:'\\0000d7';font-size:26px;color:".concat(cancel_button_color, ";}</style>");
    var headerNode = document.createElement("div");
    headerNode.style = "display:flex;justify-content:space-between;align-items:center;padding:8px;padding-bottom:0";
    var counterNode = document.createElement("span");
    counterNode.style = "font-size:14px;color:#000;opacity:0.3;letter-spacing:0.005em;line-height:12px";
    counterNode.innerText = is_response_based_survey ? "" : "".concat(index + 1, "/").concat(totalQuestionsLength);
    headerNode.appendChild(prevButton);
    headerNode.appendChild(counterNode);
    headerNode.appendChild(closeButton);
    return {
      prevButton: prevButton,
      closeButton: closeButton,
      headerNode: headerNode
    };
  };

  /**
   * Change the submit button background color based on the answer mode
   */
  var changeSubmitButtonBgColor = function changeSubmitButtonBgColor(question, submitButton) {
    var answerMode = question.answerMode,
      _question$choices = question.choices,
      choices = _question$choices === void 0 ? [] : _question$choices,
      _question$text_answer = question.text_answer,
      text_answer = _question$text_answer === void 0 ? "" : _question$text_answer,
      _question$selected_ra = question.selected_rating,
      selected_rating = _question$selected_ra === void 0 ? -1 : _question$selected_ra;
    var canEnable = true;
    if (answerMode === ANSWER_TYPES.MULTI_CHOICE || answerMode === ANSWER_TYPES.SINGLE_CHOICE) {
      var index = choices.findIndex(function (choice) {
        return choice.is_selected === true;
      });
      canEnable = index !== -1;
    } else if (answerMode === ANSWER_TYPES.SHORT_ANSWER) {
      canEnable = text_answer.length > 0;
    } else if (answerMode === ANSWER_TYPES.RATING) {
      canEnable = selected_rating > 0;
    }
    if (canEnable) {
      submitButton.className = "apx-ba";
      submitButton.disabled = false;
    } else {
      submitButton.className = "apx-bi";
      submitButton.disabled = true;
    }
  };

  /**
   * > Dialog Content
   *    > Question Root
   *      > Header
   *      > Question Content
   *      > Footer (sticks to bottom)
   *        > Right aligned buttons -> Skip -- Next
   */
  var createSurveyFooterNode = function createSurveyFooterNode(layoutConfig, question, index, totalQuestionsLength, isRequired) {
    var skip_text_color = layoutConfig.skip_text_color,
      submit_text_color = layoutConfig.submit_text_color,
      submit_active_color = layoutConfig.submit_active_color,
      submit_inactive_color = layoutConfig.submit_inactive_color;
    var skipButton = index === totalQuestionsLength - 1 || isRequired ? null : document.createElement("button");
    if (skipButton) {
      skipButton.innerText = "Skip";
      skipButton.className = "apx-b";
      skipButton.style = "font-size:14px;font-weight:600;opacity:1;font-style:inherit;color:".concat(skip_text_color, ";background-color:transparent;margin:0px 12px");
    }
    var submitButton = document.createElement("button");
    submitButton.innerHTML = "".concat(index === totalQuestionsLength - 1 ? question.submit_text === "Next >" ? "Submit" : question.submit_text : question.submit_text, "<style>.apx-ba{background-color:").concat(submit_active_color, ";cursor:pointer}.apx-bi{background-color:").concat(submit_inactive_color, ";cursor:no-drop}</style>");
    submitButton.style = "border:none;border-radius:2px;color:".concat(submit_text_color, ";padding:8px 15px;font-family:inherit");
    changeSubmitButtonBgColor(question, submitButton);
    var footerNode = document.createElement("div");
    footerNode.style = "padding:14px;display:flex;justify-content:flex-end";
    if (skipButton) {
      footerNode.appendChild(skipButton);
    }
    footerNode.appendChild(submitButton);
    return {
      footerNode: footerNode,
      skipButton: skipButton,
      submitButton: submitButton
    };
  };

  /**
   * Common code to generate the textArea node based on the given text_config param
   */
  var getTextAreaNode = function getTextAreaNode(text_config) {
    var _text_config$textinpu;
    var maximum_characters = text_config.maximum_characters,
      background_color = text_config.background_color,
      placeholder = text_config.placeholder,
      text_color = text_config.text_color;
    var textAreaNode = document.createElement("textarea");
    var textinput_border_color = (_text_config$textinpu = text_config === null || text_config === void 0 ? void 0 : text_config.textinput_border_color) !== null && _text_config$textinpu !== void 0 ? _text_config$textinpu : "black";
    textAreaNode.style = "padding-top:4px;padding-left:4px;font-zie:14px;width:98%;height:100px;margin-top:8px;border: 1px solid ".concat(textinput_border_color, ";resize:none;background:").concat(background_color, ";color:").concat(text_color);
    textAreaNode.className = "apx-ta";
    textAreaNode.setAttribute("placeholder", placeholder);
    textAreaNode.setAttribute("maxlength", maximum_characters);
    return textAreaNode;
  };

  /**
   *  > Dialog Content
   *    > Question Root
   *      > Header
   *      > Question Content
   *        > Title
   *        > Options (based on the no.of choices) / TextArea / Rating
   *      > Footer
   *
   * Generates the HTML code based on the answer mode
   */
  var createQuestionNode = function createQuestionNode(question, questionConfig, submitButton) {
    var question_text_color = questionConfig.question_text_color,
      question_background_color = questionConfig.question_background_color,
      option_bg_color_active = questionConfig.option_bg_color_active,
      option_bg_color_inactive = questionConfig.option_bg_color_inactive,
      option_text_color_active = questionConfig.option_text_color_active,
      option_text_color_inactive = questionConfig.option_text_color_inactive,
      option_bg_type = questionConfig.option_bg_type;
    var rating_style = question.rating_style,
      answerMode = question.answerMode,
      _question$choices2 = question.choices,
      choices = _question$choices2 === void 0 ? [] : _question$choices2,
      _question$rating = question.rating,
      rating = _question$rating === void 0 ? {
        rating_style: rating_style,
        bg_color: "#D9DCDE",
        selected_bg_color: "#109B15"
      } : _question$rating,
      _question$rating_scal = question.rating_scale,
      rating_scale = _question$rating_scal === void 0 ? 5 : _question$rating_scal,
      _question$selected_ra2 = question.selected_rating,
      selected_rating = _question$selected_ra2 === void 0 ? -1 : _question$selected_ra2,
      _question$text_answer2 = question.text_answer,
      text_answer = _question$text_answer2 === void 0 ? "" : _question$text_answer2;
    var text_config = question.text_config ? question.text_config : {
      maximum_characters: 150,
      background_color: "#ccc",
      placeholder: "",
      text_color: "#000",
      placeholder_text_color: "#00000087"
    };
    var otherChoiceFound = false;
    var choiceNodes = [];
    if (answerMode === ANSWER_TYPES.SINGLE_CHOICE || answerMode === ANSWER_TYPES.MULTI_CHOICE) {
      /**
       * Generate the choice nodes based on the lenfth of `choices` field from `question`
       * and appends the node to the `choiceNodes` array
       */

      var otherInputNode = getTextAreaNode(text_config);
      otherInputNode.style.visibility = "hidden";
      var setOptionColor = function setOptionColor(node, checked) {
        node.style.color = checked ? option_text_color_active : option_text_color_inactive;
      };
      var setOptionBackgroundColor = function setOptionBackgroundColor(node, checked) {
        var color = checked ? option_bg_color_active : option_bg_color_inactive;
        if (option_bg_type === "filled") {
          node.style.background = color;
        } else if (option_bg_type === "outline") {
          node.style.borderColor = color;
        }
      };
      choices.forEach(function (choice, index) {
        var choiceNode = document.createElement("label");
        choiceNode.className = "apx-lc";
        choiceNode.innerText = choice.value;
        var input = document.createElement("input");
        input.name = input.type = answerMode === ANSWER_TYPES.SINGLE_CHOICE ? "radio" : "checkbox";
        input.checked = choice.is_selected;
        var span = document.createElement("span");
        span.className = "apx-i";
        choiceNode.appendChild(input);
        choiceNode.appendChild(span);

        // If the choice is already selected, apply the CSS styles properly
        setOptionBackgroundColor(choiceNode, choice.is_selected);
        setOptionColor(choiceNode, choice.is_selected);
        if (choice.is_other) {
          otherChoiceFound = true;
          // Listen on user input and update the answer directly in `choice` instance
          otherInputNode.addEventListener("input", function (e) {
            choice.other_answer = e.target.value;
          });
        }

        // If the choice is already selected and of type OTHER,
        // make sure we show it to the users and fill the input value
        if (choice.is_selected && choice.is_other) {
          otherInputNode.style.visibility = "visible";
          if (choice.other_answer) {
            otherInputNode.value = choice.other_answer;
          }
        }
        if (answerMode === ANSWER_TYPES.MULTI_CHOICE) {
          // Listen on the change event for this choice
          // and based on the actions, update the CSS rules
          // and `choice` instance fields properly
          input.onchange = function (e) {
            var checked = e.target.checked;
            choice.is_selected = checked;
            setOptionColor(choiceNode, checked);
            setOptionBackgroundColor(choiceNode, checked);
            if (choice.is_other) {
              otherInputNode.style.visibility = checked ? "visible" : "hidden";
            }
            changeSubmitButtonBgColor(question, submitButton);
          };
        } else {
          input.setAttribute("apx-key", "radio");
          input.setAttribute("apx-ci", index + "");
          input.onchange = function () {
            // Whenever the radio button is selected, browser takes care of
            // de-selecting the other radio buttons. But, we have to take care
            // of business logic of updating the `choice` state properly
            document.querySelectorAll('input[apx-key="radio"]').forEach(function (node, i) {
              var checked = node.checked;
              choices[i].is_selected = checked;
              setOptionColor(node.parentNode, checked);
              setOptionBackgroundColor(node.parentNode, checked);
              if (choice.is_other) {
                otherInputNode.style.visibility = checked ? "visible" : "hidden";
              } else {
                otherInputNode.style.visibility = "hidden";
              }
            });
            changeSubmitButtonBgColor(question, submitButton);
          };
        }
        choiceNodes.push(choiceNode);
      });

      // If we have any other choices in the config, push it to the list
      if (otherChoiceFound) {
        choiceNodes.push(otherInputNode);
      }
    } else if (answerMode === ANSWER_TYPES.SHORT_ANSWER && text_config !== null) {
      var example = text_config.example,
        example_text_color = text_config.example_text_color;
      if (example !== "" && example.trim() !== "") {
        var exampleNode = document.createElement("span");
        exampleNode.innerHTML = "Example: " + example;
        exampleNode.style.color = example_text_color;
        exampleNode.style.marginTop = "12px";
        exampleNode.style.fontFamily = "inherit";
        exampleNode.style.fontSize = "15px";
        choiceNodes.push(exampleNode);
      }
      var textAreaNode = getTextAreaNode(text_config);
      textAreaNode.addEventListener("input", function (e) {
        question.text_answer = e.target.value;
        if (e.target.value && e.target.value.length > 0) {
          question.is_answered = true;
        }
        changeSubmitButtonBgColor(question, submitButton);
      });
      if (text_answer !== "" && text_answer.trim() !== "") {
        textAreaNode.innerText = text_answer;
      }
      choiceNodes.push(textAreaNode);
    } else if (answerMode === ANSWER_TYPES.RATING) {
      var _rating_style = rating.rating_style,
        bg_color = rating.bg_color,
        selected_bg_color = rating.selected_bg_color;
      /**
       * > Question Root
       *    > Rating Node
       *      > Rating Styles
       *      > Horizontal Div
       *        > Icon1 -- Icon 2 -- Icon 3 -- Icon 4 -- Icon 5
       */

      var ratingNode = document.createElement("div");
      var selectedStyles = "";
      var icons = [];
      var unselectedStyles = "";
      var commonStyles = "cursor:pointer;font-size:30px;width:auto;height:auto;";
      // We display icons using unicode characters to save hell lot of space
      if (_rating_style === "stylized") {
        icons = rating_scale === 5 ? STYLISED_EMOJI_GREY_5 : STYLISED_EMOJI_GREY_10;
        ratingNode.style = "display:flex;flex-wrap:wrap;justify-content:".concat(rating_scale === 5 ? "space-evenly" : "center", ";gap:5px;padding-top:8px;padding-bottom:8px;overflow:hidden");
        selectedStyles = "opacity:1 !important;"; // border:1px solid ${selected_bg_color};
        unselectedStyles = "".concat(commonStyles, "padding-right:7px;padding-top:4px;padding-bottom:2px;border-radius:50%;background:transparent;opacity:1;filter:drop-shadow(0px 0.586957px 1.76087px rgba(0, 0, 0, 0.11))");
      } else if (_rating_style === "classic") {
        icons = rating_scale === 5 ? EMOJI_ICONS_5 : EMOJI_ICONS_10;
        ratingNode.style = "display:flex;flex-wrap:wrap;justify-content:".concat(rating_scale === 5 ? "space-evenly" : "center", ";gap:5px;padding-top:8px;padding-bottom:8px;overflow:hidden");
        selectedStyles = "opacity:1 !important;border:1.06px solid #017DFD; background-color:rgba(1, 125, 253, 0.1);\n  "; // border:1px solid ${selected_bg_color};
        unselectedStyles = "".concat(commonStyles, "padding-right:7px;padding-top:4px;padding-bottom:2px;opacity:1;filter:drop-shadow(0px 0.586957px 1.76087px rgba(0, 0, 0, 0.11))");
      } else if (_rating_style === "star") {
        ratingNode.style = "display:flex;flex-wrap:wrap;justify-content:".concat(rating_scale === 5 ? "space-evenly" : "center", ";gap:5px;padding-top:8px;padding-bottom:8px;overflow:hidden");
        for (var i = 0; i < rating_scale; i++) {
          icons.push("&#11088;");
        }
        selectedStyles = "filter:grayscale(0%) !important";
        unselectedStyles = "".concat(commonStyles, "filter:grayscale(100%)");
      } else if (_rating_style === "numbers") {
        icons = rating_scale == 5 ? ["1", "2", "3", "4", "5"] : ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10"];
        selectedStyles = "background:".concat(selected_bg_color, " !important;color:white !important;");
        unselectedStyles = "display:flex;justify-content:space-evenly;align-items:center;color:#646A6E;margin-bottom:".concat(rating_scale === 5 ? "0px" : "10px", ";font-size:15px;width:40px;height:40px;background-color:").concat(bg_color, ";box-shadow:0px 0.54801px 1.64403px 0.54801px rgba(0, 0, 0, 0.11);border-radius:50%");
        ratingNode.style.marginTop = "12px";
        ratingNode.style = "display:flex;align-text:center;flex-wrap:wrap;justify-content:".concat(rating_scale === 5 ? "space-evenly" : "center", ";gap:15px;padding-top:8px;padding-bottom:8px;overflow:hidden");
      }
      var ratingNodeStyle = document.createElement("style");
      //make a function to call the array for 5 and 10
      var colorsArray = rating_scale == 5 ? RATING_COLORS_5 : RATING_COLORS_10;
      var ratingClasses = "";
      colorsArray.forEach(function (item, index) {
        ratingClasses += ".apx-rsel-".concat(index, "{\n    background:").concat(item, "!important;\n    color:white !important;\n  }");
      });
      ratingNodeStyle.innerHTML = ".apx-rsel{".concat(selectedStyles, "}") + ratingClasses + ".apx-r{".concat(unselectedStyles, "}\n");
      ratingNode.appendChild(ratingNodeStyle);
      var canBeSelected = function canBeSelected(index) {
        if (_rating_style !== "star") return index + 1 === selected_rating;
        return index + 1 <= selected_rating;
      };
      var ratings = [];
      for (var index = 0; index < icons.length; index++) {
        var node = document.createElement("div");
        node.innerHTML = "".concat(_rating_style === "numbers" ? "" : "").concat(icons[index]);
        var number = document.createElement("div");
        if (_rating_style === "classic") {
          if (icons.length == 11) {
            "".concat(number.innerHTML = index);
          } else {
            "".concat(number.innerHTML = index + 1);
          }
          number.style.fontSize = "12.83px";
          // number.style.marginLeft = "8px";
          number.style.display = "flex";
          number.style.fontWeight = "500";
          number.style.justifyContent = "center";
          number.style.alignItems = "center";
          node.appendChild(number);
          node.style.display = "flex";
          node.style.justifyContent = "space-evenly";
          node.style.alignItems = "center";
          node.style.flexDirection = "column";
          node.style.width = "40px";
          node.style.height = "70px";
        } else if (_rating_style === "stylized") {
          if (icons.length == 11) {
            "".concat(number.innerHTML = index);
          } else {
            "".concat(number.innerHTML = index + 1);
          }
          number.style.fontSize = "12.83px";
          // number.style.marginLeft = "7px";
          number.style.display = "flex";
          number.style.justifyContent = "center";
          number.style.alignItems = "center";
          node.appendChild(number);
          node.style.display = "flex";
          node.style.justifyContent = "space-evenly";
          node.style.alignItems = "center";
          node.style.marginBottom = "15px";
          node.style.marginRight = "5px";
          node.style.gap = "4px";
          node.style.flexDirection = "column";
        }
        if (canBeSelected(index, selected_rating)) {
          node.classList.add("apx-rsel");
        }
        node.classList.add("apx-r");
        ratings.push(node);
      }
      var setClickStylized = function setClickStylized(node, index, ratings, stylizedEmoji, stylizedEmojiGrey) {
        ratings.forEach(function (toggleNode, iterator) {
          var number = document.createElement("div");
          number.innerHTML = rating_scale === 5 ? iterator + 1 : iterator;
          number.style.fontSize = "12.83px";
          // number.style.marginLeft = "7px";
          number.style.display = "flex";
          number.style.justifyContent = "center";
          number.style.alignItems = "center";
          node.appendChild(number);
          iterator === index ? toggleNode.innerHTML = stylizedEmoji[index] : toggleNode.innerHTML = stylizedEmojiGrey[iterator];
          toggleNode.appendChild(number);
        });
      };
      ratings.forEach(function (node, index) {
        // Add apx-rsel class to the current node
        question.selected_rating = index + 1;
        //changing color of node for all the color

        node.addEventListener("click", function () {
          if (_rating_style === "stylized") {
            if (icons.length === 5) {
              setClickStylized(node, index, ratings, STYLISED_EMOJI_5, STYLISED_EMOJI_GREY_5);
            } else {
              setClickStylized(node, index, ratings, STYLISED_EMOJI_10, STYLISED_EMOJI_GREY_10);
            }
          }
          _rating_style === "numbers" ? node.classList.add("apx-rsel-".concat(index)) : node.classList.add("apx-rsel");
          question.is_answered = true;
          changeSubmitButtonBgColor(question, submitButton);
          question.selected_rating = index + 1;
          if (_rating_style === "numbers") {
            // Remove the apx-rsel class for all the remaining nodes
            for (var _i = 0; _i < index; _i++) {
              ratings[_i].classList.remove("apx-rsel-".concat(_i));
            }
            for (var _i2 = index + 1; _i2 < icons.length; _i2++) {
              // ratings[i].classList.remove("apx-rsel");
              ratings[_i2].classList.remove("apx-rsel-".concat(_i2));
            }
          } else if (_rating_style === "star") {
            // For the star type rating, add the apx-rsel class for the
            // nodes below the current node's index
            for (var _i3 = 0; _i3 < index + 1; _i3++) {
              ratings[_i3].classList.add("apx-rsel");
            }
            // Remove the apx-rsel class for the nodes whose index is higher
            // than the current nodes index
            for (var _i4 = index + 1; _i4 < icons.length; _i4++) {
              ratings[_i4].classList.remove("apx-rsel");
            }
          } else {
            // Remove the apx-rsel class for all the remaining nodes
            for (var _i5 = 0; _i5 < index; _i5++) {
              ratings[_i5].classList.remove("apx-rsel");
            }
            for (var _i6 = index + 1; _i6 < icons.length; _i6++) {
              // ratings[i].classList.remove("apx-rsel");
              ratings[_i6].classList.remove("apx-rsel");
            }
          }
          question.rulesArray.forEach(function (rule) {
            if (question.selected_rating >= rule.min && question.selected_rating <= rule.max) {
              var _rule$question;
              var _questionNode = document.createElement("span");
              _questionNode.setAttribute("id", "nps_advanced");
              _questionNode.innerHTML = (_rule$question = rule.question) === null || _rule$question === void 0 ? void 0 : _rule$question.question;
              var _textAreaNode = getTextAreaNode(text_config);
              _textAreaNode.addEventListener("input", function (e) {
                question.text_answer = e.target.value;
                if (e.target.value && e.target.value.length > 0) {
                  question.is_answered = true;
                }
                changeSubmitButtonBgColor(question, submitButton);
              });
              _questionNode.appendChild(_textAreaNode);
              ratingNode.appendChild(_questionNode);
              var elementNode = document.getElementById("nps_advanced");
              if (elementNode) ratingNode.removeChild(elementNode);
              _questionNode.appendChild(_textAreaNode);
              ratingNode.appendChild(_questionNode);
            }
            // else {
            //   const elementNode = document.getElementById("nps_advanced");
            //   if (elementNode) ratingNode.removeChild(elementNode);
            // }
          });
        });

        ratingNode.appendChild(node);
      });
      choiceNodes.push(ratingNode);
    }

    /**
     * > Question root
     *    > Question styles
     *    > Question Title
     *    > iterate over choiceNodes and append children
     */
    var questionNode = document.createElement("div");
    questionNode.style.padding = "14px";
    questionNode.style.display = "flex";
    questionNode.style.flexDirection = "column";
    questionNode.style.minHeight = "340px";
    var questionStyles = document.createElement("style");
    var css = "";
    if (answerMode === ANSWER_TYPES.SHORT_ANSWER) {
      css = getTextAreaCSS(text_config.placeholder_text_color);
    } else if (answerMode === ANSWER_TYPES.SINGLE_CHOICE || answerMode === ANSWER_TYPES.MULTI_CHOICE) {
      css = getSurveyOptionCSS(answerMode, option_bg_color_active, option_bg_color_inactive, option_text_color_active, option_text_color_inactive, option_bg_type);
      if (otherChoiceFound) {
        css += getTextAreaCSS(text_config.placeholder_text_color);
      }
    }
    questionStyles.innerHTML = css.replaceAll("\n", "").replace(/[\s]{2,999}/g, "");
    questionNode.appendChild(questionStyles);
    var title = document.createElement("span");
    title.innerText = question.title;
    title.style = "margin-bottom:12px;color:".concat(question_text_color, ";background-color:").concat(question_background_color, ";font-size:16px;font-weight:600");
    questionNode.appendChild(title);
    choiceNodes.forEach(function (choiceNode) {
      return questionNode.appendChild(choiceNode);
    });
    return questionNode;
  };

  /**
   * > Dialog Content
   *    > Question Root
   *      > Question Root Styles
   *      > Header
   *      > Question content
   *      > Footer
   */
  var getSurveyDialogContent = function getSurveyDialogContent(layoutConfig, questionConfig, question, index, totalQuestionsLength, is_response_based_survey) {
    var _createSurveyHeaderNo = createSurveyHeaderNode(layoutConfig, index, totalQuestionsLength, is_response_based_survey),
      headerNode = _createSurveyHeaderNo.headerNode,
      prevButton = _createSurveyHeaderNo.prevButton,
      closeButton = _createSurveyHeaderNo.closeButton;
    var _createSurveyFooterNo = createSurveyFooterNode(layoutConfig, question, index, totalQuestionsLength, question.is_required),
      skipButton = _createSurveyFooterNo.skipButton,
      submitButton = _createSurveyFooterNo.submitButton,
      footerNode = _createSurveyFooterNo.footerNode;
    var questionNode = createQuestionNode(question, questionConfig, submitButton);
    var questionRoot = document.createElement("div");
    questionRoot.className = "apx-sq";
    var styleNode = document.createElement("style");
    styleNode.innerHTML = ".apx-sq > * {font-family:inherit;}.apx-sq {height:100%;width:100%;display:flex;flex-direction:column}.apx-b{border:none;background:none;opacity:1;cursor:pointer;font-family:inherit}";
    questionRoot.appendChild(styleNode);
    questionRoot.appendChild(headerNode);
    questionRoot.appendChild(questionNode);
    return {
      questionRoot: questionRoot,
      footerNode: footerNode,
      prevButton: prevButton,
      closeButton: closeButton,
      skipButton: skipButton,
      submitButton: submitButton
    };
  };
  var createSuccessMessage = function createSuccessMessage(message, layoutConfig) {
    var bg_color = layoutConfig.success_message_bg_color,
      icon_color = layoutConfig.success_message_icon_color,
      text_color = layoutConfig.success_message_text_color;
    var root = document.createElement("div");
    root.style = "display:flex;justify-content:center;align-items:center;flex-direction:column;width:100%;height:100%;background: ".concat(bg_color, "; min-height:480px");

    //font size for check mark is set to 30px otherwise it look stretched.
    root.innerHTML = "\n  <div>\n    ".concat(getCheckMarkSVG(64, 64, icon_color), "\n  </div>\n  <div style=\"font-size: 17px;margin-top:15px;color:").concat(text_color, "\">").concat(message, "</div>\n  ");
    return root;
  };

  var Logger$5 = window.ApxorLogger;
  var Choice = /*#__PURE__*/_createClass$1(function Choice(choice) {
    var _this = this;
    _classCallCheck$1(this, Choice);
    _defineProperty$1(this, "resetState", function () {
      _this.is_selected = false;
      _this.other_answer = null;
    });
    var id = choice.id,
      value = choice.value,
      is_other = choice.is_other,
      next_question_id = choice.next_question_id;
    if (!id || !value) {
      throw new Error("Invalid Choice");
    }
    this.id = id;
    this.value = value;
    this.is_other = is_other;
    this.next_question_id = next_question_id;
    this.is_selected = false;
    this.other_answer = null;
  });
  var Question = /*#__PURE__*/_createClass$1(function Question(questionJson) {
    var _this2 = this;
    _classCallCheck$1(this, Question);
    _defineProperty$1(this, "resetState", function () {
      _this2.is_answered = false;
      _this2.text_answer = "";
      _this2.selected_rating = -1;
      _this2.choices.forEach(function (choice) {
        return choice.resetState();
      });
    });
    var id = questionJson.id,
      answer_mode = questionJson.answer_mode,
      title = questionJson.title,
      is_required = questionJson.is_required,
      submit_text = questionJson.submit_text,
      rating_style = questionJson.rating_style,
      rating_scale = questionJson.rating_scale,
      _questionJson$choices = questionJson.choices,
      choiceList = _questionJson$choices === void 0 ? [] : _questionJson$choices,
      _questionJson$text_co = questionJson.text_config,
      text_config = _questionJson$text_co === void 0 ? null : _questionJson$text_co,
      _questionJson$randomi = questionJson.randomize_choices,
      randomize_choices = _questionJson$randomi === void 0 ? false : _questionJson$randomi,
      _questionJson$respons = questionJson.response_cfg,
      response_cfg = _questionJson$respons === void 0 ? {} : _questionJson$respons,
      advanced_options = questionJson.advanced_options,
      _questionJson$rules = questionJson.rules,
      rules = _questionJson$rules === void 0 ? [] : _questionJson$rules;
    if (!id || !answer_mode) {
      throw new Error("Invalid question");
    }
    var mode = -1;
    switch (answer_mode) {
      case "single_choice":
        mode = ANSWER_TYPES.SINGLE_CHOICE;
        break;
      case "multi_choice":
        mode = ANSWER_TYPES.MULTI_CHOICE;
        break;
      case "text":
        mode = ANSWER_TYPES.SHORT_ANSWER;
        break;
      case "rating":
        mode = ANSWER_TYPES.RATING;
        break;
      default:
        mode = -1;
        break;
    }
    this.answerMode = mode;
    this.id = id;
    this.is_required = is_required;
    this.submit_text = submit_text;
    this.randomize_choices = randomize_choices;
    this.response_cfg = response_cfg;
    this.text_config = text_config;
    this.title = title;
    this.rating_style = rating_style;
    this.rating_scale = rating_scale;
    this.is_answered = false;
    // text_answer
    this.selected_rating = -1;
    this.rules = rules;
    this.rulesArray = [];
    if (advanced_options) {
      this.rules.forEach(function (rule) {
        if (questionJson[rule.qid]) {
          var ruleObj = {
            max: rule.max,
            min: rule.min,
            question: questionJson[rule.qid]
          };
          _this2.rulesArray.push(ruleObj);
        }
      });
    }
    this.choices = [];
    if (this.answerMode === ANSWER_TYPES.SINGLE_CHOICE || this.answerMode === ANSWER_TYPES.MULTI_CHOICE) {
      var _this$choices;
      var otherChoices = [];
      for (var i = 0; i < choiceList.length; i++) {
        var choice = new Choice(choiceList[i]);
        if (choice.is_other) {
          otherChoices.push(choice);
        } else {
          this.choices.push(choice);
        }
      }
      if (randomize_choices) {
        this.choices = getShuffledArr(this.choices);
      }
      (_this$choices = this.choices).push.apply(_this$choices, otherChoices);
    }
  });
  var SurveyConfigItem = /*#__PURE__*/_createClass$1(function SurveyConfigItem() {
    var _this3 = this;
    _classCallCheck$1(this, SurveyConfigItem);
    _defineProperty$1(this, "initialize", function (configId, name, uiJson) {
      var delay = uiJson.delay,
        _uiJson$dialog_config = uiJson.dialog_config,
        dialog_config = _uiJson$dialog_config === void 0 ? null : _uiJson$dialog_config,
        _uiJson$show_progress = uiJson.show_progress_bar,
        show_progress_bar = _uiJson$show_progress === void 0 ? true : _uiJson$show_progress,
        _uiJson$is_response_b = uiJson.is_response_based_survey,
        is_response_based_survey = _uiJson$is_response_b === void 0 ? false : _uiJson$is_response_b,
        _uiJson$questions = uiJson.questions,
        questionsList = _uiJson$questions === void 0 ? [] : _uiJson$questions,
        _uiJson$show_success_ = uiJson.show_success_message,
        show_success_message = _uiJson$show_success_ === void 0 ? true : _uiJson$show_success_,
        _uiJson$auto_hide_mes = uiJson.auto_hide_message,
        auto_hide_message = _uiJson$auto_hide_mes === void 0 ? 2000 : _uiJson$auto_hide_mes,
        _uiJson$success_messa = uiJson.success_message,
        success_message = _uiJson$success_messa === void 0 ? "" : _uiJson$success_messa,
        _uiJson$question_text = uiJson.question_text_color,
        question_text_color = _uiJson$question_text === void 0 ? "#002845" : _uiJson$question_text,
        _uiJson$submit_active = uiJson.submit_active_color,
        submit_active_color = _uiJson$submit_active === void 0 ? "#017DFD" : _uiJson$submit_active,
        _uiJson$submit_inacti = uiJson.submit_inactive_color,
        submit_inactive_color = _uiJson$submit_inacti === void 0 ? "#017DFD65" : _uiJson$submit_inacti,
        _uiJson$option_bg_typ = uiJson.option_bg_type,
        option_bg_type = _uiJson$option_bg_typ === void 0 ? "filled" : _uiJson$option_bg_typ,
        _uiJson$option_text_c = uiJson.option_text_color_active,
        option_text_color_active = _uiJson$option_text_c === void 0 ? "#002845" : _uiJson$option_text_c,
        _uiJson$option_text_c2 = uiJson.option_text_color_inactive,
        option_text_color_inactive = _uiJson$option_text_c2 === void 0 ? "#002845" : _uiJson$option_text_c2,
        _uiJson$option_bg_col = uiJson.option_bg_color_active,
        option_bg_color_active = _uiJson$option_bg_col === void 0 ? "#FFF" : _uiJson$option_bg_col,
        _uiJson$option_bg_col2 = uiJson.option_bg_color_inactive,
        option_bg_color_inactive = _uiJson$option_bg_col2 === void 0 ? "#FFF" : _uiJson$option_bg_col2,
        _uiJson$question_back = uiJson.question_background_color,
        question_background_color = _uiJson$question_back === void 0 ? "#FFF" : _uiJson$question_back,
        _uiJson$success_messa2 = uiJson.success_message_bg_color,
        success_message_bg_color = _uiJson$success_messa2 === void 0 ? "#109B15" : _uiJson$success_messa2,
        _uiJson$success_messa3 = uiJson.success_message_icon_color,
        success_message_icon_color = _uiJson$success_messa3 === void 0 ? "#109B15" : _uiJson$success_messa3,
        _uiJson$success_messa4 = uiJson.success_message_text_color,
        success_message_text_color = _uiJson$success_messa4 === void 0 ? "#002845" : _uiJson$success_messa4,
        _uiJson$skip_text_col = uiJson.skip_text_color,
        skip_text_color = _uiJson$skip_text_col === void 0 ? "#017DFD" : _uiJson$skip_text_col,
        _uiJson$cancel_button = uiJson.cancel_button_color,
        cancel_button_color = _uiJson$cancel_button === void 0 ? "#000" : _uiJson$cancel_button,
        _uiJson$previous_butt = uiJson.previous_button_color,
        previous_button_color = _uiJson$previous_butt === void 0 ? "#000" : _uiJson$previous_butt,
        _uiJson$progress_bar_ = uiJson.progress_bar_color,
        progress_bar_color = _uiJson$progress_bar_ === void 0 ? "#017DFD" : _uiJson$progress_bar_,
        _uiJson$submit_text_c = uiJson.submit_text_color,
        submit_text_color = _uiJson$submit_text_c === void 0 ? "#FFF" : _uiJson$submit_text_c,
        _uiJson$width = uiJson.width,
        width = _uiJson$width === void 0 ? 350 : _uiJson$width,
        _uiJson$min_height = uiJson.min_height,
        min_height = _uiJson$min_height === void 0 ? 40 : _uiJson$min_height,
        _uiJson$position = uiJson.position,
        position = _uiJson$position === void 0 ? "center" : _uiJson$position,
        _uiJson$dim_backgroun = uiJson.dim_background,
        dim_background = _uiJson$dim_backgroun === void 0 ? true : _uiJson$dim_backgroun,
        _uiJson$dim_bg_color = uiJson.dim_bg_color,
        dim_bg_color = _uiJson$dim_bg_color === void 0 ? "#313131" : _uiJson$dim_bg_color,
        _uiJson$dim_bg_opacit = uiJson.dim_bg_opacity,
        dim_bg_opacity = _uiJson$dim_bg_opacit === void 0 ? 0.54 : _uiJson$dim_bg_opacit;
      _this3.configId = configId;
      _this3.name = name;
      _this3.delay = delay;
      _this3.is_response_based_survey = is_response_based_survey;
      _this3.show_success_message = show_success_message;
      _this3.success_message = success_message;
      _this3.auto_hide_message = auto_hide_message;
      _this3.questions = [];
      _this3.displayedQuestionIndeces = [];
      _this3.answered_questions = [];
      _this3.width = width;
      _this3.min_height = min_height;
      _this3.layoutConfig = {
        show_progress_bar: show_progress_bar,
        skip_text_color: skip_text_color,
        cancel_button_color: cancel_button_color,
        previous_button_color: previous_button_color,
        progress_bar_color: progress_bar_color,
        submit_text_color: submit_text_color,
        submit_active_color: submit_active_color,
        submit_inactive_color: submit_inactive_color,
        success_message_bg_color: success_message_bg_color,
        success_message_icon_color: success_message_icon_color,
        success_message_text_color: success_message_text_color,
        position: position,
        dim_background: dim_background,
        dim_bg_color: dim_bg_color,
        dim_bg_opacity: dim_bg_opacity
      };
      _this3.questionConfig = {
        question_text_color: question_text_color,
        question_background_color: question_background_color,
        option_bg_color_active: option_bg_color_active,
        option_bg_color_inactive: option_bg_color_inactive,
        option_text_color_active: option_text_color_active,
        option_text_color_inactive: option_text_color_inactive,
        option_bg_type: option_bg_type
      };
      if (dialog_config) {
        _this3.dialog_config = dialog_config;
      }
      for (var i = 0; i < questionsList.length; i++) {
        try {
          // We are adding this line because Request Survey and Success Message are also included in the questions list
          if (questionsList[i].answer_mode === "request_survey" || questionsList[i].answer_mode === "success_message") {
            continue;
          }
          _this3.questions.push(new Question(questionsList[i]));
          _this3.answered_questions.push(-1);
        } catch (e) {
          Logger$5.error("Failed to parse Q", i, e);
          return false;
        }
      }
      if (_this3.questions.length < 1) {
        _this3.isValid = false;
        return false;
      }
      return true;
    });
    _defineProperty$1(this, "showSurvey", function (onShown, onDismiss) {
      if (!_this3.isValid) {
        return;
      }
      setTimeout(function () {
        try {
          var rtmInstance = window.ApxorRTM;
          if (rtmInstance.currentAction !== null && rtmInstance.currentAction !== undefined) {
            Logger$5.error("An action is already being shown.");
            return;
          }
          _this3.startTime = Date.now();
          var dialog = createDialog(_this3.width, _this3.min_height, onDismiss, _this3.layoutConfig, _this3.questionConfig);
          _this3.bodyOverflow = document.body.style.overflow;
          document.body.style.overflow = "hidden";
          _this3._logSurveyAppEvent("apx_survey_launched", {
            apx_survey_type: true
          });
          if (_this3.dialog_config) {
            // Show Dialog
            // Manually enfore the delay to make sure the animation works properly
            var _this3$dialog_config = _this3.dialog_config,
              _this3$dialog_config$ = _this3$dialog_config.icon_name,
              icon_name = _this3$dialog_config$ === void 0 ? "" : _this3$dialog_config$,
              icon_width = _this3$dialog_config.icon_width,
              icon_height = _this3$dialog_config.icon_height;
            var dialogContent = dialog.children[0];
            dialog.style.visibility = "hidden";
            dialogContent.style.visibility = "hidden";
            setTimeout(function () {
              var _this3$dialog_config2;
              //set the background of the survey request.
              if (_this3 !== null && _this3 !== void 0 && (_this3$dialog_config2 = _this3.dialog_config) !== null && _this3$dialog_config2 !== void 0 && _this3$dialog_config2.dialog_background_color) {
                dialogContent.style.backgroundColor = _this3.dialog_config.dialog_background_color;
              }
              dialogContent.innerHTML = generateRequestSurvey(_this3.dialog_config);
              document.getElementById(APX_DIALOG_YES).onclick = function () {
                _this3._logSurveyAppEvent("apx_survey_dialog_yes_clicked", {
                  apx_survey_type: true
                });

                // Reset the minimum height to 40%
                dialogContent.style.minHeight = _this3.min_height + "%";
                _this3._showQuestions(dialog, true);
              };
              document.getElementById(APX_DIALOG_NO).onclick = function () {
                _this3._logSurveyAppEvent("apx_survey_dialog_no_clicked", {
                  apx_survey_type: true
                });

                // Without displaying any further questions, by default close the dialog
                _this3._closeDialog(dialog);
              };
              var showDialog = function showDialog() {
                dialog.style.visibility = "visible";
                dialogContent.style.visibility = "visible";
                dialogContent.style.minHeight = icon_name === "" || icon_width === 0 || icon_height === 0 ? "13%" : "25%";

                // This enables the animation
                dialogContent.classList.toggle("open");

                // Log Launch event
                _this3._logSurveyAppEvent("apx_survey_dialog_launched", {
                  apx_survey_type: _this3.is_response_based_survey ? "response_based" : "default"
                });
              };
              if (icon_name !== "" && icon_width > 0 && icon_height > 0) {
                var icon = document.getElementById("apx_icon");
                icon.onload = function () {
                  showDialog();
                };
                icon.onerror = function () {
                  _this3._logSurveyAppEvent("apx_survey_dialog_icon_failed");
                  _this3._closeDialog(dialog);
                };
              } else {
                showDialog();
              }
            }, 100);
          } else {
            // Show the survey directly
            _this3._showQuestions(dialog);
          }
          if (onShown) onShown(function () {
            return _this3._closeDialog(dialog);
          });
        } catch (e) {
          Logger$5.error(e);
        }
      }, _this3.delay);
    });
    _defineProperty$1(this, "_showQuestions", function (dialog) {
      var fromDialog = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var _this3$layoutConfig = _this3.layoutConfig,
        show_progress_bar = _this3$layoutConfig.show_progress_bar,
        progress_bar_color = _this3$layoutConfig.progress_bar_color;
      var progressBar = document.createElement("div");
      progressBar.className = "apx-progress-bar";
      progressBar.style = "height:4px;overflow:hidden;position:relative;background:white;";
      var bar = document.createElement("div");
      bar.setAttribute("id", "apx-pb");
      bar.style = "border-radius:10px;top:0;left:0;width:100%;bottom:0;position:absolute;transition:transform 0.4s linear;transform-origin:left;background-color:".concat(progress_bar_color);
      progressBar.appendChild(bar);
      if (!show_progress_bar) {
        progressBar.style.visibility = "hidden";
      }
      var content = dialog.children[0];
      // FIXME: The second condition is useless as of now but not sure though, remove it if not needed
      if (fromDialog || content && content.childElementCount > 1) {
        // Remove previous question
        content.removeChild(content.children[content.childElementCount - 1]);
      }

      // By default add the progress bar to the dialog content
      content.appendChild(progressBar);
      _this3._displayQuestion(dialog, 0);
      if (!fromDialog) {
        // If the dialog is not enabled, we manually enfore the delay to make sure animation is seen by users
        setTimeout(function () {
          dialog.children[0].classList.toggle("open");
        }, 100);
      }
    });
    // From a given question id, finds out its index from the global questions list
    _defineProperty$1(this, "_getQuestionIndexFromId", function (question_id) {
      if (question_id == -1 || !question_id) {
        return -1;
      }
      var noOfQuestions = _this3.questions.length;
      if (noOfQuestions > 0) {
        for (var questionIndex = 0; questionIndex < noOfQuestions; questionIndex++) {
          if (_this3.questions[questionIndex].id == question_id) {
            return questionIndex;
          }
        }
      }
      return -1;
    });
    // For a response based survey, every choice in a question has a next question id associated with it.
    // This function returns the index of that next question from the global questions list.
    _defineProperty$1(this, "_getNextQuestionIndex", function (question, index) {
      var answerMode = question.answerMode,
        _question$choices = question.choices,
        choices = _question$choices === void 0 ? [] : _question$choices;
      // If the answer type is "MULTI_CHOICE","SHORT_ANSWER" next question id can not be configured.
      switch (answerMode) {
        case ANSWER_TYPES.RATING:
          {
            var next_question_id = question === null || question === void 0 ? void 0 : question.response_cfg[(question === null || question === void 0 ? void 0 : question.selected_rating) || 11];
            if (!next_question_id) {
              index = index + 1;
            } else {
              index = _this3._getQuestionIndexFromId(next_question_id);
            }
            break;
          }
        case ANSWER_TYPES.SINGLE_CHOICE:
          {
            var selectedChoice;
            choices.forEach(function (choice) {
              if (choice.is_selected) {
                selectedChoice = choice;
              }
            });
            if (!selectedChoice) {
              index = index + 1;
            } else {
              var _selectedChoice = selectedChoice,
                _next_question_id = _selectedChoice.next_question_id;
              index = _this3._getQuestionIndexFromId(_next_question_id);
            }
            break;
          }
        case ANSWER_TYPES.MULTI_CHOICE:
        case ANSWER_TYPES.SHORT_ANSWER:
        default:
          index = index + 1;
          break;
      }
      return index;
    });
    _defineProperty$1(this, "_displayQuestion", function (dialog, index) {
      var _this3$questionConfig;
      if (index >= _this3.questions.length) {
        // Submit the survey
        return;
      }
      var question = _this3.questions[index];
      var _getSurveyDialogConte = getSurveyDialogContent(_this3.layoutConfig, _this3.questionConfig, question, index, _this3.questions.length, _this3.is_response_based_survey),
        _getSurveyDialogConte2 = _getSurveyDialogConte.prevButton,
        prevButton = _getSurveyDialogConte2 === void 0 ? null : _getSurveyDialogConte2,
        _getSurveyDialogConte3 = _getSurveyDialogConte.closeButton,
        closeButton = _getSurveyDialogConte3 === void 0 ? null : _getSurveyDialogConte3,
        _getSurveyDialogConte4 = _getSurveyDialogConte.submitButton,
        submitButton = _getSurveyDialogConte4 === void 0 ? null : _getSurveyDialogConte4,
        _getSurveyDialogConte5 = _getSurveyDialogConte.skipButton,
        skipButton = _getSurveyDialogConte5 === void 0 ? null : _getSurveyDialogConte5,
        questionRoot = _getSurveyDialogConte.questionRoot,
        footerNode = _getSurveyDialogConte.footerNode;
      var content = dialog.children[0];
      if (content && content.childElementCount > 2) {
        // Remove previous question if already added
        content.removeChild(content.children[content.childElementCount - 1]);
        content.removeChild(content.children[content.childElementCount - 1]);
      }

      //set the question_background_color as background of the container
      if (_this3 !== null && _this3 !== void 0 && (_this3$questionConfig = _this3.questionConfig) !== null && _this3$questionConfig !== void 0 && _this3$questionConfig.question_background_color) {
        content.style.backgroundColor = _this3.questionConfig.question_background_color;
      }

      // Increase or Decrease the progress bar value
      var bar = document.getElementById("apx-pb");
      bar.style.transform = "translateX(".concat(-(100 - 100 / _this3.questions.length * (index + 1)), "%)");
      content.appendChild(questionRoot);
      content.appendChild(footerNode);

      // ===== Attach Click Listeners to the available buttons START =====

      // For every button click, we log the question event by default
      // if the user answers the question and not willing to proceed further
      // or goes back to previous question or closes the survey

      if (prevButton) {
        prevButton.onclick = function () {
          _this3._logSurveyAppEvent("apx_survey_back_button_clicked", {
            apx_question_id: "",
            apx_question_name: "",
            apx_question_type: "",
            apx_question_position: 2,
            apx_survey_type: ""
          });
          _this3._logSurveyQuestionEvent(index);
          var previousIndex = _this3.displayedQuestionIndeces.pop();
          if (previousIndex === undefined) {
            return;
          }
          // Display previous question
          _this3._displayQuestion(dialog, previousIndex);
        };
      }
      if (closeButton) {
        closeButton.addEventListener("click", function () {
          // This is a legacy event. Should be removed soon, when all customers move to the new event
          _this3._logSurveyAppEvent("apx_survey_close_clicked", {
            where: "question " + (index + 1)
          });
          _this3._logSurveyAppEvent("apx_survey_close_button_clicked", {
            apx_survey_type: true,
            apx_time_to_complete: 200,
            where: "question " + (index + 1)
          });
          _this3._logSurveyQuestionEvent(index);
          _this3._submitSurveyResponses(dialog, false);
        });
      }
      if (submitButton) {
        submitButton.onclick = function () {
          _this3.displayedQuestionIndeces.push(index);
          // Check if there are no questions left and gather all
          // the anwers from choices based on the answer_mode
          // and send the data to server
          if (!_this3.is_response_based_survey) {
            _this3._logSurveyQuestionEvent(index);
            if (index === _this3.questions.length - 1) {
              // Send the response to server
              _this3._submitSurveyResponses(dialog, true);
            } else {
              // Display next question
              _this3._displayQuestion(dialog, index + 1);
            }
          } else {
            _this3._logSurveyQuestionEvent(index);
            var nextQuestionindex = _this3._getNextQuestionIndex(question, index);
            if (nextQuestionindex === _this3.questions.length || nextQuestionindex === -1) {
              // Send the response to server
              _this3._submitSurveyResponses(dialog, true);
            } else {
              // Display next question
              _this3._displayQuestion(dialog, nextQuestionindex);
            }
          }
        };
      }
      if (skipButton) {
        skipButton.onclick = function () {
          _this3.displayedQuestionIndeces.push(index);
          if (index + 1 >= _this3.questions.length) {
            // Generate proper HTML code dude, are you nuts?
            return;
          }

          // This is a legacy event. Should be removed soon, when all customers move to the new event
          _this3._logSurveyAppEvent("apx_survey_skip_clicked", {
            where: "question " + (index + 1)
          });
          _this3._logSurveyAppEvent("apx_survey_skip_button_clicked", {
            apx_question_id: "",
            apx_question_name: "",
            apx_question_type: "",
            apx_question_position: 2,
            apx_survey_type: "",
            where: "question " + (index + 1)
          });
          _this3._logSurveyQuestionEvent(index);

          // Display next question
          _this3._displayQuestion(dialog, index + 1);
        };
      }
      _this3._logSurveyAppEvent("apx_survey_question_asked", {
        apx_question_id: "",
        apx_question_name: "",
        apx_question_type: "",
        apx_question_position: 2,
        apx_survey_type: ""
      });
      // ===== Attach Click Listeners to the available buttons END =====
    });
    _defineProperty$1(this, "_attributeForApxSurveyQuestionAnswered", function (index) {
      var obj = {};
      if (_this3.questions[index].answerMode === 3) {
        var _this3$questions$inde, _this3$questions$inde2, _this3$questions$inde3, _this3$questions$inde4, _this3$questions$inde5;
        obj["apx_nps_advanced_question"] = (_this3$questions$inde = (_this3$questions$inde2 = _this3.questions[index].rulesArray) === null || _this3$questions$inde2 === void 0 || (_this3$questions$inde2 = _this3$questions$inde2[0]) === null || _this3$questions$inde2 === void 0 ? void 0 : _this3$questions$inde2.question.question) !== null && _this3$questions$inde !== void 0 ? _this3$questions$inde : "";
        obj["apx_nps_advanced_choice"] = [];
        obj["apx_nps_advanced_free_text"] = [];
        if ((_this3$questions$inde3 = _this3.questions[index]) !== null && _this3$questions$inde3 !== void 0 && _this3$questions$inde3.text_answer) obj["apx_nps_advanced_free_text"].push(_this3.questions[index].text_answer);
        obj["apx_nps_advanced_question_id"] = (_this3$questions$inde4 = (_this3$questions$inde5 = _this3.questions[index].rules) === null || _this3$questions$inde5 === void 0 || (_this3$questions$inde5 = _this3$questions$inde5[0]) === null || _this3$questions$inde5 === void 0 ? void 0 : _this3$questions$inde5.qid) !== null && _this3$questions$inde4 !== void 0 ? _this3$questions$inde4 : "";
      }
      return obj;
    });
    /**
     * Get the answer for the given question index
     *
     * If user answers the current question, then log an app event
     */
    _defineProperty$1(this, "_logSurveyQuestionEvent", function (index) {
      if (_this3.answered_questions[index] !== -1) {
        return;
      }
      var answer = _this3._getAnswerForQuestion(index);
      var textBasedAnswers = [];
      if (answer.textBasedQuestionAnswers.length > 0) {
        answer.textBasedQuestionAnswers.forEach(function (textAnswers) {
          textBasedAnswers.push(textAnswers.answer);
        });
      }
      if (answer.answers.length > 0) {
        _this3._logSurveyAppEvent("apx_survey_question_answered", _objectSpread2$1(_objectSpread2$1({
          apx_question_id: "",
          apx_question_name: "",
          apx_question_type: "",
          apx_question_position: 2,
          apx_survey_type: "",
          apx_choice: answer.answerTexts,
          apx_choice_position: 2,
          apx_free_text: answer.textBasedQuestionAnswers
        }, _this3._attributeForApxSurveyQuestionAnswered(index)), {}, {
          apx_time_spent_to_answer: 20
        }));
        _this3._logSurveyAppEvent("apx_survey_".concat(_this3.questions[index].title), {
          answers: answer.answerTexts,
          text_answers: textBasedAnswers
        });
        _this3.answered_questions[index] = 1;
      }
    });
    /**
     * Simple util function to avoid passing the `survey_id` and `name` attributes
     * through out the code
     */
    _defineProperty$1(this, "_logSurveyAppEvent", function (name) {
      var _window$ApxorRTM;
      var attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var meta = (_window$ApxorRTM = window.ApxorRTM) === null || _window$ApxorRTM === void 0 ? void 0 : _window$ApxorRTM.getCampaignMeta(_this3.configId);
      var attrs = meta._attr;
      Apxor.logEvent(name, _objectSpread2$1(_objectSpread2$1({
        apx_survey_id: _this3.configId,
        apx_survey_name: _this3.name
      }, attributes), attrs));
    });
    /**
     * Based on the answerMode construct the answer JSON object and return it
     *
     * Single/Multi Choice:
     *    answer: {
     *      answers: [selected choice ids],
     *      answerTexts: [selected choice values],
     *      others: [{
     *        id: choice id,
     *        answer: other answer
     *      }]
     *    }
     *
     * Short Answer:
     *    answer: {
     *      answers: [choice id],
     *      answerTexts: [short answer],
     *      textBasedQuestionAnswers: [{
     *        id: choice id,
     *        answer: short answer
     *      }]
     *    }
     *
     * Rating:
     *    answer: {
     *      answers: [selected rating value],
     *      answerTexts: [selected rating value]
     *    }
     */
    _defineProperty$1(this, "_getAnswerForQuestion", function (index) {
      var question = _this3.questions[index];
      if (!question) {
        return null;
      }
      var answer = {
        answers: [],
        answerTexts: [],
        others: [],
        textBasedQuestionAnswers: []
      };
      var answerMode = question.answerMode,
        _question$choices2 = question.choices,
        choices = _question$choices2 === void 0 ? [] : _question$choices2,
        _question$selected_ra = question.selected_rating,
        selected_rating = _question$selected_ra === void 0 ? -1 : _question$selected_ra,
        _question$text_answer = question.text_answer,
        text_answer = _question$text_answer === void 0 ? "" : _question$text_answer,
        _question$is_answered = question.is_answered,
        is_answered = _question$is_answered === void 0 ? false : _question$is_answered,
        _question$text_config = question.text_config,
        text_config = _question$text_config === void 0 ? null : _question$text_config;
      switch (answerMode) {
        case ANSWER_TYPES.SINGLE_CHOICE:
        case ANSWER_TYPES.MULTI_CHOICE:
          choices.forEach(function (choice) {
            if (choice.is_selected) {
              answer.answers.push(choice.id);
              answer.answerTexts.push(choice.value);
              if (choice.is_other && choice.other_answer !== null && choice.other_answer.trim() !== "") {
                answer.others.push({
                  id: choice.id,
                  answer: choice.other_answer
                });
              }
            }
          });
          break;
        case ANSWER_TYPES.SHORT_ANSWER:
          if (is_answered && text_answer !== "" && text_answer.trim() !== "" && text_config !== null) {
            answer.answers.push(text_config.id);
            answer.answerTexts.push(text_answer);
            answer.textBasedQuestionAnswers.push({
              id: text_config.id,
              answer: text_answer
            });
          }
          break;
        case ANSWER_TYPES.RATING:
          if (selected_rating !== -1) {
            answer.answers.push(selected_rating);
            answer.answerTexts.push(selected_rating);
          }
          break;
      }
      return answer;
    });
    _defineProperty$1(this, "_closeDialog", function (dialog) {
      // Close the dialog and submit the survey
      if (dialog[SURVEY_ON_DISMISS]) dialog[SURVEY_ON_DISMISS]();
      dialog.children[0].classList.toggle("open");
      setTimeout(function () {
        dialog.parentNode.removeChild(dialog);
        document.body.style.overflow = _this3.bodyOverflow;
        _this3.bodyOverflow = "";
      }, 400);
    });
    _defineProperty$1(this, "_showSuccessMessage", function (dialog) {
      var content = dialog.children[0];
      content.style.minHeight = "unset";
      while (content !== null && content !== void 0 && content.childElementCount) {
        content.removeChild(content.children[content.childElementCount - 1]);
      }
      var successMessageNode = createSuccessMessage(_this3.success_message, _this3.layoutConfig);
      content.appendChild(successMessageNode);
      setTimeout(function () {
        _this3._closeDialog(dialog);
      }, _this3.auto_hide_message);
    });
    /**
     * Construct the request body and send it to server
     *
     * Request Body:
     *  {
     *    survey_id: id,
     *    name: name,
     *    responses: [list of answers],
     *    time_taken: in seconds,
     *    session_id,
     *    is_completed,
     *    app_version,
     *    device_uuid,
     *    launch_time,
     *    user_attributes,
     *    session_attributes
     *  }
     */
    _defineProperty$1(this, "_submitSurveyResponses", function (dialog, is_completed) {
      if (is_completed && _this3.show_success_message) {
        // Display success message if it is supposed to be shown
        _this3._showSuccessMessage(dialog);
      } else {
        _this3._closeDialog(dialog);
      }

      // Prepare survey data and send to server
      var response = {
        survey_id: _this3.configId,
        name: _this3.name,
        responses: []
      };
      _this3.questions.forEach(function (question, index) {
        var answer = _this3._getAnswerForQuestion(index);
        if (answer.answers.length > 0) {
          var data = {
            question_id: question.id,
            answers: answer.answers
          };
          if (question.rules.length > 0) {
            question.rulesArray.forEach(function (rule) {
              if (question.selected_rating >= rule.min && question.selected_rating <= rule.max) {
                var text_config = rule.question.text_config;
                var text_answer = question.text_answer;
                data.answers = [].concat(_toConsumableArray(data.answers), [text_config.id]);
                var advancedQuestion = {
                  id: text_config.id,
                  answer: text_answer
                };
                if (!data.others) {
                  data.others = [];
                }
                data.others.push(advancedQuestion);
              }
            });
          }
          if (answer.others.length > 0) {
            data.others = answer.others;
          } else if (answer.textBasedQuestionAnswers.length > 0) {
            data.others = answer.textBasedQuestionAnswers;
          }
          response.responses.push(data);
        }
      });
      if (response.responses.length > 0) {
        var power = Math.pow(10, 3);
        response.time_taken = Math.round((Date.now() - _this3.startTime) / 1000 * power) / power;
        var controller = Apxor.getController();
        var _controller$getFromSt = controller.getFromStorage("_apx_cd", true),
          launch_time = _controller$getFromSt.session_info.launch_time;
        response.session_id = Apxor.getSessionId();
        response.is_completed = is_completed;
        response.app_version = controller.getFromStorage("apx_ver", false);
        response.device_uuid = Apxor.getClientId();
        response.launch_time = launch_time;
        response.user_attributes = controller.getUserAttributes();
        response.session_attributes = controller.getSessionAttributes();
        _this3._sendReponseToServer(response);
      }
      if (is_completed) {
        _this3._logSurveyAppEvent("apx_survey_completed", {
          apx_survey_type: true,
          apx_time_to_complete: 200
        });
      }

      // Reset questions state
      _this3.questions.forEach(function (question, index) {
        question.resetState();
        _this3.answered_questions[index] = -1;
      });
      _this3.startTime = -1;
      _this3.bodyOverflow = "";
    });
    _defineProperty$1(this, "_sendReponseToServer", function (data) {
      var surveysResponseUrl = SURVEY_RESPONSE_URL.replace("<app_id>", Apxor.getSiteId());
      fetch(surveysResponseUrl, {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify(data)
      });
    });
    this.isValid = true;
    this.dialog_config = null;
  });

  var ApxorSurveys = /*#__PURE__*/_createClass$1(function ApxorSurveys() {
    _classCallCheck$1(this, ApxorSurveys);
    _defineProperty$1(this, "parse", function (configId, name, uiJson) {
      // Parses the JSON and returns an instance of SurveyConfigItem
      // which will be used to show the survey
      var configItem = new SurveyConfigItem();
      if (configItem.initialize(configId, name, uiJson)) {
        return configItem;
      }
      return null;
    });
  });

  /**
   * @constructor PIPButton
   * @example
   * Example of a pip button model is
   *
   * pip_button: {
   *  color: "#172B4D",
   *  fill_color: "#FFFFFF",
   *  type: "normal/filled/custom",
   *  path: "<assets-path>",
   *  offset_top: 8,
   *  offset_right: 8,
   *  height: 20,
   *  width: 20,
   *  action: "cancel/dismiss",
   * }
   */
  var PIPButton = /*#__PURE__*/function () {
    function PIPButton() {
      var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck$1(this, PIPButton);
      this.color = getColorOrDefault(data.color, "#FFFFFF");
      this.fill_color = getColorOrDefault(data.fill_color, "#FFFFFF");
      this.type = getStringOrDefault(data.type, "normal");
      this.path = data.path;
      this.offset_top = getNumberOrDefault(data.offset_top, 8);
      this.offset_right = getNumberOrDefault(data.offset_right, 8);
      this.height = getNumberOrDefault(data.height, 24);
      this.width = getNumberOrDefault(data.width, 24);
      this.action = getStringOrDefault(data.action, "dismiss");
    }
    _createClass$1(PIPButton, null, [{
      key: "isEnabled",
      value: function isEnabled(data) {
        if (isUndefined$1(data) || isNull(data) || isEmptyObject(data)) {
          return false;
        } else {
          return true;
        }
      }
    }]);
    return PIPButton;
  }();

  /**
   * @constructor PIP
   * @example
   * Example of a Arrow model is
   *
   * {
   *  enable_toggles : true,
   *  enable_pip : true
   * }
   */
  var PIP = /*#__PURE__*/function () {
    function PIP() {
      var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck$1(this, PIP);
      this.enable_toggles = data.enable_toggles;
    }
    _createClass$1(PIP, null, [{
      key: "isEnabled",
      value: function isEnabled(data) {
        if (isUndefined$1(data) || isNull(data) || isEmptyObject(data)) {
          return false;
        } else {
          return true;
        }
      }
    }]);
    return PIP;
  }();

  /**
   * @constructor EmbeddedVideo
   * @example
   * Example of a EmbeddedVideo model is
   *
   * embed: {
   *   html : "<iframe><video></video></iframe>",
   * }
   */
  var EmbeddedVideo = /*#__PURE__*/_createClass$1(function EmbeddedVideo() {
    var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    _classCallCheck$1(this, EmbeddedVideo);
    this.html = data.html;
  });

  /**
   * @constructor Video
   * @example
   * Example of a Video model is
   *
   * video: {
   *  path: "<assets-path>",
   *  height: 360,
   *  width: 360,
   *  enable_border : true,
   *  border: {
   *    enable : true,
   *    radius : 50,
   *    color : "#FFFFFF",
   *    width : 2,
   *    style : "dotted"
   *  },
   *  enable_embed : true,
   *  embed: {
   *   enable : true,
   *   html : "<iframe><video></video></iframe>",
   *  },
   *  enable_audio:true
   * }
   */
  var Video = /*#__PURE__*/function () {
    function Video() {
      var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck$1(this, Video);
      this.path = getStringOrDefault(data.path, "");
      this.width = getNumberOrDefault(data.width, 360);
      this.height = getNumberOrDefault(data.height, 360);
      this.enable_embed = data.enable_embed;
      this.embed = new EmbeddedVideo(data.embed);
      this.enable_border = data.enable_border;
      this.border = new Border(data.border);
      this.enable_audio = data.enable_audio;
      this.format = getStringOrDefault(data.format, "video/mp4");
    }
    _createClass$1(Video, null, [{
      key: "isEnabled",
      value: function isEnabled(data) {
        if (isUndefined$1(data) || isNull(data) || isEmptyObject(data)) {
          return false;
        } else {
          return true;
        }
      }
    }]);
    return Video;
  }();

  var Logger$4 = window.ApxorLogger;
  var VideoInApp = /*#__PURE__*/function () {
    /**
     * @class VideoInApp
     * @param {JSON} config
     * @param {function} showCallback
     * @param {function} hideCallback
     */
    function VideoInApp(config, terminationConfig, configId, name, showCallback, _hideCallback) {
      var _this = this;
      _classCallCheck$1(this, VideoInApp);
      /**
       * @function showVideoInApp
       * @description Shows the video InApp with the configured mode.
       */
      _defineProperty$1(this, "showVideoInApp", function () {
        _this.createPlayer();
        try {
          // In PIP mode, only after the video metadata is loaded, show the PIP.
          if (_this.mode == VIDEOS_MODES.PIP) {
            var video = _this.videoElement;
            var hideCallback = _this.hideCallback;
            video.onloadedmetadata = function () {
              var _this2 = this;
              video.disablePictureInPicture = false;
              video.requestPictureInPicture().then(function () {
                video.play();
              })["catch"](function (error) {
                Logger$4.error("Can't show PIP:".concat(error));
                Apxor.logEvent("apx_video_inapp_failed", {
                  campaignName: _this2.name,
                  id: _this2.configId,
                  failureReason: error
                });
                hideCallback();
              });
            };
            video.onabort = function () {
              Logger$4.error("Can't show video: resource is not fully loaded");
              Apxor.logEvent("apx_video_inapp_failed", {
                campaignName: this.name,
                id: this.configId,
                failureReason: "Can't show video, meta data not loaded"
              });
              this.hideCallback();
            };
            video.onstalled = function () {
              Logger$4.error("Can't show video: data is unexpectedly not forthcoming");
              Apxor.logEvent("apx_video_inapp_failed", {
                campaignName: this.name,
                id: this.configId,
                failureReason: "Can't show video, data is unexpectedly not forthcoming"
              });
              this.hideCallback();
            };
          } else {
            // As the video player is hidden by default, unhide if the mode is not PIP.
            _this.unhideVideoPlayer();
          }
          _this.showCallback();
        } catch (e) {
          Logger$4.error("Can't show video:".concat(e));
          Apxor.logEvent("apx_video_inapp_failed", {
            campaignName: _this.name,
            id: _this.configId,
            failureReason: e
          });
          _this.hideCallback();
        }
      });
      /**
       * @function _getHeightWidthFromResolution
       * @private
       * @description Sets the height and width of the video element.
       * For portrait - width is set to 50% of the screen and height is auto adjusted based on resolution.
       * For landscape - height is set to 50% of the screen and width is auto adjusted based on resolution.
       */
      _defineProperty$1(this, "_getHeightWidthFromResolution", function () {
        var _getHeightWidthFromRe = getHeightWidthFromResolution(_this.video),
          width = _getHeightWidthFromRe.width,
          height = _getHeightWidthFromRe.height;
        _this.height = height;
        _this.width = width;
      });
      /**
       * @function _removeVideoPlayerStyles
       * @private
       * @description Removes the video player style element.
       */
      _defineProperty$1(this, "_removeVideoPlayerStyles", function () {
        var playerStyles = document.getElementById("apx-mpl-styles");
        if (playerStyles) {
          playerStyles.remove();
        }
      });
      /**
       * @function _setVideoControlListeners
       * @private
       * @description Attach listeners on the video controls
       */
      _defineProperty$1(this, "_setVideoControlListeners", function () {
        // Listener for the video end. Display the CTA's when the video ends.
        _this.videoElement.addEventListener("ended", function () {
          var ctaButtons = document.getElementById("apx-cta-btn");
          if (ctaButtons) {
            ctaButtons.classList.remove("apx-video-hide-elmt".concat(_this.cssPostFix));
          }
          if (!document.fullscreenElement) {
            _this.totalDurationMinimised += Math.round(_this.videoElement.duration) - Math.round(_this.slotStartTime);
            _this.durationMinimisedSlots.push("".concat(Math.round(_this.slotStartTime), "-").concat(Math.round(_this.videoElement.duration)));
          } else {
            _this.totalDurationMaximised += Math.round(_this.videoElement.duration) - Math.round(_this.slotStartTime);
            _this.durationMaximisedSlots.push("".concat(Math.round(_this.slotStartTime), "-").concat(Math.round(_this.videoElement.duration)));
          }
        });

        // Listener for the play button. After the video ended, CTA buttons are shown.
        // If the play button is clicked again, the CTA buttons should be removed.
        _this.videoElement.addEventListener("play", function () {
          if (!_this.inAppShown) {
            // Initialize the fields to keep the track of aditional info required for logging events.
            _this.minimisedCount = 0;
            _this.maximisedCount = 0;
            _this.totalDurationMinimised = 0;
            _this.totalDurationMaximised = 0;
            _this.durationMinimisedSlots = [];
            _this.durationMaximisedSlots = [];
            _this.volumeClickedCount = 0;
            _this.slotStartTime = 0; // to tract the start time of the minimize and maximize time slot.
            _this.slotStartTimeVolumeChange = 0; // to track the start time of the volume change time slot.

            Apxor.logEvent("inapp_shown", {
              message_name: _this.name,
              visibleScreen: location.pathname,
              inappType: "PIP Inapp",
              autoReplay: _this.videoElement.loop ? "On" : "Off",
              defaultSound: _this.videoElement.muted ? "Mute" : "Unmute",
              id: _this.configId,
              videoDuration: Math.round(_this.videoElement.duration),
              videoResolution: "".concat(_this.videoElement.videoWidth, "x").concat(_this.videoElement.videoHeight),
              videoConfiguration: "Streaming"
            });
            _this.inAppShown = true;
          }
          if (_this.videoElement.currentTime === 0 || _this.videoElement.currentTime === _this.videoElement.duration) {
            _this.replayCount++;
            _this.slotStartTime = 0; // to tract the start time of the minimize and maximize time slot.
            _this.slotStartTimeVolumeChange = 0; // to track the start time of the volume change time slot.
          }

          var ctaButtons = document.getElementById("apx-cta-btn");
          if (ctaButtons) {
            ctaButtons.classList.add("apx-video-hide-elmt".concat(_this.cssPostFix));
          }
        });
        _this.videoElement.addEventListener("fullscreenchange", function () {
          _this.slotEndTime = _this.videoElement.currentTime;
          if (document.fullscreenElement) {
            _this.maximisedCount++;
            _this.durationMinimised = Math.round(_this.slotEndTime) - Math.round(_this.slotStartTime);
            if (_this.videoElement.currentTime !== _this.videoElement.duration) {
              _this.totalDurationMinimised += _this.durationMinimised;
              _this.durationMinimisedSlots.push("".concat(Math.round(_this.slotStartTime), "-").concat(Math.round(_this.slotEndTime)));
            }
            Apxor.logEvent("apx_video_inapp_maximised", {
              message_name: _this.name,
              durationMinimised: _this.durationMinimised,
              durationSlotMinimised: "".concat(Math.round(_this.slotStartTime), "-").concat(Math.round(_this.slotEndTime)),
              id: _this.configId,
              totalDurationWatched: Math.round(_this.totalDurationMinimised),
              totalDurationWatchedSlot: _this.durationMinimisedSlots,
              maximisedCount: _this.maximisedCount
            });
          } else {
            _this.durationMaximised = Math.round(_this.slotEndTime) - Math.round(_this.slotStartTime);
            _this.minimisedCount++;
            if (_this.videoElement.currentTime !== _this.videoElement.duration) {
              _this.totalDurationMaximised += _this.durationMaximised;
              _this.durationMaximisedSlots.push("".concat(Math.round(_this.slotStartTime), "-").concat(Math.round(_this.slotEndTime)));
            }
            Apxor.logEvent("apx_video_inapp_minimised", {
              message_name: _this.name,
              durationMaximised: _this.durationMaximised,
              durationSlotMaximised: "".concat(Math.round(_this.slotStartTime), "-").concat(Math.round(_this.slotEndTime)),
              id: _this.configId,
              totalDurationWatched: Math.round(_this.totalDurationMaximised),
              totalDurationWatchedSlot: _this.durationMaximisedSlots,
              minimisedCount: _this.minimisedCount
            });
          }
          _this.slotStartTime = _this.videoElement.currentTime;
        });
        _this.videoElement.addEventListener("volumechange", function () {
          if (!isNaN(_this.slotStartTimeVolumeChange)) {
            _this.volumeClickedCount++;
            Apxor.logEvent("apx_video_inapp_volume_button_clicked", {
              message_name: _this.name,
              id: _this.configId,
              actionPerformed: _this.videoElement.muted ? "mute" : "unmute",
              totalDurationWatchedSlot: "".concat(Math.round(_this.slotStartTimeVolumeChange), "-").concat(Math.round(_this.videoElement.currentTime)),
              totalDurationWatched: Math.round(_this.videoElement.currentTime) - Math.round(_this.slotStartTimeVolumeChange)
            });
            _this.slotStartTimeVolumeChange = _this.videoElement.currentTime;
          }
        });
      });
      /**
       * @function _setPIPtoggleListeners
       * @private
       * @description Attach listeners for the PIP toggle. i.e. for the PIP enter and PIP exit
       */
      _defineProperty$1(this, "_setPIPtoggleListeners", function () {
        var _this$terminationConf;
        if (_this.mode === "PIP" && !((_this$terminationConf = _this.terminationConfig) !== null && _this$terminationConf !== void 0 && _this$terminationConf.auto_dismiss)) {
          // On Exit of the PIP,
          // In PIP mode - Remove the PIP and also remove the video player from DOM
          _this.videoElement.addEventListener("leavepictureinpicture", function () {
            _this._onClose("web_pip_x_icon_clicked");
          }, false);
        } else if (_this.mode === "mini") {
          if (_this.enable_pip_button) {
            // On Enter of the PIP,
            // Hide the video player. It is not a good idea to show both video player and PIP at the same time.
            var onEnterPip = function onEnterPip() {
              _this.videoPlayer.classList.add("apx-video-hide-elmt".concat(_this.cssPostFix));
            };
            _this.videoElement.addEventListener("enterpictureinpicture", onEnterPip, false);
            // Enable the PIP toggle listeners only if the config says so.
            if (_this.pip.enable_toggles) {
              // On Exit of the PIP,
              // In Video Player mode(Note that PIP can be opened from video player) - Show the video player. It means that PIP merges to the video player.
              var onExitPip = function onExitPip() {
                _this.videoElement.disablePictureInPicture = true;
                _this.videoPlayer.classList.remove("apx-video-hide-elmt".concat(_this.cssPostFix));
              };
              _this.videoElement.addEventListener("leavepictureinpicture", onExitPip, false);
            } else {
              // on Exit of the PIP,
              // when enable_toggles are off then, perform cleanup activities(remove the video player, remove styles and set the correct rtm status.) and log events.
              _this.videoElement.addEventListener("leavepictureinpicture", function () {
                _this._onClose("web_pip_x_icon_clicked");
              }, false);
            }
          }
        }
      });
      /**
       * @function _setCustomControls
       * @private Sets the custom controls on the video player.
       * PIP and close are the custom controls that are created and positions on the video.
       */
      _defineProperty$1(this, "_setCustomControls", function () {
        _this.enable_close_button;
        if (_this.enable_close_button && !isIOSDevice()) {
          var closeButton = document.createElement("span");
          if (_this.close_button.type === CLOSE_BUTTON_STYLE.NORMAL) {
            closeButton.innerHTML = getCloseSVG(_this.close_button.width, _this.close_button.height, _this.close_button.color);
          } else if (_this.close_button.type === CLOSE_BUTTON_STYLE.FILL) {
            if (_this.close_button.shape === "circle") {
              closeButton.innerHTML = getCloseWithCircleSVG(_this.close_button.width, _this.close_button.height, _this.close_button.fill_color, _this.close_button.color);
            } else {
              closeButton.innerHTML = getCloseWithRectangleSVG(_this.close_button.width, _this.close_button.height, _this.close_button.fill_color, _this.close_button.color);
            }
          } else {
            closeButton.innerHTML = "<img src=\"".concat(_this.close_button.path, "\" width=\"").concat(_this.close_button.width, "px\" height=\"").concat(_this.close_button.height, "px\"></img>");
          }
          closeButton.classList.add("apx-video-close-btn".concat(_this.cssPostFix));
          // On click of the close button, remove the video player, remove styles and set the correct rtm status.
          closeButton.addEventListener("click", function () {
            _this._onClose();
          });
          _this.videoPlayer.appendChild(closeButton);
        }
        if (_this.enable_pip_button && !isIOSDevice()) {
          var pipButton = document.createElement("span");
          pipButton.innerHTML = getPIPSVG(_this.pip_button.width, _this.pip_button.height, _this.pip_button.color);
          if (_this.pip_button.path) {
            pipButton.innerHTML = "<img src=\"".concat(_this.pip_button.path, "\" width=\"").concat(_this.pip_button.width, "px\" height=\"").concat(_this.pip_button.height, "px\"></img>");
          }
          pipButton.classList.add("apx-video-pip-btn".concat(_this.cssPostFix));
          // PIP button click listener.
          // To remove the default PIP option of the video element, PIP is disabled.
          // When the custom PIP button is clicked, enable the PIP and request for PIP.
          pipButton.addEventListener("click", function () {
            try {
              _this.videoElement.disablePictureInPicture = false;
              _this.videoElement.requestPictureInPicture();
            } catch (e) {
              console.log("Error \n ".concat(e, " \n while starting the PIP"));
            }
          });
          _this.videoPlayer.appendChild(pipButton);
        }
      });
      /**
       * @function hideVideoPlayer
       * @description Sets the visibility of the video player to hidden.
       */
      _defineProperty$1(this, "hideVideoPlayer", function () {
        _this.videoPlayer.classList.add("apx-video-hide-elmt".concat(_this.cssPostFix));
      });
      /**
       * @function unhideVideoPlayer
       * @description Unhides video player.
       */
      _defineProperty$1(this, "unhideVideoPlayer", function () {
        _this.videoPlayer.classList.remove("apx-video-hide-elmt".concat(_this.cssPostFix));
      });
      /**
       * @function getVideoElement
       * @returns {HTMLElement} Video ekement
       */
      _defineProperty$1(this, "getVideoElement", function () {
        return _this.videoElement;
      });
      this.videoPlayer = null;
      this.videoElement = null;
      this.showCallback = showCallback;
      this.terminationConfig = terminationConfig;
      this.hideCallback = _hideCallback;
      this.height = 320;
      this.width = 320;
      this.configId = configId;
      this.name = name || "VideoPlayer";
      this.cssPostFix = "-".concat(this.configId, "-").concat(this.name).replaceAll(" ", "").replace(/[^\w\s]/gi, "");
      this.replayCount = 0;
      this.inAppShown = false; // This boolean restricts the "inapp_shown" event from logging multiple times.

      /********************************Configs*********************************************************/
      this.videoConfig = config;
      this.bg_color = config.bg_color;
      this.mode = getStringOrDefault(config.mode, "PIP");
      this.position = new Position(config.position);
      this.enable_buttons = config.enable_buttons;
      if (this.enable_buttons) this.buttons = new Buttons(config.buttons);
      this.direction = new Direction(config.direction);
      this.enable_close_button = config.enable_close_button;
      if (this.enable_close_button) this.close_button = new CloseButton(config.close_button);
      this.enable_pip_button = config.enable_pip_button;
      if (this.enable_pip_button) this.pip_button = new PIPButton(config.pip_button);
      this.video = new Video(config.video);
      this.pip = new PIP(config.pip);
    }

    /**
     * @function isAVideoBeingPlayed
     * @static
     * @description Checks if a video InApp is already being played.
     * @returns {boolean}
     */
    _createClass$1(VideoInApp, [{
      key: "createPlayer",
      value:
      /**
       * @function createPlayer
       * @description Creates a video player with all the config options and attaches it to the document body
       */
      function createPlayer() {
        //Create a container for the video player and add the styles
        this.videoPlayer = document.createElement("div");
        this.videoPlayer.setAttribute("id", "apx-video-player");
        this.videoPlayer.style.backgroundColor = this.bg_color;

        // Video has a resolution, not deviating from the resolution set the height and width.
        this._getHeightWidthFromResolution();
        //Generate the styles and add them to the document head.
        this._setVideoPlayerStyles();
        //Set the position of the video player with in the 5 possible positions.
        this._setVideoPlayerPosition();
        //Create a video element,set the source and add to the container.
        this._setPlayerContent();
        //Set the listeners on the video control buttons.
        this._setVideoControlListeners();
        //Attach listeners for the PIP toggle. i.e. for the PIP enter and PIP exit
        this._setPIPtoggleListeners();
        //Set the custom close and PIP controls. Not using the defaults from the html video element.
        //Reason - We want to position them at the top right and left positions.
        this._setCustomControls();
        //Generate and postion the CTA buttons on the video. By default hidden, visible only when video is completed
        this._setButtons(BUTTON_CONTAINER_POSITION.CENTER);
        //Hide the video player. Display it based on the video mode. Videoplayer for "video" mode and a direct PIP  for "PIP" mode.
        this.hideVideoPlayer();
        //If the auto dismiss is enabled, sets the timeout to call the InApp close.
        this._setAutoTerminate();
        document.body.appendChild(this.videoPlayer);
      }
    }, {
      key: "_setVideoPlayerStyles",
      value:
      /**
       * @function _setVideoPlayerStyles
       * @private
       * @description Creates the styles for the video player and attaches that to the document head.
       */
      function _setVideoPlayerStyles() {
        var playerStyles = document.getElementById("apx-mpl-styles");
        // If the styles are already added to the customers website, do not re-add.
        if (!playerStyles) {
          var styleElement = document.createElement("style");
          styleElement.setAttribute("id", "apx-mpl-styles");
          var pipButtonStyles = this.enable_pip_button ? "\n      width: ".concat(this.pip_button.width, "px;\n      height:  ").concat(this.pip_button.height, "px;\n      ") : "";
          var closeButtonStyles = this.enable_close_button ? "\n      top: ".concat(this.close_button.offset_top, "px;\n      right: ").concat(this.close_button.offset_right, "px;\n      ") : "";
          styleElement.innerHTML = "\n          #apx-video-player {\n            width: ".concat(this.width, "px;\n            height: ").concat(this.height, "px;\n          }\n\n          div.apx-video-player").concat(this.cssPostFix, "--topLeft {\n            position: fixed;\n            top: 0;\n            left: 0;\n            background-color: ").concat(COLORS.BLACK, ";\n            z-index:99999999;\n          }\n          \n          div.apx-video-player").concat(this.cssPostFix, "--topRight {\n            position: fixed;\n            top: 0;\n            right: 0;\n            background-color: ").concat(COLORS.BLACK, ";\n            z-index:99999999;\n          }\n          \n          div.apx-video-player").concat(this.cssPostFix, "--bottomLeft {\n            position: fixed;\n            bottom: 0;\n            left: 0;\n            background-color: ").concat(COLORS.BLACK, ";\n            z-index:99999999;\n          }\n          \n          div.apx-video-player").concat(this.cssPostFix, "--bottomRight {\n            position: fixed;\n            bottom: 0;\n            right: 0;\n            background-color: ").concat(COLORS.BLACK, ";\n            z-index:99999999;\n          }\n\n          div.apx-video-player").concat(this.cssPostFix, "--center {\n            position: fixed;\n            left: 50%;\n            top: 50%;\n            background-color: ").concat(COLORS.BLACK, ";\n            transform: translate(-50%, -50%);\n            z-index:99999999;\n          }\n          .apx-video-hide-elmt").concat(this.cssPostFix, " {\n            display : none;\n          }\n\n          #apx-cta-btn.apx-video-hide-elmt").concat(this.cssPostFix, " {\n            display : none;\n          }\n\n          .apx-video-pip-btn").concat(this.cssPostFix, " {\n            position: absolute;\n            top: 10px;\n            left: 10px;\n            opacity: 0.3;\n            transition: opacity .3s ease;\n            cursor: pointer;\n            ").concat(pipButtonStyles, "\n          }\n\n          video:hover~.apx-video-pip-btn").concat(this.cssPostFix, " {\n            opacity: 1;\n          }\n          \n          .apx-video-close-btn").concat(this.cssPostFix, " {\n            position: absolute;\n            opacity: 0.3;\n            transition: opacity .3s ease;\n            cursor: pointer;\n            ").concat(closeButtonStyles, "\n          }\n\n          video:hover~.apx-video-close-btn").concat(this.cssPostFix, " {\n            opacity: 1;\n          }\n\n          .apx-video-cta").concat(this.cssPostFix, " {\n            position: absolute;\n            top: 50%;\n            left: 50%;\n            -webkit-transform: translate(-50%, -50%);\n            -moz-transform: translate(-50%, -50%);\n            width: auto;\n            height: auto;\n            transition: opacity .3s ease;\n            cursor: pointer;\n          }\n          \n          .bi::before,\n          [class^=\"bi-\"]::before,\n          [class*=\" bi-\"]::before {\n            display: inline-block;\n            font-style: normal;\n            font-weight: normal !important;\n            font-variant: normal;\n            text-transform: none;\n            line-height: 1;\n            vertical-align: -.125em;\n            -webkit-font-smoothing: antialiased;\n            -moz-osx-font-smoothing: grayscale;\n          }\n          \n          .bi-pip::before { \n            content: \"\f4ef\"; \n          }\n\n          .bi-x-circle::before { \n            content: \"\f623\"; \n          }\n\n      ");
          document.head.appendChild(styleElement);
        }
      }
    }, {
      key: "_setVideoPlayerPosition",
      value:
      /**
       * @function _setVideoPlayerPosition
       * @private
       * @description Video player can be position in 5 different places.
       * Depending on the config option set the position for the player. Position is set using the css classes.
       */
      function _setVideoPlayerPosition() {
        //Set the css class on the video player based on the postion in the configuration
        switch (this.position.position) {
          case INAPP_POSITION.TOP_LEFT:
            this.videoPlayer.classList.add("apx-video-player".concat(this.cssPostFix, "--topLeft"));
            break;
          case INAPP_POSITION.TOP_RIGHT:
            this.videoPlayer.classList.add("apx-video-player".concat(this.cssPostFix, "--topRight"));
            break;
          case INAPP_POSITION.BOTTOM_LEFT:
            this.videoPlayer.classList.add("apx-video-player".concat(this.cssPostFix, "--bottomLeft"));
            break;
          case INAPP_POSITION.BOTTOM_RIGHT:
            this.videoPlayer.classList.add("apx-video-player".concat(this.cssPostFix, "--bottomRight"));
            break;
          case INAPP_POSITION.CENTER:
            this.videoPlayer.classList.add("apx-video-player".concat(this.cssPostFix, "--center"));
            break;
          default:
            this.videoPlayer.classList.add("apx-video-player".concat(this.cssPostFix, "--bottomRight"));
            break;
        }
      }

      /**
       * @function _setPlayerContent
       * @private
       * @description Create a video element,sets the source and adds to the container.
       */
    }, {
      key: "_setPlayerContent",
      value: function _setPlayerContent() {
        // Create video element
        this.videoElement = document.createElement("video");
        this.videoElement.width = this.width;
        this.videoElement.height = this.height;
        this.videoElement.style.objectFit = "fill";
        this.videoElement.controlsList = "nodownload";
        this.videoElement.controls = true;
        if (isIOSDevice()) {
          this.videoElement.playsInline = true;
        }
        // By default disable the PIP. This is a hack to remove the default PIP option.
        // We want to have our own PIP button. On click of that button PIP will be enabled.
        this.videoElement.disablePictureInPicture = true;
        this.videoElement.autoplay = true;
        if (!this.video.enable_audio) {
          this.videoElement.muted = true;
        }
        // Create a video source.
        var sourceElement = document.createElement("source");
        //Set the video tag attributes
        sourceElement.setAttribute("src", this.video.path);
        sourceElement.setAttribute("type", this.video.format);
        this.videoElement.appendChild(sourceElement);
        this.videoPlayer.appendChild(this.videoElement);
      }
    }, {
      key: "_onClose",
      value:
      /**
       * @function _onClose
       * @private
       * @description Performs cleanup activities and log events on close of the mini player
       * @param {string} closeButtonName
       */
      function _onClose() {
        var closeButtonName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "web_minimise_x_clicked";
        try {
          if (this.inAppShown) {
            if (!document.fullscreenElement) {
              this.totalDurationMinimised += Math.round(this.videoElement.currentTime) - Math.round(this.slotStartTime);
              this.durationMinimisedSlots.push("".concat(Math.round(this.videoElement.currentTime), "-").concat(Math.round(this.slotStartTime)));
            } else {
              this.totalDurationMaximised += Math.round(this.videoElement.currentTime) - Math.round(this.slotStartTime);
              this.durationMaximisedSlots.push("".concat(Math.round(this.videoElement.currentTime), "-").concat(Math.round(this.slotStartTime)));
            }
          }
          this.videoPlayer.remove();
          this._removeVideoPlayerStyles();
          if (closeButtonName !== "auto_dismiss") {
            Apxor.logEvent("apx_video_inapp_close_button_clicked", {
              message_name: this.name,
              id: this.configId,
              totalDurationWatchedSlot: "0-".concat(Math.round(this.videoElement.currentTime)),
              totalDurationWatched: Math.round(this.videoElement.currentTime),
              closeButtonName: closeButtonName
            });
          }
          Apxor.logEvent("apx_inapp_dismissed", {
            campaignName: this.name,
            id: this.configId,
            totalDurationWatched: Math.round(this.videoElement.currentTime),
            totalDurationWatchedSlot: "0-".concat(Math.round(this.videoElement.currentTime)),
            totalReplayCount: this.replayCount,
            totalMinimiseCount: this.minimisedCount,
            totalMaximiseCount: this.maximisedCount,
            totalDurationMinimised: Math.round(this.totalDurationMinimised),
            totalDurationMaximised: Math.round(this.totalDurationMaximised),
            dismissType: closeButtonName,
            volumeClickedCount: this.volumeClickedCount,
            inappType: "PIP Inapp",
            apx_completed: this.videoElement.currentTime === this.videoElement.duration ? true : false,
            apx_completion_percentage: this.videoElement.currentTime / this.videoElement.duration
          });
          this.hideCallback("cancel");
        } catch (e) {
          console.log("Error \n ".concat(e, " \n occured while closing the video"));
        }
      }

      /**
       * @function _setButtons
       * @private
       * @description Generate the Button's and append them to the specified button container.
       *
       */
    }, {
      key: "_setButtons",
      value: function _setButtons(position) {
        var _this3 = this;
        if (!this.enable_buttons) {
          return;
        }
        if (this.buttons.enable_top || this.buttons.enable_center || this.buttons.enable_bottom) {
          var removeCallback = function removeCallback(isCancel, action, index) {
            try {
              var button;
              if (_this3.buttons.enable_top && _this3.buttons.top.length > 0) {
                button = _this3.buttons.top;
              }
              if (_this3.buttons.enable_center && _this3.buttons.center.length) {
                button = _this3.buttons.center;
              }
              if (_this3.buttons.enable_bottom && _this3.buttons.bottom.length) {
                button = _this3.buttons.bottom;
              }
              Apxor.logEvent("apx_video_inapp_button_clicked", {
                buttonName: button.at(index).text.text,
                redirection: button.at(index).action.type,
                totalDurationWatched: Math.round(_this3.videoElement.currentTime),
                message_name: _this3.name,
                id: _this3.configId,
                totalDurationWatchedSlot: "0-".concat(Math.round(_this3.videoElement.currentTime)),
                replayCount: _this3.replayCount
              });
              _this3.videoPlayer.remove();
              _this3._removeVideoPlayerStyles();
              _this3.hideCallback();
            } catch (e) {
              console.log("Can't close the video player\n".concat(e));
            }
          };
          var actionHandler = {
            next: removeCallback,
            prev: removeCallback,
            complete: removeCallback,
            cancel: removeCallback,
            _isCancelled: false,
            action: ""
          };
          var buttons_config = {};
          if (this.buttons.top.length > 0) {
            buttons_config = this.buttons.top;
          } else if (this.buttons.center.length > 0) {
            buttons_config = this.buttons.center;
          } else {
            buttons_config = this.buttons.bottom;
          }
          var buttons = generateButtonsBlock(this.configId, this.name, this.stepper, EVENT_PREFIX.INAPP, buttons_config, this.direction.buttons, "", position, actionHandler, this.isWalkthrough, this.uis, this.index);
          buttons.setAttribute("id", "apx-cta-btn");
          buttons.classList.add("apx-video-cta".concat(this.cssPostFix));
          buttons.classList.add("apx-video-hide-elmt".concat(this.cssPostFix));
          this.videoPlayer.appendChild(buttons);
        }
      }
    }, {
      key: "_setAutoTerminate",
      value:
      /**
       * @function _setAutoTerminate
       * @private
       * @description If the auto dismiss is enabled, sets the timeout to call the InApp close.
       */
      function _setAutoTerminate() {
        var _this$terminationConf2,
          _this4 = this;
        if (((_this$terminationConf2 = this.terminationConfig) === null || _this$terminationConf2 === void 0 ? void 0 : _this$terminationConf2.auto_dismiss) === true) {
          window.setTimeout(function () {
            if (document.pictureInPictureEnabled && document.pictureInPictureElement) {
              _this4.videoElement.pause();
              document.exitPictureInPicture();
            }
            _this4._onClose("auto_dismiss");
          }, this.terminationConfig.duration);
        }
      }
    }], [{
      key: "isAVideoBeingPlayed",
      value: function isAVideoBeingPlayed() {
        var videoPlayerElement = document.getElementById("apx-video-player");
        if (videoPlayerElement) {
          return true;
        }
        return false;
      }

      /**
       * @function canShowVideoInApp
       * @static
       * @description Checks if the video InApp can be created or not by checking the page binding.
       * @param {JSON} videoConfig
       * @returns {boolean}
       */
    }, {
      key: "canShowVideoInApp",
      value: function canShowVideoInApp(videoConfig) {
        var binding = videoConfig.binding,
          activity = videoConfig.activity;
        var showVideo = true;
        // If the current page is not where the video is bind, do not show the video
        if (binding && activity != "") {
          if (window.location.pathname !== activity) {
            showVideo = false;
          }
        }
        return showVideo;
      }
    }]);
    return VideoInApp;
  }();

  /**
   * @constructor Form
   * @example
   * Example of a Form model is
   *
   * form: {
   *  font: {
   *   family:"sans-serif",
   *   size : 14,
   *   style : "bold",
   *   weight : "normal"
   *  },
   *  enable_padding: true,
   *  padding: {
   *   top : 10,
   *   bottom : 10,
   *   left : 12,
   *   right : 12
   *  },
   *  element: [{
   *  name : "First Name",
   *  type : "name",
   *  callback : ()=>{},
   * }]
   * }
   */
  var Form = /*#__PURE__*/function () {
    function Form() {
      var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck$1(this, Form);
      this.font = new Font(data.font);
      this.padding = new Padding(data.padding);
      this.elements = data.elements;
    }
    _createClass$1(Form, null, [{
      key: "isEnabled",
      value: function isEnabled(data) {
        if (isUndefined$1(data) || isNull(data) || isEmptyObject(data)) {
          return false;
        } else {
          return true;
        }
      }
    }]);
    return Form;
  }();

  /**
   * @constructor Marketing
   * @example
   * Example of a Marketing model is
   *
   * marketing: {
   *    text : {
   *      // Text-Config
   *    }
   * }
   */
  var Marketing = /*#__PURE__*/_createClass$1(function Marketing() {
    var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    _classCallCheck$1(this, Marketing);
    this.message = new Text(data.message);
  });

  var ModalInApp = /*#__PURE__*/function () {
    /**
     * @class ModalInApp
     * @param {JSON}      config
     * @param {JSON}      terminationConfig
     * @param {string}    configId
     * @param {string}    name
     * @param {function}  showCallback
     * @param {function}  closeCallback
     */
    function ModalInApp(config, terminationConfig, configId, name, showCallback, closeCallback, stepperCallBack, isWalkthrough) {
      var _this = this;
      var uis = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : {};
      var index = arguments.length > 9 ? arguments[9] : undefined;
      _classCallCheck$1(this, ModalInApp);
      _defineProperty$1(this, "closeListener", function () {
        clearTimeout(_this.terminationTimeoutId);
        _this.closeCallback(_this.overlayElement, "dismiss", ".apx-inapp-container".concat(_this.cssPostFix), _this.closeListener, _this.redirectionListener);
      });
      _defineProperty$1(this, "redirectionListener", function () {
        if (window.location.href !== _this.launchPageUrl) {
          _this.closeCallback(_this.overlayElement, "dismiss", ".apx-inapp-container".concat(_this.cssPostFix), _this.closeListener, _this.redirectionListener);
        }
      });
      /**
       * @function _getMarketingStyles
       * @private
       * @description Creates the styles for Marketing message.
       * @returns {string} css styles
       */
      _defineProperty$1(this, "_getMarketingStyles", function () {
        if (!_this.enable_marketing) {
          return "";
        }
        var message = _this.marketing.message;
        var alignment = message.alignment;
        if (message.alignment === "left") {
          alignment = "flex-start";
        } else if (message.alignment === "right") {
          alignment = "flex-end";
        }
        var marketingStyles = "\n      .apx-inapp-marketing".concat(_this.cssPostFix, " {\n        align-self:").concat(alignment, ";\n        text-align:").concat(message.alignment, ";\n      }\n    ");
        return marketingStyles;
      });
      /**
       * @funciton generateResponse
       * @private
       * @description Get the response for Form content in the InApp modal.
       */
      _defineProperty$1(this, "generateResponse", function (form_elements) {
        var obj = {};
        var callback = "";
        form_elements.forEach(function (element) {
          var _element$name$, _element$name, _element$name$2, _element$name2, _element$name3, _element$name4, _element$name5, _element$name6, _element$name7, _element$callback;
          switch (element.type) {
            case "fullname":
              document.getElementById("fname") ? obj["".concat((_element$name$ = element === null || element === void 0 || (_element$name = element.name) === null || _element$name === void 0 ? void 0 : _element$name[0]) !== null && _element$name$ !== void 0 ? _element$name$ : "firstname")] = document.getElementById("fname").value : "";
              document.getElementById("lname") ? obj["".concat((_element$name$2 = element === null || element === void 0 || (_element$name2 = element.name) === null || _element$name2 === void 0 ? void 0 : _element$name2[1]) !== null && _element$name$2 !== void 0 ? _element$name$2 : "lastname")] = document.getElementById("lname").value : "";
              break;
            case "name":
              document.getElementById("name") ? obj["".concat((_element$name3 = element === null || element === void 0 ? void 0 : element.name) !== null && _element$name3 !== void 0 ? _element$name3 : "name")] = document.getElementById("name").value : "";
              break;
            case "email":
              document.getElementById("email") ? obj["".concat((_element$name4 = element === null || element === void 0 ? void 0 : element.name) !== null && _element$name4 !== void 0 ? _element$name4 : "email")] = document.getElementById("email").value : "";
              break;
            case "phone":
              document.getElementById("phoneNumber") ? obj["".concat((_element$name5 = element === null || element === void 0 ? void 0 : element.name) !== null && _element$name5 !== void 0 ? _element$name5 : "phonenumber")] = document.getElementById("phoneNumber").value : "";
              break;
            case "date":
              document.getElementById("date") ? obj["".concat((_element$name6 = element === null || element === void 0 ? void 0 : element.name) !== null && _element$name6 !== void 0 ? _element$name6 : "date")] = document.getElementById("date").value : "";
              break;
            case "message":
              document.getElementById("textField") ? obj["".concat((_element$name7 = element === null || element === void 0 ? void 0 : element.name) !== null && _element$name7 !== void 0 ? _element$name7 : "feedback")] = document.getElementById("textField").value : "";
              break;
            case "button":
              callback = (_element$callback = element === null || element === void 0 ? void 0 : element.callback) !== null && _element$callback !== void 0 ? _element$callback : "";
              break;
          }
        });
        return {
          obj: obj,
          callback: callback
        };
      });
      /**
       * @function _setMarketingMessage
       * @private
       * @description Sets the marketing content at the end of the InApp
       */
      _defineProperty$1(this, "_setMarketingMessage", function () {
        if (_this.enable_marketing) {
          var marketingContainer = document.createElement("div");
          marketingContainer.classList.add("apx-inapp-marketing".concat(_this.cssPostFix));
          var marketingTextElement = createNewTextElement(_this.marketing.message, _this.currentId, "marketing");
          marketingContainer.appendChild(marketingTextElement);
          _this.inAppContainer.appendChild(marketingContainer);
        }
      });
      this.rtmInstance = window.ApxorRTM;
      this.index = index;
      this.uis = uis;
      this.terminationConfig = terminationConfig;
      this.terminationTimeoutId = null;
      this.isWalkthrough = isWalkthrough;
      this.cssPostFix = "-".concat(configId, "-").concat(name).replaceAll(" ", "").replace(/[^\w\s]/gi, "");
      this.delay = config.delay || 0;
      this.background_color = config.bg_color || COLORS.WHITE;
      this.width = config.width || 50; // Scale of the screen
      this.height = config.height || 50; // Mostly auto. But for scrollable templates, should be the pixels.

      this.direction = new Direction(config.direction);
      this.position = new Position(config.position);
      this.enable_dismiss_actions = config.enable_dismiss_actions;
      if (this.enable_dismiss_actions) this.dismiss_actions = new DismissActions(config.dismiss_actions);
      this.enable_dimbackground = config.enable_dimbackground;
      if (this.enable_dimbackground) this.dimbackground = new DimBackground(config.dimbackground);
      this.enable_padding = config.enable_padding;
      if (this.enable_padding) this.padding = new Padding(config.padding);
      this.enable_margin = config.enable_margin;
      if (this.enable_margin) this.margin = new Margin(config.margin);
      this.enable_border = config.enable_border;
      if (this.enable_border) this.border = new Border(config.border);
      this.enable_close_button = config.enable_close_button;
      if (this.enable_close_button) this.close_button = new CloseButton(config.close_button);
      this.enable_scroll = config.enable_scroll;
      if (this.enable_scroll) this.scroll = new Scroll(config.scroll);
      this.enable_icon = config.enable_icon;
      if (this.enable_icon) this.icon = new Icon(config.icon);
      this.enable_image = config.enable_image;
      if (this.enable_image) this.image = new Image(config.image);
      this.enable_video = config.enable_video;
      if (this.enable_video) this.video = new Video(config.video);
      this.enable_title = config.enable_title;
      if (this.enable_title) this.title = new Title(config.title);
      this.enable_description = config.enable_description;
      if (this.enable_description) this.description = new Description(config.description);
      this.enable_form = config.enable_form;
      if (this.enable_form) this.form = new Form(config.form);
      this.enable_buttons = config.enable_buttons;
      if (this.enable_buttons) this.buttons = new Buttons(config.buttons);
      this.enable_stepper = config.enable_stepper;
      if (this.enable_stepper) this.stepper = new Stepper(config.stepper);
      this.enable_shadow = config.enable_shadow;
      if (this.enable_shadow) this.shadow = new Shadow(config.shadow);
      this.enable_gradient = config.enable_gradient;
      if (this.enable_gradient) this.gradient = new Gradient(config.gradient);
      this.enable_marketing = config.enable_marketing;
      if (this.enable_marketing) this.marketing = new Marketing(config.marketing);
      this.min_width = "";
      this.max_width = "";
      this.inapp_width = "auto";
      this.inapp_height = "auto";
      this.media_container_height = 0;
      this.media_width = "auto";
      this.media_height = "auto";
      this.configId = configId;
      this.name = name;
      this.showCallback = showCallback;
      this.closeCallback = closeCallback;
      this.stepperCallBack = stepperCallBack;
      this.currentId = makeid(10);
      this.dimBackgroundElement = null;
      this.overlayElement = null;
      this.inAppContainer = null;
      this.launchPageUrl = "";
    }

    /**
     * Creates a modal for the given config and displays it.
     * Supported Modals are "small-text","medium-text","large-text","icon-text","image-text","image-only","custom-size-text","video-text"
     *                                                  _________________
     *                                                 |apx-inapp-overlay|
     *                                                  -----------------
     *                                                /        |          \
     *                                               /      chi|dren       \
     *                                              /          |            \
     *                            __________________________  _______   __________
     *                           |[apx-dimbackground-overlay]| |styles|  |apx-inapp-container|
     *                            --------------------------  --------  -----------
     * @param {JSON} config
     * @param {string} configId
     * @param {string} name
     * @param {function} showCallback
     * @param {function} closeCallback
     */
    _createClass$1(ModalInApp, [{
      key: "createInAppModal",
      value: function createInAppModal() {
        //Set the InApp dimensions.
        this._setInAppDimensions();
        //Set the background overlays
        this._setBackgroundOverlays();
        //Set the InApp styles
        this._setStyles();
        //Set the content
        this._setInAppModalContent();
        //Set the auto termination
        this._setAutoTerminate();
        //Show the InApp
        this._showInApp();
      }
    }, {
      key: "_setInAppDimensions",
      value:
      /**
       * @function _setInAppDimensions
       * @private
       * @description Sets the width modal based on the media resolution.
       */
      function _setInAppDimensions() {
        var scale = this.direction.nudge === DIRECTION.VERTICAL ? this.width / 100 : this.height / 100;
        var calculateFromHeight = this.direction.nudge === DIRECTION.VERTICAL ? false : true;
        if (this.enable_image) {
          this._setDimenstionFromResolution(this.image.width, this.image.height, scale, calculateFromHeight);
        } else if (this.enable_video) {
          if (this.video.enable_embed) {
            if (this.direction.nudge === DIRECTION.VERTICAL) {
              this.inapp_width = "".concat(this.video.width + (this.enable_border ? this.border.width * 2 : 0) + (this.enable_padding ? this.padding.left + this.padding.right : 0), "px");
              this.media_width = "".concat(this.video.width, "px");
            } else {
              this.inapp_height = "".concat(this.video.height + (this.enable_border ? this.border.width * 2 : 0) + (this.enable_padding ? this.padding.left + this.padding.right : 0), "px");
              this.media_container_height = this.video.height;
              this.media_height = "".concat(this.video.height, "px");
              this.min_width = "".concat(this.width, "%");
            }
          } else {
            this._setDimenstionFromResolution(this.video.width, this.video.height, scale, calculateFromHeight);
          }
        } else if (this.enable_icon) {
          if (this.direction.nudge === DIRECTION.VERTICAL) {
            this.inapp_width = "".concat(this.width, "%");
          } else {
            //this.inapp_height = `${this.height}%`;
            this.min_width = "".concat(this.width, "%");
          }
        } else {
          if (this.direction.nudge === DIRECTION.VERTICAL) {
            this.inapp_width = "".concat(this.width, "%");
          } else {
            this.max_width = "".concat(this.width, "%");
          }
        }
      }

      /**
       * @function _setDimenstionFromResolution
       * @private
       * @description For image and video type of InApps, modal width and height must be calculated along the lines of resolution.
       * @param {number} width
       * @param {number} height
       * @param {number} scale
       */
    }, {
      key: "_setDimenstionFromResolution",
      value: function _setDimenstionFromResolution(width, height) {
        var scale = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.5;
        var calculateFromHeight = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
        var dimensions = getHeightWidthFromResolution({
          width: width,
          height: height
        }, scale, calculateFromHeight);
        this.media_width = "".concat(dimensions.width, "px");
        this.media_height = "".concat(dimensions.height, "px");
        this.media_container_height = dimensions.height;
        if (this.direction.nudge === DIRECTION.VERTICAL) {
          this.inapp_width = "".concat(dimensions.width + (this.enable_border ? this.border.width * 2 : 0) + (this.enable_padding ? this.padding.left + this.padding.right : 0), "px");
        } else {
          this.inapp_height = "".concat(dimensions.height + (this.enable_border ? this.border.width * 2 : 0) + (this.enable_padding ? this.padding.top + this.padding.bottom : 0), "px");
          this.min_width = "".concat(this.width, "%");
        }
      }

      /**
       * @function _setBackgroundOverlays
       * @private
       * @description Creates the overlay and dim background elements and adds them to the document body.
       */
    }, {
      key: "_setBackgroundOverlays",
      value: function _setBackgroundOverlays() {
        var _this2 = this;
        // Modal main div
        this.launchPageUrl = window.location.href;
        this.overlayElement = document.createElement("div");
        this.overlayElement.classList.add("apx-inapp-overlay".concat(this.cssPostFix));
        var dismissableElement = this.overlayElement;

        // If dismiss outside touch is enabled, set a onclick listener to remove the overlay.
        // With dim background, it becomes the element to add the listener.
        // With out dim background, ideally dismiss out side touch should not be used. If used, set the listener on the overlay.

        if (this.enable_dimbackground) {
          // Modal overlay for the dimbackground and dismiss
          this.dimBackgroundElement = document.createElement("div");
          this.dimBackgroundElement.classList.add("apx-inapp-dimbackground-overlay".concat(this.cssPostFix));
          dismissableElement = this.dimBackgroundElement;
          this.overlayElement.appendChild(this.dimBackgroundElement);
          if (this.enable_dismiss_actions && this.dismiss_actions.outside_touch) {
            dismissableElement.onclick = function () {
              clearTimeout(_this2.terminationTimeoutId);
              dismissableElement.onclick = null;
              _this2.closeCallback(_this2.overlayElement, "dismiss", ".apx-inapp-container".concat(_this2.cssPostFix), _this2.closeListener, _this2.redirectionListener);
            };
          }
        } else {
          if (this.enable_dismiss_actions && this.dismiss_actions.outside_touch) {
            document.body.addEventListener("click", this.closeListener);
          }
        }
        if (!this.enable_dimbackground) {
          document.body.addEventListener("click", this.redirectionListener);
        }
        // Append the overlay to the body. All the element of the InApp are children of this overlay.
        document.body.appendChild(this.overlayElement);
      }

      /**
       * @function _setStyles
       * @private
       * @description Creates all the styles needed by the InApp modal and sets them on the overlay.
       */
    }, {
      key: "_setStyles",
      value: function _setStyles() {
        var styles = "\n      ".concat(this._getBackgroundContainerStyles(), " \n      ").concat(this._getInAppContainerStyles(), " \n      ").concat(this._getScrollStyles(), " \n      ").concat(this._getControlsStyles(), " \n      ").concat(this._getInAppMediaContainerStyles(), "\n      ").concat(this._getInAppNonMediaContainerStyles(), "\n      ").concat(this._getTextConatinerStyles(), "\n      ").concat(this._getTitleStyles(), " \n      ").concat(this._getDescriptionStyles(), " \n      ").concat(this._getFormStyles(), "\n      ").concat(this._getInAppButtonContainerStyles(), "\n      ").concat(this._getIconStyles(), " \n      ").concat(this._getImageStyles(), " \n      ").concat(this._getVideoStyles(), " \n      ").concat(this._getMarketingStyles(), " \n      ").concat(this._getProgressBarStyles(), "\n      ").concat(this._getBootstrapiconsStyles(), " \n    ").replaceAll("\n", "").replace(/[\s]{2,999}/g, "");
        var styleNode = document.createElement("style");
        styleNode.innerHTML = styles;
        this.overlayElement.appendChild(styleNode);
      }

      /**
       * @function _getBackgroundContainerStyles
       * @private
       * @description Creates the styles for the inapp overlay and dimbackground overlay
       * @returns {string} css styles
       */
    }, {
      key: "_getBackgroundContainerStyles",
      value: function _getBackgroundContainerStyles() {
        // Set the dim background color and opacity only if dim background is enabled.
        var backgroundContainerStyle = "\n      .apx-inapp-overlay".concat(this.cssPostFix, " {\n        width:100%;\n        height:100%;\n      }\n      .apx-inapp-dimbackground-overlay").concat(this.cssPostFix, " {\n        width:100%;\n        height:100%;\n        position:fixed;\n        top:0;\n        left:0;\n        z-index:999;\n        background-color:").concat(this.enable_dimbackground ? this.dimbackground.color : "transparent", ";\n        ").concat(this.enable_dimbackground ? "opacity: ".concat(this.dimbackground.opacity, ";") : "", "\n        overflow: auto;\n      }\n    ");
        return backgroundContainerStyle;
      }

      /**
       * @function _getInAppContainerStyles
       * @private
       * @description Creates the styles for the inapp container
       * @returns {string} css styles
       */
    }, {
      key: "_getInAppContainerStyles",
      value: function _getInAppContainerStyles() {
        var inappPositionOffset = this.enable_border ? this.border.width : 0;
        var topOffset = inappPositionOffset;
        var leftOffset = inappPositionOffset;
        var rightOffset = inappPositionOffset;
        var bottomOffset = inappPositionOffset;
        if (this.enable_padding) {
          topOffset = topOffset + this.padding.top;
          leftOffset = leftOffset + this.padding.left;
          rightOffset = rightOffset + this.padding.right;
          bottomOffset = bottomOffset + this.padding.bottom;
        }
        if (this.enable_margin) {
          topOffset = topOffset + this.margin.top;
          leftOffset = leftOffset + this.margin.left;
          rightOffset = rightOffset + this.margin.right;
          bottomOffset = bottomOffset + this.margin.bottom;
        }
        var positionStylesForContainer = "";
        switch (this.position.position) {
          case INAPP_POSITION.TOP_LEFT:
            positionStylesForContainer = "\n          top:".concat(topOffset, "px;\n          left:").concat(leftOffset, "px;\n        ");
            break;
          case INAPP_POSITION.TOP_CENTER:
            positionStylesForContainer = "\n          left:50%;\n          top:".concat(topOffset, "px;\n          -webkit-transform: translate(-50%, ").concat(topOffset * 0.1, "px);\n          -moz-transform: translate(-50%, ").concat(topOffset, "px);\n        ");
            break;
          case INAPP_POSITION.TOP_RIGHT:
            positionStylesForContainer = "\n            top:".concat(topOffset, "px;\n            right:").concat(rightOffset, "px;\n          ");
            break;
          case INAPP_POSITION.BOTTOM_LEFT:
            positionStylesForContainer = "\n          bottom:".concat(bottomOffset, "px;\n          left:").concat(leftOffset, "px;\n        ");
            break;
          case INAPP_POSITION.BOTTOM_CENTER:
            positionStylesForContainer = "\n          left:50%;\n          bottom:".concat(bottomOffset, "px;\n          -webkit-transform: translate(-50%, ").concat(bottomOffset * 0.1, "px);\n          -moz-transform: translate(-50%, ").concat(bottomOffset, "px);\n        ");
            break;
          case INAPP_POSITION.BOTTOM_RIGHT:
            positionStylesForContainer = "\n          bottom:".concat(bottomOffset, "px;\n          right:").concat(rightOffset, "px;\n        ");
            break;
          case INAPP_POSITION.CENTER:
            positionStylesForContainer = "\n          left:50%;\n          top:50%;\n          -webkit-transform: translate(-50%, -50%);\n          -moz-transform: translate(-50%, -50%);\n        ";
            break;
          default:
            positionStylesForContainer = "\n          left:50%;\n          top:50%;\n          -webkit-transform: translate(-50%, -50%);\n          -moz-transform: translate(-50%, -50%);\n        ";
            break;
        }
        var minWidthStyle = "";
        if (this.min_width) {
          minWidthStyle = "min-width:".concat(this.min_width, ";");
        }
        var borderStylesForContainer = "";
        if (this.enable_border) {
          borderStylesForContainer = "\n        border-radius: ".concat(this.border.radius, "px;\n        border: ").concat(this.border.width, "px ").concat(this.border.style, " ").concat(this.border.color, ";\n      ");
        }
        var gradientStylesForContainer = "";
        if (this.enable_gradient) {
          gradientStylesForContainer = "\n        background-image:linear-gradient(".concat(this.gradient.direction, ", ").concat(this.gradient.colors[0], ", ").concat(this.gradient.colors[1], ");\n      ");
        }
        var shadowStylesForContainer = "";
        if (this.enable_shadow) {
          shadowStylesForContainer = "\n        box-shadow: ".concat(this.shadow.offset_x, "px ").concat(this.shadow.offset_y, "px ").concat(this.shadow.blur_radius, "px ").concat(this.shadow.spread_radius, "px ").concat(this.shadow.color, ";\n      ");
        }
        var paddingStylesForContainer = "";
        if (this.enable_padding) {
          paddingStylesForContainer = "\n        padding:".concat(this.padding.top, "px ").concat(this.padding.right, "px ").concat(this.padding.bottom, "px ").concat(this.padding.left, "px;\n      ");
        }
        var flexStylesForContainer = this.direction.nudge !== DIRECTION.VERTICAL ? "flex-direction:row;" : "flex-direction:column;";
        flexStylesForContainer = " ".concat(flexStylesForContainer, "\n      justify-content:space-evenly;\n      align-items:center;\n      display:flex;\n    ");
        var maxWidth = "",
          maxHeight = "",
          margin = "margin: auto";
        if (this.direction.nudge === DIRECTION.HORIZONTAL) {
          if (!(this.enable_image || this.enable_video || this.enable_icon)) {
            maxWidth = "max-width: ".concat(this.max_width);
          } else {
            if (this.position.position === INAPP_POSITION.TOP_LEFT || this.position.position === INAPP_POSITION.BOTTOM_LEFT) {
              margin = "margin-right: 20%; margin-block:auto";
            } else if (this.position.position === INAPP_POSITION.TOP_RIGHT || this.position.position === INAPP_POSITION.BOTTOM_RIGHT) {
              margin = "margin-left: 20%; margin-block:auto";
            }
          }
        }
        if (this.enable_video && this.video.enable_embed) {
          maxWidth = "max-width:100%;";
          maxHeight = "max-height:100%;";
        }
        //justify-content: space-evenly;
        //align-items:stretch
        var inappContainerStyles = "\n      .apx-inapp-container".concat(this.cssPostFix, " {\n        height:").concat(this.inapp_height, ";\n        width:").concat(this.inapp_width, ";\n        background-color:").concat(this.background_color, ";\n        z-index:9999;\n        opacity:0;\n        transition:all .5s cubic-bezier(.96,.23,.07,.8);\n        position:fixed;\n        visibility:hidden;\n\n        ").concat(minWidthStyle, "\n        ").concat(flexStylesForContainer, "\n        ").concat(paddingStylesForContainer, "\n        ").concat(borderStylesForContainer, "\n        ").concat(gradientStylesForContainer, "\n        ").concat(shadowStylesForContainer, "\n        ").concat(positionStylesForContainer, "\n        ").concat(maxWidth, "\n        ").concat(maxHeight, "\n        ").concat(margin, "\n      }\n      \n      .apx-inapp-container").concat(this.cssPostFix, ".open{\n        opacity:1;\n        visibility:visible;\n      }\n    ");
        return inappContainerStyles;
      }

      /**
       * @function _getScrollStyles
       * @private
       * @description Creates the styles for the scrollbar
       * @returns {string} css styles
       */
    }, {
      key: "_getScrollStyles",
      value: function _getScrollStyles() {
        var scrollStyles = "";
        var borderStyles = this.enable_scroll && this.scroll.enable_border ? "\n  border-top: ".concat(this.scroll.border.width, "px ").concat(this.scroll.border.style, " ").concat(this.scroll.border.color, ";\n  border-bottom : ").concat(this.scroll.border.width, "px ").concat(this.scroll.border.style, " ").concat(this.scroll.border.color, ";\n  ") : "";
        if (this.enable_scroll) {
          scrollStyles = "\n      .apx-inapp-scroll".concat(this.cssPostFix, " {\n        overflow:scroll; \n        overflow-x: hidden;\n        height:").concat(this.scroll.height, "px;\n        ").concat(borderStyles, "\n      }\n    ");
        } else {
          scrollStyles = "\n      .apx-inapp-scroll".concat(this.cssPostFix, " {\n        overflow : hidden;\n      }\n    ");
        }
        return scrollStyles;
      }

      /**
       * @function _getControlsStyles
       * @private
       * @description Creates the styles for any controls on the modal like the close control.
       * @returns {string} css styles
       */
    }, {
      key: "_getControlsStyles",
      value: function _getControlsStyles() {
        if (!this.enable_close_button) {
          return "";
        }
        var controlsStyles = "";
        if (this.direction.non_media === DIRECTION.VERTICAL || this.direction.nudge === DIRECTION.VERTICAL) {
          controlsStyles = "\n        .apx-inapp-close".concat(this.cssPostFix, " {\n          position: absolute;\n          z-index:99999;\n          top: ").concat(this.close_button.offset_top, "px;\n          right: ").concat(this.close_button.offset_right, "px;\n          width: ").concat(this.close_button.width, "px;\n          height:  ").concat(this.close_button.height, "px;\n          cursor: pointer;\n        }\n      ");
        } else {
          controlsStyles = "\n      .apx-inapp-close".concat(this.cssPostFix, " {\n        display:flex;\n        flex-direction:row;\n        justify-content:center;\n        align-items:center;\n        width: ").concat(this.close_button.width, "px;\n        height:  ").concat(this.close_button.height, "px;\n        cursor: pointer;\n        z-index:99999;\n      }\n      ");
        }
        return controlsStyles;
      }

      /**
       * @function _getInAppMediaContainerStyles
       * @private
       * @description Creates the styles for the inapp Media container
       * @returns {string} css styles
       */
    }, {
      key: "_getInAppMediaContainerStyles",
      value: function _getInAppMediaContainerStyles() {
        var inappMediaContainerStyles = "\n    .apx-inapp-media-container".concat(this.cssPostFix, "{\n      ").concat(this.enable_icon ? "align-self:".concat(this.icon.alignment, ";") : "", "\n      ").concat(this.enable_image || this.enable_video ? "display:flex;" : "", "\n      }");
        return inappMediaContainerStyles;
      }

      /**
       * @function _getInAppNonMediaContainerStyles
       * @private
       * @description Creates the styles for the inapp Non-Media container
       * @returns {string} css styles
       */
    }, {
      key: "_getInAppNonMediaContainerStyles",
      value: function _getInAppNonMediaContainerStyles() {
        var maxHeight = "";
        if (this.direction.nudge === DIRECTION.VERTICAL) {
          maxHeight = "max-height:".concat(window.innerHeight - this.media_container_height, "px;");
        } else {
          if (this.enable_image || this.enable_video) {
            maxHeight = "max-height:".concat(this.media_container_height, "px;");
          }
        }
        var inappNonMediaContainerStyles = "";
        if (this.direction.non_media === DIRECTION.VERTICAL) {
          inappNonMediaContainerStyles = "\n        .apx-inapp-nonmedia-container".concat(this.cssPostFix, "{\n          width:100%;\n          display:flex;\n          flex-direction:column;\n          justify-content:center;\n          align-items:stretch;\n          ").concat(maxHeight, "\n        }\n      ");
        } else {
          inappNonMediaContainerStyles = "\n        .apx-inapp-nonmedia-container".concat(this.cssPostFix, "{\n          width:100%;\n          flex-grow:2;\n          display:flex;\n          flex-direction:row;\n          justify-content:space-between;\n          align-items:center;\n          ").concat(maxHeight, "\n        }\n      ");
        }
        return inappNonMediaContainerStyles;
      }

      /**
       * @function _getTextContainerStyles
       * @private
       * @description Creates the styles for the text container
       * @returns {string} css styles
       */
    }, {
      key: "_getTextConatinerStyles",
      value: function _getTextConatinerStyles() {
        var contentStyling = "\n      .apx-inapp-text-container".concat(this.cssPostFix, "{\n        width:auto;\n        display:flex;\n        flex-direction:column;\n        justify-content: center;\n        overflow: hidden;\n        align-items:center;\n        cursor:text;\n      }\n    ");
        return contentStyling;
      }

      /**
       * @function _getTitleStyles
       * @private
       * @description Creates the styles for the title
       * @returns {string} css styles
       */
    }, {
      key: "_getTitleStyles",
      value: function _getTitleStyles() {
        if (!this.enable_title) {
          return "";
        }
        var titleIconStyles = "";
        if (this.title.enable_icon) {
          var iconBorderStyles = "";
          if (this.title.icon.enable_border) {
            iconBorderStyles = "border-radius:".concat(this.title.icon.border.radius, "%;\n        border:").concat(this.title.icon.border.width, "px ").concat(this.title.icon.border.style, " ").concat(this.title.icon.border.color, ";");
          }
          titleIconStyles = "\n          height: ".concat(this.title.icon.height, "px;\n          width: ").concat(this.title.icon.width, "px;\n          margin-right: 10px;\n          ").concat(iconBorderStyles, "\n     ");
        }
        var titleMarginStyles = "";
        if (this.title.enable_margin) {
          titleMarginStyles = " \n        margin-top:".concat(this.title.margin.top, "px;\n        margin-bottom:").concat(this.title.margin.bottom, "px;\n        margin-left:").concat(this.title.margin.left, "px;\n        margin-right:").concat(this.title.margin.right, "px;\n      ");
        }
        var titlePaddingStyles = "";
        if (this.title.enable_padding) {
          titlePaddingStyles = " \n        padding-top:".concat(this.title.padding.top, "px;\n        padding-bottom:").concat(this.title.padding.bottom, "px;\n        padding-left:").concat(this.title.padding.left, "px;\n        padding-right:").concat(this.title.padding.right, "px;\n      ");
        }
        var titeStyles = "\n      .apx-inapp-title-div".concat(this.cssPostFix, " {\n        width:100%;\n        display:flex;\n        justify-content:").concat(this.title.alignment, ";\n        align-items: center;\n        text-align:").concat(this.title.alignment, ";\n        pointer-events:none;\n        ").concat(titleMarginStyles, "\n        ").concat(titlePaddingStyles, "\n      }\n      .apx-inapp-title-icon").concat(this.cssPostFix, " {\n        ").concat(titleIconStyles, "\n      }\n    ");
        return titeStyles;
      }

      /**
       * @function _getDescriptionStyles
       * @private
       * @description Creates the styles for text description
       * @returns {string} css styles
       */
    }, {
      key: "_getDescriptionStyles",
      value: function _getDescriptionStyles() {
        if (!this.enable_description) {
          return "";
        }
        var descriptionMarginStyles = "";
        if (this.description.enable_margin) {
          descriptionMarginStyles = " \n        margin-top:".concat(this.description.margin.top, "px;\n        margin-bottom:").concat(this.description.margin.bottom, "px;\n        margin-left:").concat(this.description.margin.left, "px;\n        margin-right:").concat(this.description.margin.right, "px;\n      ");
        }
        var descriptionPaddingStyles = "";
        if (this.description.enable_padding) {
          descriptionPaddingStyles = " \n        padding-top:".concat(this.description.padding.top, "px;\n        padding-bottom:").concat(this.description.padding.bottom, "px;\n        padding-left:").concat(this.description.padding.left, "px;\n        padding-right:").concat(this.description.padding.right, "px;\n      ");
        }
        var descriptionStyles = "\n      .apx-inapp-description".concat(this.cssPostFix, " {\n        width:100%;\n        justify-content:").concat(this.description.alignment, ";\n        text-align:").concat(this.description.alignment, ";\n        ").concat(descriptionMarginStyles, "\n        ").concat(descriptionPaddingStyles, "\n      }\n    ");
        return descriptionStyles;
      }
    }, {
      key: "_getFormStyles",
      value: function _getFormStyles() {
        if (!this.enable_form) {
          return;
        }
        var formPaddingStyles = "";
        if (this.form.enable_padding) {
          formPaddingStyles = "padding:".concat(this.form.padding.top, "px ").concat(this.form.padding.right, "px ").concat(this.form.padding.bottom, "px ").concat(this.form.padding.left, "px;");
        }
        var formContainerstyle = "\n      .apx-inapp-form-container".concat(this.cssPostFix, "{\n        ").concat(formPaddingStyles, "\n        font-size:").concat(this.form.font.size, "px;\n        font-family:").concat(this.form.font.family, ";\n        display:flex;\n        flex-direction:column;\n      }");
        return formContainerstyle;
      }
      /**
       * @function _getInAppButtonContainerStyles
       * @private
       * @description Creates the styles for the inapp button container
       * @returns {string} css styles
       */
    }, {
      key: "_getInAppButtonContainerStyles",
      value: function _getInAppButtonContainerStyles() {
        var inappButtonContainerStyles = "\n    .apx-inapp-button-container".concat(this.cssPostFix, "{\n      display:flex;\n      flex-direction:row;\n      align-items:center;\n      justify-content:center;\n      margin:0 10px 0 10px;\n    }\n    .apx-inapp-top-button-container").concat(this.cssPostFix, "{\n      width:100%;\n      height:auto;\n    }\n    .apx-inapp-center-button-container").concat(this.cssPostFix, "{\n      width:100%;\n      height:auto;\n    }\n    .apx-inapp-bottom-button-container").concat(this.cssPostFix, "{\n      width:100%;\n      height:auto;\n    }");
        return inappButtonContainerStyles;
      }

      /**
       * @function _getIconStyles
       * @private
       * @description Creates the styles for icon, which is displayed above the title.
       * @returns {string} css styles
       */
    }, {
      key: "_getIconStyles",
      value: function _getIconStyles() {
        var iconStyles = "";
        if (this.enable_icon) {
          var iconBorderStyles = "";
          if (this.icon.enable_border) {
            iconBorderStyles = "\n            border-radius:".concat(this.icon.border.radius, "%;\n            border:").concat(this.icon.border.width, "px ").concat(this.icon.border.style, " ").concat(this.icon.border.color, ";\n        ");
          }
          var iconMarginStyles = "";
          if (this.icon.enable_margin) {
            iconMarginStyles = "\n          margin-top:".concat(this.icon.margin.top, "px;\n          margin-bottom:").concat(this.icon.margin.bottom, "px;\n          margin-left:").concat(this.icon.margin.left, "px;\n          margin-right:").concat(this.icon.margin.right, "px;\n        ");
          }
          var iconPaddingStyles = "";
          if (this.icon.enable_padding) {
            iconPaddingStyles = "\n          padding-top:".concat(this.icon.padding.top, "px;\n          padding-bottom:").concat(this.icon.padding.bottom, "px;\n          padding-left:").concat(this.icon.padding.left, "px;\n          padding-right:").concat(this.icon.padding.right, "px;\n        ");
          }
          iconStyles = "\n        .apx-inapp-icon-container".concat(this.cssPostFix, " {\n          text-align:").concat(this.icon.alignment, ";\n        }\n        .apx-inapp-icon-content").concat(this.cssPostFix, " {\n          height: ").concat(this.icon.height, "px;\n          width: ").concat(this.icon.width, "px;\n          ").concat(iconBorderStyles, "\n          ").concat(iconMarginStyles, "\n          ").concat(iconPaddingStyles, "\n        }\n      ");
        }
        return iconStyles;
      }

      /**
       * @function _getImageStyles
       * @private
       * @description Creates the styles for images, for both image only modal and modal with both image and text
       * @returns {string} css styles
       */
    }, {
      key: "_getImageStyles",
      value: function _getImageStyles() {
        var imageStyles = "";

        // height: ${this.media_height};
        // width: ${this.media_width};
        // background:url('${this.image.path}') no-repeat 50% 50%;
        //Create the css for images only if image_config is sent.
        if (this.enable_image) {
          //Image can be used as a background image. Styles are different in that case.
          if (this.image.enable_background_image) {
            imageStyles = "\n          .apx-inapp-image".concat(this.cssPostFix, "{\n            background-image: url('").concat(this.image.path, "');\n            background-repeat: no-repeat;\n            background-attachment: fixed; \n            background-size: 100% 100%;\n            height: ").concat(this.media_height, ";\n            width: ").concat(this.media_width, ";\n            box-shadow: inset ").concat(this.media_width, " ").concat(this.media_height, " 0px 0px ").concat(hexToRGB(this.image.background_image.mask_color, this.image.background_image.mask_opacity), ",inset -").concat(this.media_width, " -").concat(this.media_height, " 0px 0px ").concat(hexToRGB(this.image.background_image.mask_color, this.image.background_image.mask_opacity), "\n          }\n        ");
          } else {
            var imageBorderStyles = "";
            if (this.image.enable_border) {
              imageBorderStyles = "\n          border-radius:".concat(this.image.border.radius, "%;\n          border:").concat(this.image.border.width, "px ").concat(this.image.border.style, " ").concat(this.image.border.color, ";\n          ");
            }
            imageStyles = "\n        .apx-inapp-image".concat(this.cssPostFix, "{\n          height: ").concat(this.media_height, ";\n          width: ").concat(this.media_width, ";\n          ").concat(imageBorderStyles, "\n        }\n      ");
          }
        }
        return imageStyles;
      }

      /**
       * @function _getVideoStyles
       * @private
       * @description Creates the styles for videos modals.
       * @returns {string} css styles
       */
    }, {
      key: "_getVideoStyles",
      value: function _getVideoStyles() {
        var videoStyles = "";
        if (this.enable_video) {
          var videoBorderStyles = "";
          if (this.video.enable_border) {
            videoBorderStyles = "\n        border-radius:".concat(this.video.border.radius, "%;\n        border:").concat(this.video.border.width, "px ").concat(this.video.border.style, " ").concat(this.video.border.color, ";\n        ");
          }
          videoStyles = "\n        .apx-inapp-video".concat(this.cssPostFix, " {\n          width:").concat(this.media_width, ";\n          height:").concat(this.media_height, ";\n          ").concat(videoBorderStyles, "\n        }\n      ");
        }
        return videoStyles;
      }
    }, {
      key: "_getProgressBarStyles",
      value:
      /**
       * @function _getProgressBarStyles
       * @private
       * @description Creates the styles for ProgressBar.
       * @returns {string} css styles
       */
      function _getProgressBarStyles() {
        var progressBarStyles = "";
        if (this.has_progress_bar) {
          progressBarStyles = "\n      .apx-inapp-progress-bar".concat(this.cssPostFix, "{\n        position: absolute;\n        width:100%;\n        height:").concat(this.progressbar.width, "px;\n        ").concat(this.progressbar.position === "top" ? "top:0px;" : "bottom:0px;", "\n        left:0px;\n        z-index:999999;\n        overflow:hidden;\n        cursor: pointer;\n        background:").concat(this.progressbar.reamining_color, ";\n      }\n      .apx-inapp-bar").concat(this.cssPostFix, "{\n        width:100%;\n        height:100%;\n        background:").concat(this.progressbar.progress_color, ";\n      }");
        }
        return progressBarStyles;
      }

      /**
       * @function _getBootstrapiconsStyles
       * @private
       * @description Creates the styles for bootstrap icons.
       * @returns {string} css styles
       */
    }, {
      key: "_getBootstrapiconsStyles",
      value: function _getBootstrapiconsStyles() {
        var bootstrapiconStyles = "\n      .bi::before, [class^=\"bi-\"]::before, [class*=\" bi-\"]::before {\n        display: inline-block;\n        font-style: normal;\n        font-weight: normal !important;\n        font-variant: normal;\n        text-transform: none;\n        line-height: 1;\n        vertical-align: -.125em;\n        -webkit-font-smoothing: antialiased;\n        -moz-osx-font-smoothing: grayscale;\n      }\n      .bi-x::before { \n        content: \"62a\"; \n      }\n      .bi-x-circle-fill::before { \n        content: \"622\"; \n      }\n    ";
        return bootstrapiconStyles;
      }

      /**
       * @function _setInAppModalContent
       * @private
       * @description Sets the content of the InApp modal.
       */
    }, {
      key: "_setInAppModalContent",
      value: function _setInAppModalContent() {
        // Create the Modal container
        this._createInAppContainer();
        if (this.direction.nudge === DIRECTION.VERTICAL) {
          // Create Top Button container
          this._createTopButtonContainer();
          // Set the Top buttons
          this._setButtons(BUTTON_CONTAINER_POSITION.TOP);
        }

        // Create the Media container
        this._createMediaContainer();
        if (this.direction.nudge === DIRECTION.VERTICAL) {
          // Create Center button container
          this._createCenterButtonContainer();
          // Set the Center buttons
          this._setButtons(BUTTON_CONTAINER_POSITION.CENTER);
        }

        // For image InApp, set its properties
        this._setImageOptions();
        // For video InApp, set its properties
        this._setVideoOptions();
        // For icon-text InApp, set its properties
        this._setIconOptions();
        // Create Non-Media container
        this._createNonMediaContainer();
        // For Text-content
        this._setTextContainer();
        // Set the title content
        this._setTitleContent();
        // Set the description content
        this._setDescriptionContent();
        // Set the Form content
        this._setFormContent();
        // Create Buttom container
        this._createButtonContainer();

        // Create Bottom Button container
        this._createBottomButtonContainer();
        // Set the Bottom buttons
        this._setButtons(BUTTON_CONTAINER_POSITION.BOTTOM);

        // Set the ProgressBar
        this._setProgressBar();
        // Set the close button
        this._setCloseButton();

        //Set the Marketing content
        this._setMarketingMessage();
      }

      /**
       * @function _createInAppContainer
       * @private
       * @description Creates the container for the InApp
       */
    }, {
      key: "_createInAppContainer",
      value: function _createInAppContainer() {
        // InApp modal container.
        this.inAppContainer = document.createElement("div");
        this.inAppContainer.classList.add("apx-inapp-container".concat(this.cssPostFix));
        this.overlayElement.appendChild(this.inAppContainer);
        if (this.enable_dismiss_actions && this.dismiss_actions.outside_touch) {
          this.inAppContainer.onclick = function (event) {
            event.stopPropagation();
          };
        }
      }

      /**
       * @function _createMediaContainer
       * @private
       * @description Creates the container for the image/icon/vedio
       */
    }, {
      key: "_createMediaContainer",
      value: function _createMediaContainer() {
        this.mediaContainer = document.createElement("div");
        this.mediaContainer.classList.add("apx-inapp-media-container".concat(this.cssPostFix));
        this.inAppContainer.appendChild(this.mediaContainer);
      }

      /**
       * @function _setImageOptions
       * @private
       * @description Sets the image styles. This is applicable when image_config is sent.
       */
    }, {
      key: "_setImageOptions",
      value: function _setImageOptions() {
        if (this.enable_image) {
          if (this.image.enable_background_image) {
            this.inAppContainer.classList.add("apx-inapp-image".concat(this.cssPostFix));
          } else {
            //const imgDiv = document.createElement("div");
            var imgElement = document.createElement("img");
            imgElement.src = this.image.path;
            imgElement.classList.add("apx-inapp-image".concat(this.cssPostFix));
            //imgDiv.appendChild(imgElement);
            this.mediaContainer.appendChild(imgElement);
          }
        }
      }

      /**
       * @function _setVideoOptions
       * @private
       * @description Sets the video styles. This is applicable when video_config is sent.
       */
    }, {
      key: "_setVideoOptions",
      value: function _setVideoOptions() {
        if (this.enable_video) {
          if (this.video.enable_embed) {
            var videoDiv = document.createElement("div");
            videoDiv.classList.add("apx-inapp-video".concat(this.cssPostFix));
            videoDiv.innerHTML = "".concat(this.video.embed.html);
            this.mediaContainer.appendChild(videoDiv);
          } else {
            var videoElement = document.createElement("video");
            videoElement.classList.add("apx-inapp-video".concat(this.cssPostFix));
            videoElement.controlsList = "noplaybackrate nodownload";
            videoElement.disablePictureInPicture = true;
            videoElement.controls = true;
            videoElement.muted = !this.video.enable_audio;
            var sourceElement = document.createElement("source");
            //Set the video tag attributes
            sourceElement.setAttribute("src", this.video.path);
            sourceElement.setAttribute("type", "video/mp4");
            videoElement.appendChild(sourceElement);
            this.mediaContainer.appendChild(videoElement);
          }
        }
      }

      /**
       * @function _setIconOptions
       * @private
       * @description Sets the icon styles. This is applicable when icon_config is sent.
       */
    }, {
      key: "_setIconOptions",
      value: function _setIconOptions() {
        if (this.enable_icon) {
          var iconDiv = document.createElement("div");
          iconDiv.classList.add("apx-inapp-icon-container".concat(this.cssPostFix));
          var iconElement = document.createElement("img");
          iconElement.src = this.icon.path;
          iconElement.classList.add("apx-inapp-icon-content".concat(this.cssPostFix));
          iconDiv.appendChild(iconElement);
          this.mediaContainer.appendChild(iconDiv);
        }
      }

      /**
       * @function _createNonMediaContainer
       * @private
       * @description Creates the container for the text and buttom
       */
    }, {
      key: "_createNonMediaContainer",
      value: function _createNonMediaContainer() {
        this.nonMediaContainer = document.createElement("div");
        this.nonMediaContainer.classList.add("apx-inapp-nonmedia-container".concat(this.cssPostFix));
        this.inAppContainer.appendChild(this.nonMediaContainer);
      }

      /**
       * @funciton _setTextContainer
       * @private
       * @description Sets the container for the title and the description
       */
    }, {
      key: "_setTextContainer",
      value: function _setTextContainer() {
        this.textContainer = document.createElement("div");
        this.textContainer.classList.add("apx-inapp-text-container".concat(this.cssPostFix));
        this.nonMediaContainer.appendChild(this.textContainer);
      }

      /**
       * @funciton _setTitleContent
       * @private
       * @description Sets the title content in the InApp modal. This is a common config for all modals.
       */
    }, {
      key: "_setTitleContent",
      value: function _setTitleContent() {
        // Create an element for the title and append it to the container.
        if (this.enable_title) {
          // Before creating the text element, evaluate the dynamic text if any
          resolveDynamicText(this.title);
          var titleElement = document.createElement("div");
          titleElement.classList.add("apx-inapp-title-div".concat(this.cssPostFix));
          if (this.title.enable_icon) {
            var titleIconElement = document.createElement("img");
            titleIconElement.src = this.title.icon.path;
            titleIconElement.classList.add("apx-inapp-title-icon".concat(this.cssPostFix));
            titleElement.appendChild(titleIconElement);
          }
          titleElement.appendChild(createNewTextElement(this.title, this.currentId, "title"));
          this.textContainer.appendChild(titleElement);
        }
      }

      /**
       * @funciton _setDescriptionContent
       * @private
       * @description Sets the description content in the InApp modal. This is a common config for all modals.
       */
    }, {
      key: "_setDescriptionContent",
      value: function _setDescriptionContent() {
        // Create an element for the description and append it to the container.
        if (this.enable_description) {
          // Before creating the text element, evaluate the dynamic text if any
          resolveDynamicText(this.description);
          var textElement = document.createElement("div");
          textElement.classList.add("apx-inapp-description".concat(this.cssPostFix));
          textElement.appendChild(createNewTextElement(this.description, this.currentId, "description"));
          textElement.classList.add("apx-inapp-scroll".concat(this.cssPostFix));

          // this.inAppContainer.appendChild(textElement);
          this.textContainer.appendChild(textElement);
        }
      }
    }, {
      key: "_setFormContent",
      value:
      /**
       * @funciton _setFormContent
       * @private
       * @description Sets the form content in the InApp modal.
       */
      function _setFormContent() {
        var _this3 = this;
        if (this.enable_form) {
          var _this$form$elements;
          var formContainer = document.createElement("form");
          formContainer.classList.add("apx-inapp-form-container".concat(this.cssPostFix));
          var dummy = "";
          (_this$form$elements = this.form.elements) === null || _this$form$elements === void 0 || _this$form$elements.forEach(function (element) {
            dummy += generateFormField(element);
          });
          formContainer.innerHTML = dummy;
          this.nonMediaContainer.appendChild(formContainer);
          var form = document.querySelector(".apx-inapp-form-container".concat(this.cssPostFix));
          form.addEventListener("submit", function (e) {
            e.preventDefault();
            var _this3$generateRespon = _this3.generateResponse(_this3.form.elements),
              obj = _this3$generateRespon.obj,
              callback = _this3$generateRespon.callback;
            var evalString = "(obj)=>" + callback + "(obj)";
            var evalFunction = eval(evalString);
            evalFunction(obj);
            clearTimeout(_this3.terminationTimeoutId);
            _this3.closeCallback(_this3.overlayElement, "dismiss", ".apx-inapp-container".concat(_this3.cssPostFix), _this3.closeListener, _this3.redirectionListener);
          });
        }
      }
      /**
       * @function _createButtomContainer
       * @private
       * @description Creates the container for the buttons
       */
    }, {
      key: "_createButtonContainer",
      value: function _createButtonContainer() {
        if (this.direction.non_media === DIRECTION.VERTICAL) {
          return;
        }
        this.buttonContainer = document.createElement("div");
        this.buttonContainer.classList.add("apx-inapp-button-container".concat(this.cssPostFix));
        this.nonMediaContainer.appendChild(this.buttonContainer);
      }
      /**
       * @function _setProgressBar
       * @private
       * @description Set the progressbar.
       */
    }, {
      key: "_setProgressBar",
      value: function _setProgressBar() {
        if (this.enable_stepper && this.stepper.enable_progressbar) {
          this.progressbar = this.stepper.progressbar;
          var progressBar = document.createElement("div");
          progressBar.classList.add("apx-inapp-progress-bar".concat(this.cssPostFix));
          var bar = document.createElement("div");
          bar.classList.add("apx-inapp-bar".concat(this.cssPostFix));
          if (this.stepper.index <= this.stepper.length) {
            bar.style.transform = "translateX(".concat(-(100 - 100 / this.stepper.length * this.stepper.index), "%)");
          } else {
            progressBar.style.visibility = "hidden";
          }
          progressBar.appendChild(bar);
          this.inAppContainer.appendChild(progressBar);
        }
      }
      /**
       * @function _createTopButtomContainer
       * @private
       * @description Creates the container for the top buttons
       */
    }, {
      key: "_createTopButtonContainer",
      value: function _createTopButtonContainer() {
        var _this$buttons;
        if (this.enable_buttons && (_this$buttons = this.buttons) !== null && _this$buttons !== void 0 && _this$buttons.enable_top) {
          this.topButtonContainer = document.createElement("div");
          this.topButtonContainer.classList.add("apx-inapp-top-button-container".concat(this.cssPostFix));
          this.inAppContainer.appendChild(this.topButtonContainer);
        }
      }
      /**
       * @function _createCenterButtomContainer
       * @private
       * @description Creates the container for the center buttons
       */
    }, {
      key: "_createCenterButtonContainer",
      value: function _createCenterButtonContainer() {
        var _this$buttons2;
        if (this.enable_buttons && (_this$buttons2 = this.buttons) !== null && _this$buttons2 !== void 0 && _this$buttons2.enable_center) {
          this.centerButtonContainer = document.createElement("div");
          this.centerButtonContainer.classList.add("apx-inapp-center-button-container".concat(this.cssPostFix));
          this.inAppContainer.appendChild(this.centerButtonContainer);
        }
      }
      /**
       * @function _createBottomButtomContainer
       * @private
       * @description Creates the container for the bottom buttons
       */
    }, {
      key: "_createBottomButtonContainer",
      value: function _createBottomButtonContainer() {
        var _this$buttons3;
        if (this.enable_buttons && (_this$buttons3 = this.buttons) !== null && _this$buttons3 !== void 0 && _this$buttons3.enable_bottom) {
          this.bottomButtonContainer = document.createElement("div");
          this.bottomButtonContainer.classList.add("apx-inapp-bottom-button-container".concat(this.cssPostFix));
          if (this.direction.non_media === DIRECTION.VERTICAL) {
            this.nonMediaContainer.appendChild(this.bottomButtonContainer);
          } else {
            this.buttonContainer.appendChild(this.bottomButtonContainer);
          }
        }
      }
      /**
       * @function _setButtons
       * @private
       * @description Generate the Button's and append them to the specified button container.
       *
       */
    }, {
      key: "_setButtons",
      value: function _setButtons(position) {
        var _this4 = this;
        if (!this.enable_buttons) {
          return;
        }
        if (position === BUTTON_CONTAINER_POSITION.TOP && this.buttons.enable_top || position === BUTTON_CONTAINER_POSITION.CENTER && this.buttons.enable_center || position === BUTTON_CONTAINER_POSITION.BOTTOM && this.buttons.enable_bottom) {
          var overlay = this.overlayElement;
          var actionCallback = function actionCallback(isCancelled, action) {
            clearTimeout(_this4.terminationTimeoutId);
            _this4.closeCallback(overlay, action, "new-inline".concat(_this4.cssPostFix), _this4.closeListener, _this4.redirectionListener);
          };
          var next_Callback = function next_Callback(id, action) {
            actionCallback(false, "next");
            _this4.stepperCallBack(id, action);
          };
          var prev_Callback = function prev_Callback(id, action) {
            actionCallback(false, "prev");
            _this4.stepperCallBack(id, action);
          };
          var actionHandler = {
            next: next_Callback,
            prev: prev_Callback,
            complete: actionCallback,
            cancel: actionCallback,
            _isCancelled: false,
            action: ""
          };
          var buttons_config = {};
          if (position === BUTTON_CONTAINER_POSITION.TOP) {
            buttons_config = this.buttons.top;
          } else if (position === BUTTON_CONTAINER_POSITION.CENTER) {
            buttons_config = this.buttons.center;
          } else {
            buttons_config = this.buttons.bottom;
          }
          var _Buttons = generateButtonsBlock(this.configId, this.name, this.stepper, EVENT_PREFIX.INAPP, buttons_config, this.direction.buttons, "", position, actionHandler, this.isWalkthrough, this.uis, this.index);
          if (position === BUTTON_CONTAINER_POSITION.TOP) {
            this.topButtonContainer.appendChild(_Buttons);
          } else if (position === BUTTON_CONTAINER_POSITION.CENTER) {
            this.centerButtonContainer.appendChild(_Buttons);
          } else {
            this.bottomButtonContainer.appendChild(_Buttons);
          }
        }
      }

      /**
       * @function _setCloseButton
       * @private
       * @description If close is enabled set the close button on the modal. This is a common config for all modals.
       */
    }, {
      key: "_setCloseButton",
      value: function _setCloseButton() {
        var _this5 = this;
        if (this.enable_close_button) {
          var closeButton = document.createElement("span");
          // Close button SVG is decided based on the type of the button in the config.
          if (this.close_button.type === CLOSE_BUTTON_STYLE.NORMAL) {
            closeButton.innerHTML = getCloseSVG(this.close_button.width, this.close_button.height, this.close_button.color);
          } else if (this.close_button.type === CLOSE_BUTTON_STYLE.FILL) {
            if (this.close_button.shape === "circle") {
              closeButton.innerHTML = getCloseWithCircleSVG(this.close_button.width, this.close_button.height, this.close_button.fill_color, this.close_button.color);
            } else {
              closeButton.innerHTML = getCloseWithRectangleSVG(this.close_button.width, this.close_button.height, this.close_button.fill_color, this.close_button.color);
            }
          } else {
            closeButton.innerHTML = "<img src=\"".concat(this.close_button.path, "\" width=\"").concat(this.close_button.width, "px\" height=\"").concat(this.close_button.height, "px\"></img>");
          }
          closeButton.classList.add("apx-inapp-close".concat(this.cssPostFix));
          closeButton.addEventListener("click", function () {
            clearTimeout(_this5.terminationTimeoutId);
            _this5.rtmInstance.logActionEvent("InAppXIconClicked", _this5.configId, _this5.name);
            _this5.closeCallback(_this5.overlayElement, _this5.close_button.action, ".apx-inapp-container".concat(_this5.cssPostFix), _this5.closeListener, _this5.redirectionListener);
          });
          this.direction.non_media === DIRECTION.VERTICAL || this.direction.nudge === DIRECTION.VERTICAL ? this.inAppContainer.appendChild(closeButton) : this.buttonContainer.appendChild(closeButton);
        }
      }
    }, {
      key: "_setAutoTerminate",
      value:
      /**
       * @function _setAutoTerminate
       * @private
       * @description If the auto dismiss is enabled, sets the timeout to call the InApp close.
       */
      function _setAutoTerminate() {
        var _this6 = this;
        if (this.terminationConfig.auto_dismiss === true) {
          this.terminationTimeoutId = window.setTimeout(function () {
            _this6.closeCallback(_this6.overlayElement, "dismiss", ".apx-inapp-container".concat(_this6.cssPostFix), _this6.closeListener, _this6.redirectionListener);
          }, this.terminationConfig.duration);
        }
      }

      /**
       * @function _showInApp
       * @private
       * @description Opens the InApp modal and lets the world know by calling the showcallback.
       */
    }, {
      key: "_showInApp",
      value: function _showInApp() {
        this.inAppContainer.classList.toggle("open");
        this.showCallback();
      }
    }]);
    return ModalInApp;
  }();

  var Logger$3 = window.ApxorLogger;
  function createInApp(width, height, _ref) {
    var dimmed_background = _ref.dimmed_background;
    var dialogRoot = document.createElement("div");
    dialogRoot.setAttribute("id", APX_OVERLAY);
    var styleNode = document.createElement("style");
    styleNode.innerHTML = "#apx-oly {\n    width:auto;height:auto;position:fixed;top:0;right:0;bottom:0;left:0;\n    display:flex;justify-content:center;align-items:center;border-radius:3px;z-index:99999999;background-color:".concat(dimmed_background ? "#31313185" : "transparent", ";\n\n  }\n  #apx-oly > * {font-family:inherit;box-sizing:unset}\n  .apx-dlg-c {\n    height:auto;width:auto;z-index:99999999;opacity:0;transition:all .5s cubic-bezier(.96,.23,.07,.8);position:fixed;visibility:hidden;\n    border-radius:3px;overflow:hidden\n  }\n  .apx-dlg-c.open{opacity:1;visibility:visible;width:100%;height:100%;}\n  ").replaceAll("\n", "").replace(/[\s]{2,999}/g, "");
    var dialogContent = document.createElement("div");
    dialogContent.setAttribute("id", APX_DIALOG_CONTENT);
    dialogContent.classList.add(APX_DIALOG_CONTENT);
    dialogRoot.appendChild(dialogContent);
    dialogRoot.appendChild(styleNode);
    document.body.appendChild(dialogRoot);
    return dialogRoot;
  }
  function createInAppVideo(videoConfig, terminationConfig, configId, name, showCallback, hideCallback) {
    if (VideoInApp.isAVideoBeingPlayed()) {
      return;
    }
    if (!VideoInApp.canShowVideoInApp(videoConfig)) {
      return;
    }
    var VideoInAppInstance = new VideoInApp(videoConfig, terminationConfig, configId, name, showCallback, hideCallback);
    VideoInAppInstance.showVideoInApp();
  }

  /**
   * Creates a modal for the given config and displays it.
   * Supported Modals are "small-text","medium-text","large-text","icon-text","image-text","image-only","custom-size-text","video-text"
   * @param {JSON} config
   * @param {string} configId
   * @param {string} name
   * @param {function} showCallback
   * @param {function} closeCallback
   */
  function createInAppModal(config, terminationConfig, configId, name, showCallback, closeCallback, stepperCallBack, isWalkthrough, uis, index) {
    var inappModal = new ModalInApp(config, terminationConfig, configId, name, showCallback, closeCallback, stepperCallBack, isWalkthrough, uis, index);
    inappModal.createInAppModal();
  }
  var InAppConfigItem = /*#__PURE__*/_createClass$1(function InAppConfigItem() {
    var _this = this;
    _classCallCheck$1(this, InAppConfigItem);
    _defineProperty$1(this, "_inApp", new ApxorInApp());
    _defineProperty$1(this, "initialize", function (configId, name, uiJson) {
      var uis = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
      var index = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
      var stepperCallBack = arguments.length > 5 ? arguments[5] : undefined;
      var isWalkthrough = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;
      var delay = uiJson.delay,
        _uiJson$layout_type = uiJson.layout_type,
        layout_type = _uiJson$layout_type === void 0 ? "" : _uiJson$layout_type,
        _uiJson$html_config$d = uiJson.html_config.data,
        data = _uiJson$html_config$d === void 0 ? "" : _uiJson$html_config$d,
        _uiJson$window_attrib = uiJson.window_attributes,
        _uiJson$window_attrib2 = _uiJson$window_attrib.width,
        width = _uiJson$window_attrib2 === void 0 ? "auto" : _uiJson$window_attrib2,
        _uiJson$window_attrib3 = _uiJson$window_attrib.height,
        height = _uiJson$window_attrib3 === void 0 ? "auto" : _uiJson$window_attrib3,
        _uiJson$window_attrib4 = _uiJson$window_attrib.dimmed_background,
        dimmed_background = _uiJson$window_attrib4 === void 0 ? true : _uiJson$window_attrib4,
        _uiJson$window_attrib5 = _uiJson$window_attrib.dismiss_outside_touch,
        dismiss_outside_touch = _uiJson$window_attrib5 === void 0 ? false : _uiJson$window_attrib5,
        _uiJson$window_attrib6 = _uiJson$window_attrib.position,
        position = _uiJson$window_attrib6 === void 0 ? CENTER : _uiJson$window_attrib6;
      _this.configId = configId;
      _this.name = name;
      _this.delay = delay || 0;
      _this.width = width;
      _this.height = height;
      _this.layoutConfig = {
        layout_type: layout_type,
        dimmed_background: dimmed_background,
        dismiss_outside_touch: dismiss_outside_touch,
        position: position
      };
      _this.htmlConfig = {
        data: data
      };
      _this.uis = uis;
      _this.index = index;
      _this.ui = uiJson;
      _this.rtmInstance = window.ApxorRTM;
      _this.on_show = function () {
        // onShown callback
        _this.rtmInstance.logActionEvent("inapp_shown", _this.configId, _this.name);
        _this.rtmInstance.isShowingAction = true;
        _this.rtmInstance.currentAction = function () {};
      };
      _this.on_hide = function () {
        var action = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
        // onHidden callback
        _this.rtmInstance.isShowingAction = false;
        _this.rtmInstance.currentAction = null;
        if (action.toLowerCase() !== "cancel") {
          _this.rtmInstance.logActionEvent("inapp_dismissed", _this.configId, _this.name);
        } else {
          _this.rtmInstance.logActionEvent("walkthrough_cancelled", _this.configId, _this.name);
        }
      };
      _this.stepperCallBack = stepperCallBack;
      _this.isWalkthrough = isWalkthrough;
      return true;
    });
    _defineProperty$1(this, "showInApp", function (configId, terminationConfig) {
      if (!_this.isValid) {
        return false;
      }
      setTimeout(function () {
        if (_this.rtmInstance.currentAction !== null && _this.rtmInstance.currentAction !== undefined) {
          Logger$3.error("An action is already being shown.");
          return;
        }
        try {
          ceWrapper.getInstance().updateCount(_this.configId);
          if (_this.layoutConfig.layout_type === INAPP_TYPE.VIDEO) {
            //Create in-app-video
            createInAppVideo(_this.ui, terminationConfig, _this.configId, _this.name, _this.on_show, _this.on_hide);
          } else if (_this.layoutConfig.layout_type === INAPP_TYPE.MODAL) {
            createInAppModal(_this.ui, terminationConfig, _this.configId, _this.name, _this.on_show, _this._closeInApp, _this.stepperCallBack, _this.isWalkthrough, _this.uis, _this.index);
          } else {
            var backgroundDiv = createInApp(_this.width, _this.height, _this.layoutConfig);
            if (_this.layoutConfig.dismiss_outside_touch) {
              document.getElementById(APX_OVERLAY).onclick = function () {
                _this._closeInApp(backgroundDiv);
              };
            }
            setTimeout(function () {
              backgroundDiv.children[0].classList.toggle("open");
              backgroundDiv.children[0].innerHTML = _this.htmlConfig.data;
              _this._logInAppEvent(INAPP_SHOWN);
              _this.on_show();
              var anchors = backgroundDiv.querySelectorAll("a");
              anchors.forEach(function (anchor) {
                anchor.onclick = function () {
                  return _this._takeAction(backgroundDiv, anchor);
                };
              });
            }, 100);
          }
        } catch (e) {
          Logger$3.error(e);
        }
      }, _this.delay);
    });
    _defineProperty$1(this, "_takeAction", function (backgroundDiv, anchor) {
      var href = anchor.getAttribute("href");
      if (href != null && href.includes("apxor")) {
        var action = href.replace(/^apxor:\/\/([^?]*).*?$/, "$1");
        var buttonName;
        switch (action) {
          case "cancel":
            _this._logInAppEvent(WALK_THROUGH_CANCELLED);
            break;
          case "xclose":
            _this._logInAppEvent(INAPP_XICON_CLICKED);
            break;
          case "close":
            buttonName = href.replace(/(.*?)buttonName=([^&]*).*?$/, "$2");
            _this._logInAppEvent(INAPP_BUTTON_CLICKED(buttonName === "" ? "Button" : buttonName));
            break;
          case "dl_url":
            {
              var url = href.replace(/(.*?)uri=([^&]*).*?$/, "$2");
              var isExternal = href.replace(/(.*?)external=([^&]*).*?$/, "$2");
              buttonName = href.replace(/(.*?)buttonName=([^&]*).*?$/, "$2");
              _this._logInAppEvent(INAPP_BUTTON_CLICKED(buttonName === "" ? "Button" : buttonName));
              if (isExternal == "true") {
                window.open(url, "_blank");
              } else {
                Apxor.logClientEvent("REDIRECT", {
                  url: url
                });
              }
              break;
            }
        }
        _this._closeInApp(backgroundDiv, action);
        return false;
      } else {
        return true;
      }
    });
    _defineProperty$1(this, "_closeInApp", function (backgroundDiv, action) {
      var _dialogContent$classL;
      var cssClass = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ".apx-dlg-c";
      var closeListener = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
      var redirectionListener = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
      document.body.removeEventListener("click", closeListener);
      document.body.removeEventListener("click", redirectionListener);
      var dialogContent = document.querySelector(cssClass);
      dialogContent === null || dialogContent === void 0 || (_dialogContent$classL = dialogContent.classList) === null || _dialogContent$classL === void 0 || _dialogContent$classL.toggle("open");
      // setTimeout(() => {
      backgroundDiv.remove();
      _this.on_hide(action);
      // }, 300);
    });
    _defineProperty$1(this, "_logInAppEvent", function (name) {
      var attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var meta = _this.rtmInstance.getCampaignMeta(_this.configId);
      var attrs = meta._attr;
      Apxor.logEvent(name, _objectSpread2$1(_objectSpread2$1({
        id: _this.configId,
        message_name: _this.name
      }, attributes), attrs));
    });
    this.isValid = true;
  });

  var ApxorInApp = /*#__PURE__*/_createClass$1(function ApxorInApp() {
    _classCallCheck$1(this, ApxorInApp);
    _defineProperty$1(this, "parse", function (configId, name, uiJson) {
      var uis = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
      var index = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
      var stepperCallBack = arguments.length > 5 ? arguments[5] : undefined;
      var isWalkthrough = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;
      /*
      Parses the JSON and returns an instance of InAppConfigItem
      which will be used to show the inapp
      */
      var configItem = new InAppConfigItem();
      if (configItem.initialize(configId, name, uiJson, uis, index, stepperCallBack, isWalkthrough)) {
        return configItem;
      }
      return null;
    });
  });

  var onMouseOver = function onMouseOver(e) {
    if (e.target) {
      var classList = e.target.classList;
      var isApxor = classList.contains("apx-highlight") || classList.toString().indexOf("apx-") !== -1;
      if (classList && !isApxor) {
        e.target.classList.add("apx-highlight");
        e.target.oldOnClick = e.target.onclick;
        e.target.onclick = null;
      }
    }
  };
  var onMouseOut = function onMouseOut(e) {
    if (e.target) {
      if (e.target.classList && e.target.classList.contains("apx-highlight")) {
        e.target.classList.remove("apx-highlight");
        e.target.onclick = e.target.oldOnClick;
        e.target.oldOnClick = null;
      }
    }
  };
  var handleDocumentOnClick = function handleDocumentOnClick(e, callback) {
    var target = e.target;
    if (target && target.classList.contains("apx-highlight")) {
      e.preventDefault();
      e.stopPropagation();
      target.classList.remove("apx-highlight");
      target.onclick = target.oldOnClick;
      target.oldOnClick = null;
      if (callback) {
        callback(target);
      }
    }
  };
  function dragElement(elmnt) {
    var PADDING = 8;
    var rect;
    var viewport = {
      bottom: window.innerHeight - PADDING,
      left: PADDING,
      right: window.innerWidth - PADDING,
      top: PADDING
    };
    var xPos = 0,
      yPos = 0,
      oldX = 0,
      oldY = 0;
    var dragEle = document.getElementById(elmnt.id + "-h");
    if (dragEle) {
      dragEle.addEventListener("mousedown", dragMouseDown);
      dragEle.addEventListener("touchstart", dragMouseDown, {
        passive: false
      });
    } else {
      elmnt.addEventListener("mousedown", dragMouseDown);
      elmnt.addEventListener("touchstart", dragMouseDown, {
        passive: false
      });
    }
    function dragMouseDown(e) {
      e.preventDefault();
      e.stopPropagation();
      e = e || window.event;
      if (e.type === "touchstart") {
        oldX = e.targetTouches[0].pageX;
        oldY = e.targetTouches[0].pageY;
      } else {
        oldX = e.clientX;
        oldY = e.clientY;
      }
      rect = elmnt.getBoundingClientRect();
      document.addEventListener("mouseup", closeDragElement);
      document.addEventListener("touchend", closeDragElement, {
        passive: false
      });
      document.addEventListener("mousemove", elementDrag);
      document.addEventListener("touchmove", elementDrag, {
        passive: false
      });
    }
    function elementDrag(e) {
      e.preventDefault();
      e.stopPropagation();
      e = e || window.event;
      // calculate the new cursor position:

      if (e.type === "touchmove") {
        xPos = oldX - e.targetTouches[0].pageX;
        yPos = oldY - e.targetTouches[0].pageY;
        oldX = e.targetTouches[0].pageX;
        oldY = e.targetTouches[0].pageY;
      } else {
        xPos = oldX - e.clientX;
        yPos = oldY - e.clientY;
        oldX = e.clientX;
        oldY = e.clientY;
      }
      var newLeft = elmnt.offsetLeft - xPos;
      var newTop = elmnt.offsetTop - yPos;
      if (newLeft < viewport.left || newTop < viewport.top || newLeft + rect.width > viewport.right || newTop + rect.height > viewport.bottom) ; else {
        elmnt.style.top = elmnt.offsetTop - yPos + "px";
        elmnt.style.left = elmnt.offsetLeft - xPos + "px";
        elmnt.style.right = "";
      }
    }
    function closeDragElement() {
      document.removeEventListener("mouseup", closeDragElement);
      document.removeEventListener("touchend", closeDragElement);
      document.removeEventListener("mousemove", elementDrag);
      document.removeEventListener("touchmove", elementDrag);
    }
  }

  var ON_HTML = "<b>View Selection Mode: ON";
  var OFF_HTML = "<b>View Selection Mode: OFF</b>";
  var SSE_API = "https://server.apxor.com/v1/sse/";
  var LAYOUT_URL = SSE_API + "layout?appId=<aid>&deviceId=<uid>";
  var PREVIEW_API = SSE_API + "ui-config?appId=<aid>&deviceId=<uid>";
  var CONFIG_API = SSE_API + "art-config?appId=<aid>&deviceId=<uid>";
  var FRONTEND_API = "https://server.apxor.com/v4/frontendapi/web/test-devices";
  var ADD_TEST_DEVICE_API = FRONTEND_API + "?appId=<aid>";
  var REMOVE_TEST_DEVICE_API = FRONTEND_API + "/<uid>?appId=<aid>";
  var WYSIWYG = /*#__PURE__*/_createClass$1(function WYSIWYG() {
    var _this = this;
    _classCallCheck$1(this, WYSIWYG);
    _defineProperty$1(this, "_styleNode", null);
    _defineProperty$1(this, "_viewPickerNode", null);
    _defineProperty$1(this, "_addRemoveTestDeviceDialog", null);
    _defineProperty$1(this, "_wysiwygRoot", null);
    _defineProperty$1(this, "_vid", "");
    _defineProperty$1(this, "_type", getDevice());
    _defineProperty$1(this, "init", function (siteId, rtmInstance) {
      // Enable WYSIWYG only when cookie is enabled
      var encodedKey = getCookie("_apx_ewc");
      if (!encodedKey) {
        // If no cookie don't initialize the plugin
        return;
      }

      // Get the stored key in cookie
      var key = atob(encodedKey);
      try {
        // Read the data using the decoded key from localStorage
        var decodedData = Apxor.getController().getFromStorage(key, true);
        if (!decodedData) {
          // If there is no data, someone is trying to inflitrate
          return;
        }
        var app_id = decodedData.app_id,
          expiry = decodedData.expiry,
          volatile_id = decodedData.volatile_id;
        _this._vid = volatile_id;
        if (app_id === siteId && Date.now() <= expiry) {
          // No need to delete the cookie as it will be taken care by the Browser
          // deleteCookie("_apx_ew");

          // Create a node which display a small div at the center of the screen
          // When view selection is enabled/disabled
          var node = document.createElement("span");
          node.style = "z-index:99999999;visibility:hidden;position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);padding:16px 24px;background:#252f37;border-radius:3px;opacity:0;font-size:24px;color:white;transition:all .3s ease-out";
          node.innerHTML = ON_HTML;
          _this._viewPickerNode = node;
          document.body.appendChild(node);

          // Create the style node which will be used to highlight the views upon mouse hover
          _this._styleNode = document.createElement("style");
          _this._styleNode.innerHTML = ".apx-highlight{height:auto;z-index:9999999999;outline: 2px solid red;cursor:default}";
          document.body.appendChild(_this._styleNode);
          _this.isSelectionMode = false;

          // Get the existind test device information, if this is user is already marked this as a test device
          _this.testDeviceData = Apxor.getController().getFromStorage("_apx_td", true);
          if (_this.testDeviceData) {
            var _this$testDeviceData = _this.testDeviceData,
              _this$testDeviceData$ = _this$testDeviceData.name,
              name = _this$testDeviceData$ === void 0 ? "" : _this$testDeviceData$,
              _this$testDeviceData$2 = _this$testDeviceData.id,
              id = _this$testDeviceData$2 === void 0 ? "" : _this$testDeviceData$2;

            // If both ID and NAME exists, then send this device as selected device for preview and testing
            // Also, wait for the preview messages from SSE server
            if (name !== "" && id !== "") {
              _this._makeSSERequest("select", "".concat(name, " - ").concat(id), id);
              var previewEventSource = new EventSource(PREVIEW_API.replace("<aid>", siteId).replace("<uid>", id));
              var artConfigEventSource = new EventSource(CONFIG_API.replace("<aid>", siteId).replace("<uid>", id));
              previewEventSource.onmessage = artConfigEventSource.onmessage = function (e) {
                if (e && e.data && e.data !== "{}") {
                  _this._handleSSEResponse(rtmInstance, e.data);
                }
              };
            }
          }
          _this._createDraggableWYSIWYGOverlay(rtmInstance);
        }
      } catch (e) {
        window.ApxorLogger.error("WYSIWYG can not be initialised");
      }
    });
    _defineProperty$1(this, "tearDown", function () {
      // TODO: Make sure all cleanups are properly done
      _this._viewPickerNode.parentNode.removeChild(_this._viewPickerNode);
      _this._styleNode.parentNode.removeChild(_this._styleNode);
    });
    /**
     * Dashboard sends the preview or testing configurations over an SSE connection
     *
     * Interprets the command and performs necessary action
     */
    _defineProperty$1(this, "_handleSSEResponse", function (rtmInstance, json) {
      try {
        _this._wysiwygRoot.dispatchEvent(new CustomEvent("preview"));
        var data = JSON.parse(json);
        var _data$cmd = data.cmd,
          command = _data$cmd === void 0 ? "prev" : _data$cmd;
        if (command === "prev") {
          if (data !== null && data !== void 0 && data.ui) {
            var id = uuid(36);
            var response = {
              configs: [{
                _id: id,
                enabled: true,
                terminate_info: {
                  auto_dismiss: false,
                  duration: 1000
                },
                meta: {
                  name: APX_PREVIEW_CAMPAIGN_NAME,
                  type: data.type
                },
                ui: data.ui
              }]
            };
            rtmInstance._storeConfigs(data.type !== "SURVEY" ? 0 : 1, response);
            Apxor.getController().dispatchEvent(data.type, {
              name: data.type,
              additional_info: {
                uuid: id,
                name: APX_PREVIEW_CAMPAIGN_NAME
              }
            });
          } else if (data !== null && data !== void 0 && data.messages) {
            var surveys = [];
            var walkthroughs = [];
            data.messages.forEach(function (message) {
              if (message.meta.type !== "SURVEY") {
                walkthroughs.push(message);
              } else {
                surveys.push(message);
              }
            });
            if (walkthroughs.length > 0) {
              rtmInstance.handleResponse(0, {
                configs: walkthroughs
              });
            }
            if (surveys.length > 0) {
              rtmInstance.handleResponse(1, {
                configs: surveys
              });
            }
          }
        }
      } catch (e) {
        console.error(e);
      }
    });
    /**
     * Creates a draggable div which contains the following options
     *
     * - Add as Test Device
     * - Remove Test Device
     * - Enable View Selection Mode
     * - Disable View Selection Mode
     */
    _defineProperty$1(this, "_createDraggableWYSIWYGOverlay", function (rtmInstance) {
      var isAdded = _this.testDeviceData !== null && _this.testDeviceData !== undefined && _this.testDeviceData.id && _this.testDeviceData.name;
      var html = "\n        <style>\n            .apx-cr{\n              display:flex;\n              justify-content:center;\n              align-items:center;\n              flex-direction:column;\n              gap:10px\n            }\n            .apx-b{\n              border:none;\n              font-size:16px;\n              font-family:inherit;\n              padding:8px 14px;\n              cursor:pointer\n            }\n            .apx-close:before{\n              content:'\\58';\n              font-size:9px;\n              color:#969696;\n              cursor:pointer;\n              position:absolute;\n              top:1px;\n              right:3px\n            }\n        </style>\n        <div>\n            <svg class=\"apx-\" id=\"apx-wr-h\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1\" preserveAspectRatio=\"xMidYMid meet\" viewBox=\"280.6027397260274 189.52023061718432 89.75342465753425 54.49346801295263\" width=\"60\" height=\"40\" style=\"width:40px;position:absolute;top:17px;left:50%;transform:translate(-50%, -50%);cursor:move;\">\n            <defs>\n              <path\n                d=\"M304.6 201.52C304.6 208.14 299.23 213.52 292.6 213.52C285.98 213.52 280.6 208.14 280.6 201.52C280.6 194.9 285.98 189.52 292.6 189.52C299.23 189.52 304.6 194.9 304.6 201.52Z\"\n                id=\"e2aMl5NH8S\"\n              />\n              <path\n                d=\"M324.9 189.54C331.52 189.16 337.2 194.21 337.58 200.82C337.97 207.43 332.91 213.12 326.3 213.5C319.69 213.89 314.01 208.83 313.62 202.22C313.24 195.61 318.29 189.93 324.9 189.54Z\"\n                id=\"e2L4sySuvL\"\n              />\n              <path\n                d=\"M304.6 232.01C304.6 225.39 299.23 220.01 292.6 220.01C285.98 220.01 280.6 225.39 280.6 232.01C280.6 238.64 285.98 244.01 292.6 244.01C299.23 244.01 304.6 238.64 304.6 232.01Z\"\n                id=\"a5AJxVSDw\"\n              />\n              <path\n                d=\"M337.6 232.01C337.6 225.39 332.23 220.01 325.6 220.01C318.98 220.01 313.6 225.39 313.6 232.01C313.6 238.64 318.98 244.01 325.6 244.01C332.23 244.01 337.6 238.64 337.6 232.01Z\"\n                id=\"bjnangUBy\"\n              />\n              <path\n                d=\"M370.36 232.01C370.36 225.39 364.98 220.01 358.36 220.01C351.73 220.01 346.36 225.39 346.36 232.01C346.36 238.64 351.73 244.01 358.36 244.01C364.98 244.01 370.36 238.64 370.36 232.01Z\"\n                id=\"a8aeEZTAL0\"\n              />\n              <path\n                d=\"M369.36 201.52C369.36 194.9 363.98 189.52 357.36 189.52C350.73 189.52 345.36 194.9 345.36 201.52C345.36 208.14 350.73 213.52 357.36 213.52C363.98 213.52 369.36 208.14 369.36 201.52Z\"\n                id=\"a4VJpGfPPp\"\n              />\n            </defs>\n            <g>\n              <g>\n                <g>\n                  <use xlink:href=\"#e2aMl5NH8S\" opacity=\"1\" fill=\"#000000\"  fill-opacity=\"1\" />\n                </g>\n                <g>\n                  <use xlink:href=\"#e2L4sySuvL\" opacity=\"1\" fill=\"#000000\" fill-opacity=\"1\"/>\n                </g>\n                <g>\n                  <use xlink:href=\"#a5AJxVSDw\" opacity=\"1\" fill=\"#000000\" fill-opacity=\"1\"/>\n                </g>\n                <g>\n                  <use xlink:href=\"#bjnangUBy\" opacity=\"1\" fill=\"#000000\" fill-opacity=\"1\"/>\n                </g>\n                <g>\n                  <use xlink:href=\"#a8aeEZTAL0\" opacity=\"1\" fill=\"#000000\" fill-opacity=\"1\"/>\n                </g>\n                <g>\n                  <use xlink:href=\"#a4VJpGfPPp\" opacity=\"1\" fill=\"#000000\" fill-opacity=\"1\"/>\n                </g>\n              </g>\n            </g>\n          </svg>\n        </div>\n        <div class=\"apx-cr\" style=\"gap:0;margin-top:20px;margin-bottom=20px;\">\n          <img class=\"apx-\" width=\"54\" height=\"54\" src=\"https://f.hubspotusercontent10.net/hub/5329664/hubfs/Apxor%20X%20logo.png?width=108&height=108\" />\n        </div>\n        <div id=\"apx-bh\" class=\"apx-cr apx-bh\" style=\"padding:8px 20px;\">\n          <button class=\"apx-b\" id=\"apx-a\" style=\"display:".concat(isAdded ? "none" : "block", "\">\n              Add as test device\n          </button>\n          <button class=\"apx-b\" id=\"apx-r\" style=\"display:").concat(isAdded ? "block" : "none", "\">\n              Remove as test device\n          </button>\n          <button class=\"apx-b\" id=\"apx-ev\" style=\"display:").concat(isAdded && _this.isSelectionMode ? "none" : isAdded ? "block" : "none", "\">\n              Enable view selection\n          </button>\n          <button class=\"apx-b\" id=\"apx-dv\" style=\"display:").concat(isAdded && _this.isSelectionMode ? "block" : "none", "\">\n              Disable view selection\n          </button>\n        </div>\n    ");

      //Remove the overlay if its already created.
      var wysiwyg_overlay = document.getElementById("apx-wr");
      if (wysiwyg_overlay && wysiwyg_overlay.remove) {
        wysiwyg_overlay.remove();
      }
      var node = document.createElement("div");
      node.style = "\n      z-index:99999999;\n      position:fixed;\n      top:8px;\n      right:8px;\n      background:white;\n      box-shadow:0px 0px 7px 7px black;\n      border-radius:3px;\n      padding:20px;\n      border: 5px solid rgba(0, 0, 0, 0.7);\n    ";
      node.setAttribute("id", "apx-wr");
      node.innerHTML = html;
      document.body.appendChild(node);
      _this._wysiwygRoot = node;
      var buttons = document.getElementById("apx-bh");
      var hide = function hide() {
        node.style.opacity = 0.5;
        buttons.style.display = "none";
      };
      var timeoutHandler = setTimeout(hide, 3000);

      // Upon mouseout of this div, show the buttons and reset the opacity back to 1
      node.addEventListener("mouseover", function () {
        node.style.opacity = 1;
        clearTimeout(timeoutHandler);
        buttons.style.display = "flex";
      });

      // Upon mouseout of this div, hide the buttons and decrease the opacity to 0.5
      node.addEventListener("mouseout", function () {
        timeoutHandler = setTimeout(hide, 3000);
      });
      var addDeviceButton = document.getElementById("apx-a");
      var removeDeviceButton = document.getElementById("apx-r");
      var enableViewSelectionButton = document.getElementById("apx-ev");
      var disableViewSelectionButton = document.getElementById("apx-dv");
      addDeviceButton.onclick = function () {
        return _this._showAddTestDeviceDialog(rtmInstance);
      };
      removeDeviceButton.onclick = function () {
        // Make remove API call
        fetch(REMOVE_TEST_DEVICE_API.replace("<aid>", Apxor.getSiteId()).replace("<uid>", _this.testDeviceData.id), {
          method: "DELETE",
          headers: {
            apx_web_key: "WTCKFAIVAJKYJA3HCV80WIKZU98R9NJG"
          }
        }).then(function (res) {
          if (res.ok && res.status === 200) {
            return res.json();
          }
          return null;
        }).then(function (data) {
          if (data) {
            Apxor.getController().persistToStorage("_apx_td", {}, true);
            _this.testDeviceData = null;
            addDeviceButton.style.display = "block";
            removeDeviceButton.style.display = enableViewSelectionButton.style.display = disableViewSelectionButton.style.display = "none";
            if (_this.isSelectionMode) {
              _this._hideSelectionMode();
            }
          }
        })["catch"](function (e) {
          return console.error(e);
        });
      };

      /**
       * @function traverseLayouts
       * @description get the layouts and loop  through the layout and finds the view(id,path,bounds) that was clicked
       * * @param {Array}layouts - layouts of the document
       * *@param {number}x  - X value of click
       * *@param {number}y -  Y value of click
       */
      var traverseLayouts = function traverseLayouts(layouts, x, y, depth) {
        for (var i = 0; i < layouts.length; i++) {
          var layout = layouts[i];
          console.log("current view", layout.view);
          var bounds = layout.bounds;
          if (bounds) {
            if (x >= bounds.left && x <= bounds.right && y >= bounds.top && y <= bounds.bottom) {
              if (_this.result == null) {
                _this.result = {
                  depth: depth,
                  layout: layout
                };
              } else {
                if (_this.result.depth <= depth) {
                  _this.result = {
                    depth: depth,
                    layout: layout
                  };
                }
              }
              console.log(layout);
              // traverseLayouts(layout.views, x, y, depth + 1);
            }
            // return null;
          }

          traverseLayouts(layout.views, x, y, depth + 1);
          // return null;
        }
        // return null;
      };

      /**
       * Hides this button, Shows the Disable View Selection button and attach some event listeners
       *
       * At last, show a toast kind of message at the center of the screen
       */
      enableViewSelectionButton.onclick = function () {
        _this.isSelectionMode = true;
        if (Apxor.isFlutter()) {
          var helper = Apxor.getApxorFlutterHelper(); /*getApxorFlutterHelper:returns object*/
          helper.disableClick();
          var response = helper.dump(); /*dump:for feature extraction*/
          // console.log(response);
          var layout = response.r;
          _this.clickListener = function (e) {
            var x = e.clientX,
              y = e.clientY;
            console.log("x,y", x, y);
            var rect = disableViewSelectionButton.getBoundingClientRect();
            console.log("rect", rect);
            // if disable view selection is clicked then return
            if (x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom) {
              return;
            }
            traverseLayouts(layout.views, x, y, 0);
            var _this$result$layout = _this.result.layout,
              id = _this$result$layout.id,
              path = _this$result$layout.path,
              bounds = _this$result$layout.bounds;
            _this.result = null;
            if (id && id.length != 0) {
              navigator.clipboard.writeText(id);
            } else {
              navigator.clipboard.writeText(path);
            }
            showFeedbackAfterViewIdCopyForFlutter(bounds);
            //disabling the view seletion after showing the container
            disableViewSelectionHandler();
            _this._makeSSERequest("view", location.href, id + "___" + path);
          };
        } else {
          // Attach the mouseover and mouseout listeners
          window.addEventListener("mouseover", onMouseOver, true);
          window.addEventListener("mouseout", onMouseOut, true);
          _this.clickListener = function (e) {
            return handleDocumentOnClick(e, function (target) {
              // Send this information over to SSE server which will send this info to dashboard
              var cssSelector = _this.cssPath(target, true);
              var xPath = _this.xPath(target, true);
              //copying value to the clipboard
              navigator.clipboard.writeText(cssSelector + "___" + xPath);
              //creating container for indicating user to paste the code in dashboard
              showFeedbackAfterViewIdCopy();
              //disabling the view seletion after showing the container
              disableViewSelectionHandler();
              _this._makeSSERequest("view", location.href, cssSelector + "___" + xPath);
            });
          };
        }
        window.addEventListener("click", _this.clickListener, true);
        _this._hideToast(false);
        enableViewSelectionButton.style.display = "none";
        disableViewSelectionButton.style.display = "block";
      };
      var showFeedbackAfterViewIdCopy = function showFeedbackAfterViewIdCopy() {
        var enableViewSelectionBtn = document.querySelector("#apx-ev");
        enableViewSelectionBtn.disabled = true;
        var message = "ID Copied! Now go back to apxor dashboard and paste <br> the element ID";
        var uiElementPasteSVG = "\n        <svg width=\"447\" height=\"144\" viewBox=\"0 0 447 144\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n          <rect width=\"447\" height=\"144\" fill=\"white\"/>\n          <path d=\"M24.84 35V26.36H28.488C28.572 26.36 28.684 26.364 28.824 26.372C28.968 26.376 29.096 26.388 29.208 26.408C29.724 26.488 30.146 26.658 30.474 26.918C30.806 27.178 31.05 27.506 31.206 27.902C31.362 28.294 31.44 28.732 31.44 29.216C31.44 29.7 31.36 30.14 31.2 30.536C31.044 30.928 30.8 31.254 30.468 31.514C30.14 31.774 29.72 31.944 29.208 32.024C29.096 32.04 28.968 32.052 28.824 32.06C28.68 32.068 28.568 32.072 28.488 32.072H26.472V35H24.84ZM26.472 30.548H28.416C28.5 30.548 28.592 30.544 28.692 30.536C28.792 30.528 28.884 30.512 28.968 30.488C29.188 30.428 29.358 30.328 29.478 30.188C29.598 30.044 29.68 29.886 29.724 29.714C29.772 29.538 29.796 29.372 29.796 29.216C29.796 29.06 29.772 28.896 29.724 28.724C29.68 28.548 29.598 28.39 29.478 28.25C29.358 28.106 29.188 28.004 28.968 27.944C28.884 27.92 28.792 27.904 28.692 27.896C28.592 27.888 28.5 27.884 28.416 27.884H26.472V30.548ZM32.767 35L35.407 26.36H37.843L40.483 35H38.803L36.451 27.38H36.763L34.447 35H32.767ZM34.351 33.2V31.676H38.911V33.2H34.351ZM45.9081 35.18C45.2681 35.18 44.6901 35.068 44.1741 34.844C43.6621 34.616 43.2401 34.292 42.9081 33.872C42.5801 33.448 42.3721 32.944 42.2841 32.36L43.9881 32.108C44.1081 32.604 44.3561 32.986 44.7321 33.254C45.1081 33.522 45.5361 33.656 46.0161 33.656C46.2841 33.656 46.5441 33.614 46.7961 33.53C47.0481 33.446 47.2541 33.322 47.4141 33.158C47.5781 32.994 47.6601 32.792 47.6601 32.552C47.6601 32.464 47.6461 32.38 47.6181 32.3C47.5941 32.216 47.5521 32.138 47.4921 32.066C47.4321 31.994 47.3461 31.926 47.2341 31.862C47.1261 31.798 46.9881 31.74 46.8201 31.688L44.5761 31.028C44.4081 30.98 44.2121 30.912 43.9881 30.824C43.7681 30.736 43.5541 30.61 43.3461 30.446C43.1381 30.282 42.9641 30.066 42.8241 29.798C42.6881 29.526 42.6201 29.184 42.6201 28.772C42.6201 28.192 42.7661 27.71 43.0581 27.326C43.3501 26.942 43.7401 26.656 44.2281 26.468C44.7161 26.28 45.2561 26.188 45.8481 26.192C46.4441 26.2 46.9761 26.302 47.4441 26.498C47.9121 26.694 48.3041 26.98 48.6201 27.356C48.9361 27.728 49.1641 28.184 49.3041 28.724L47.5401 29.024C47.4761 28.744 47.3581 28.508 47.1861 28.316C47.0141 28.124 46.8081 27.978 46.5681 27.878C46.3321 27.778 46.0841 27.724 45.8241 27.716C45.5681 27.708 45.3261 27.744 45.0981 27.824C44.8741 27.9 44.6901 28.012 44.5461 28.16C44.4061 28.308 44.3361 28.484 44.3361 28.688C44.3361 28.876 44.3941 29.03 44.5101 29.15C44.6261 29.266 44.7721 29.36 44.9481 29.432C45.1241 29.504 45.3041 29.564 45.4881 29.612L46.9881 30.02C47.2121 30.08 47.4601 30.16 47.7321 30.26C48.0041 30.356 48.2641 30.492 48.5121 30.668C48.7641 30.84 48.9701 31.068 49.1301 31.352C49.2941 31.636 49.3761 31.996 49.3761 32.432C49.3761 32.896 49.2781 33.302 49.0821 33.65C48.8901 33.994 48.6301 34.28 48.3021 34.508C47.9741 34.732 47.6021 34.9 47.1861 35.012C46.7741 35.124 46.3481 35.18 45.9081 35.18ZM54.0188 35V27.884H51.2948V26.36H58.3748V27.884H55.6508V35H54.0188ZM60.6591 35V26.36H66.2991V27.884H62.2911V29.732H65.5791V31.256H62.2911V33.476H66.2991V35H60.6591ZM76.2955 35.18C75.5995 35.18 74.9875 35.04 74.4595 34.76C73.9315 34.476 73.5195 34.078 73.2235 33.566C72.9275 33.054 72.7795 32.452 72.7795 31.76V26.372L74.4355 26.36V31.748C74.4355 32.032 74.4835 32.29 74.5795 32.522C74.6755 32.754 74.8075 32.954 74.9755 33.122C75.1475 33.29 75.3455 33.42 75.5695 33.512C75.7975 33.6 76.0395 33.644 76.2955 33.644C76.5595 33.644 76.8035 33.598 77.0275 33.506C77.2555 33.414 77.4535 33.284 77.6215 33.116C77.7895 32.948 77.9195 32.748 78.0115 32.516C78.1075 32.284 78.1555 32.028 78.1555 31.748V26.36H79.8115V31.76C79.8115 32.452 79.6635 33.054 79.3675 33.566C79.0715 34.078 78.6595 34.476 78.1315 34.76C77.6035 35.04 76.9915 35.18 76.2955 35.18ZM82.9266 35V26.36H84.5586V35H82.9266ZM91.3997 35V26.36H97.0397V27.884H93.0317V29.732H96.3197V31.256H93.0317V33.476H97.0397V35H91.3997ZM99.9178 35V26.36H101.55V33.476H105.27V35H99.9178ZM107.61 35V26.36H113.25V27.884H109.242V29.732H112.53V31.256H109.242V33.476H113.25V35H107.61ZM116.008 35V26.36H117.472L120.328 32.096L123.184 26.36H124.648V35H123.124V29.84L120.616 35H120.04L117.532 29.84V35H116.008ZM127.652 35V26.36H133.292V27.884H129.284V29.732H132.572V31.256H129.284V33.476H133.292V35H127.652ZM136.05 35V26.36H137.706L141.462 32.12V26.36H143.118V35H141.462L137.706 29.24V35H136.05ZM148.117 35V27.884H145.393V26.36H152.473V27.884H149.749V35H148.117ZM158.236 35V26.36H159.868V35H158.236ZM162.987 35V26.36H165.783C165.851 26.36 165.991 26.362 166.203 26.366C166.415 26.37 166.619 26.384 166.815 26.408C167.511 26.492 168.101 26.734 168.585 27.134C169.069 27.534 169.437 28.042 169.689 28.658C169.941 29.274 170.067 29.948 170.067 30.68C170.067 31.412 169.941 32.086 169.689 32.702C169.437 33.318 169.069 33.826 168.585 34.226C168.101 34.626 167.511 34.868 166.815 34.952C166.619 34.976 166.415 34.99 166.203 34.994C165.991 34.998 165.851 35 165.783 35H162.987ZM164.643 33.464H165.783C165.891 33.464 166.037 33.462 166.221 33.458C166.405 33.45 166.571 33.432 166.719 33.404C167.095 33.328 167.401 33.152 167.637 32.876C167.877 32.6 168.053 32.268 168.165 31.88C168.281 31.492 168.339 31.092 168.339 30.68C168.339 30.248 168.279 29.838 168.159 29.45C168.043 29.062 167.865 28.734 167.625 28.466C167.385 28.198 167.083 28.028 166.719 27.956C166.571 27.924 166.405 27.906 166.221 27.902C166.037 27.898 165.891 27.896 165.783 27.896H164.643V33.464Z\" fill=\"#FF7F33\"/>\n          <rect x=\"24\" y=\"78\" width=\"399\" height=\"44\" rx=\"2\" fill=\"white\" stroke=\"#CCD4DA\"/>\n          <path d=\"M305.98 106V95.92H310.054C310.152 95.92 310.273 95.9247 310.418 95.934C310.563 95.9387 310.7 95.9527 310.831 95.976C311.391 96.0647 311.858 96.256 312.231 96.55C312.609 96.844 312.891 97.215 313.078 97.663C313.265 98.111 313.358 98.6057 313.358 99.147C313.358 99.693 313.265 100.19 313.078 100.638C312.891 101.086 312.609 101.457 312.231 101.751C311.858 102.045 311.391 102.236 310.831 102.325C310.7 102.344 310.56 102.358 310.411 102.367C310.266 102.376 310.147 102.381 310.054 102.381H307.443V106H305.98ZM307.443 100.995H309.998C310.091 100.995 310.194 100.99 310.306 100.981C310.423 100.972 310.532 100.955 310.635 100.932C310.934 100.862 311.174 100.734 311.356 100.547C311.538 100.356 311.669 100.136 311.748 99.889C311.827 99.6417 311.867 99.3943 311.867 99.147C311.867 98.8997 311.827 98.6547 311.748 98.412C311.669 98.1647 311.538 97.9477 311.356 97.761C311.174 97.5697 310.934 97.439 310.635 97.369C310.532 97.341 310.423 97.3223 310.306 97.313C310.194 97.3037 310.091 97.299 309.998 97.299H307.443V100.995ZM316.66 106.21C316.1 106.21 315.631 106.107 315.253 105.902C314.875 105.692 314.588 105.417 314.392 105.076C314.201 104.731 314.105 104.353 314.105 103.942C314.105 103.559 314.173 103.223 314.308 102.934C314.443 102.645 314.644 102.4 314.91 102.199C315.176 101.994 315.503 101.828 315.89 101.702C316.226 101.604 316.606 101.518 317.031 101.443C317.456 101.368 317.901 101.298 318.368 101.233C318.839 101.168 319.306 101.102 319.768 101.037L319.236 101.331C319.245 100.738 319.119 100.3 318.858 100.015C318.601 99.7257 318.158 99.581 317.528 99.581C317.131 99.581 316.767 99.6743 316.436 99.861C316.105 100.043 315.874 100.346 315.743 100.771L314.378 100.351C314.565 99.7023 314.919 99.1867 315.442 98.804C315.969 98.4213 316.669 98.23 317.542 98.23C318.219 98.23 318.807 98.3467 319.306 98.58C319.81 98.8087 320.179 99.1727 320.412 99.672C320.533 99.9193 320.608 100.181 320.636 100.456C320.664 100.731 320.678 101.028 320.678 101.345V106H319.383V104.271L319.635 104.495C319.322 105.074 318.923 105.505 318.438 105.79C317.957 106.07 317.365 106.21 316.66 106.21ZM316.919 105.013C317.334 105.013 317.691 104.941 317.99 104.796C318.289 104.647 318.529 104.458 318.711 104.229C318.893 104 319.012 103.762 319.068 103.515C319.147 103.291 319.192 103.039 319.201 102.759C319.215 102.479 319.222 102.255 319.222 102.087L319.698 102.262C319.236 102.332 318.816 102.395 318.438 102.451C318.06 102.507 317.717 102.563 317.409 102.619C317.106 102.67 316.835 102.733 316.597 102.808C316.396 102.878 316.217 102.962 316.058 103.06C315.904 103.158 315.78 103.277 315.687 103.417C315.598 103.557 315.554 103.727 315.554 103.928C315.554 104.124 315.603 104.306 315.701 104.474C315.799 104.637 315.948 104.768 316.149 104.866C316.35 104.964 316.606 105.013 316.919 105.013ZM325.387 106.203C324.467 106.203 323.718 106 323.14 105.594C322.561 105.188 322.206 104.616 322.076 103.879L323.574 103.648C323.667 104.04 323.882 104.35 324.218 104.579C324.558 104.803 324.981 104.915 325.485 104.915C325.942 104.915 326.299 104.822 326.556 104.635C326.817 104.448 326.948 104.192 326.948 103.865C326.948 103.674 326.901 103.52 326.808 103.403C326.719 103.282 326.53 103.167 326.241 103.06C325.951 102.953 325.51 102.82 324.918 102.661C324.269 102.493 323.753 102.313 323.371 102.122C322.993 101.926 322.722 101.7 322.559 101.443C322.4 101.182 322.321 100.867 322.321 100.498C322.321 100.041 322.442 99.6417 322.685 99.301C322.927 98.9603 323.268 98.6967 323.707 98.51C324.15 98.3233 324.668 98.23 325.261 98.23C325.839 98.23 326.355 98.321 326.808 98.503C327.26 98.685 327.627 98.944 327.907 99.28C328.187 99.6113 328.355 100.001 328.411 100.449L326.913 100.722C326.861 100.358 326.691 100.071 326.402 99.861C326.112 99.651 325.737 99.5367 325.275 99.518C324.831 99.4993 324.472 99.574 324.197 99.742C323.921 99.9053 323.784 100.132 323.784 100.421C323.784 100.589 323.835 100.731 323.938 100.848C324.045 100.965 324.25 101.077 324.554 101.184C324.857 101.291 325.305 101.42 325.898 101.569C326.532 101.732 327.036 101.914 327.41 102.115C327.783 102.311 328.049 102.547 328.208 102.822C328.371 103.093 328.453 103.422 328.453 103.809C328.453 104.556 328.18 105.141 327.634 105.566C327.092 105.991 326.343 106.203 325.387 106.203ZM334.327 106C333.851 106.093 333.385 106.133 332.927 106.119C332.47 106.105 332.062 106.016 331.702 105.853C331.343 105.69 331.072 105.433 330.89 105.083C330.727 104.77 330.638 104.453 330.624 104.131C330.615 103.804 330.61 103.436 330.61 103.025V96.34H332.08V102.955C332.08 103.258 332.083 103.522 332.087 103.746C332.097 103.97 332.146 104.159 332.234 104.313C332.402 104.602 332.668 104.768 333.032 104.81C333.401 104.847 333.833 104.831 334.327 104.761V106ZM329.161 99.616V98.44H334.327V99.616H329.161ZM338.933 106.21C338.181 106.21 337.521 106.047 336.952 105.72C336.387 105.389 335.946 104.929 335.629 104.341C335.316 103.748 335.16 103.062 335.16 102.283C335.16 101.457 335.314 100.741 335.622 100.134C335.934 99.5273 336.368 99.0583 336.924 98.727C337.479 98.3957 338.125 98.23 338.863 98.23C339.633 98.23 340.288 98.4097 340.83 98.769C341.371 99.1237 341.775 99.63 342.041 100.288C342.311 100.946 342.419 101.728 342.363 102.633H340.9V102.101C340.89 101.224 340.722 100.575 340.396 100.155C340.074 99.735 339.581 99.525 338.919 99.525C338.186 99.525 337.635 99.756 337.267 100.218C336.898 100.68 336.714 101.347 336.714 102.22C336.714 103.051 336.898 103.695 337.267 104.152C337.635 104.605 338.167 104.831 338.863 104.831C339.32 104.831 339.714 104.728 340.046 104.523C340.382 104.313 340.643 104.014 340.83 103.627L342.265 104.082C341.971 104.759 341.525 105.284 340.928 105.657C340.33 106.026 339.665 106.21 338.933 106.21ZM336.238 102.633V101.492H341.635V102.633H336.238ZM350.943 106.21C349.935 106.21 349.076 105.991 348.367 105.552C347.658 105.109 347.114 104.493 346.736 103.704C346.363 102.915 346.176 102.001 346.176 100.96C346.176 99.9193 346.363 99.0047 346.736 98.216C347.114 97.4273 347.658 96.8137 348.367 96.375C349.076 95.9317 349.935 95.71 350.943 95.71C352.105 95.71 353.066 96.004 353.827 96.592C354.592 97.18 355.124 97.971 355.423 98.965L353.939 99.364C353.743 98.6593 353.393 98.1063 352.889 97.705C352.39 97.3037 351.741 97.103 350.943 97.103C350.229 97.103 349.634 97.264 349.158 97.586C348.682 97.908 348.323 98.3583 348.08 98.937C347.842 99.5157 347.723 100.19 347.723 100.96C347.718 101.73 347.835 102.404 348.073 102.983C348.316 103.562 348.675 104.012 349.151 104.334C349.632 104.656 350.229 104.817 350.943 104.817C351.741 104.817 352.39 104.616 352.889 104.215C353.393 103.809 353.743 103.256 353.939 102.556L355.423 102.955C355.124 103.949 354.592 104.74 353.827 105.328C353.066 105.916 352.105 106.21 350.943 106.21ZM357.102 106V95.71H358.565V106H357.102ZM360.808 97.201V95.78H362.271V97.201H360.808ZM360.808 106V98.44H362.271V106H360.808ZM367.922 106.21C367.198 106.21 366.592 106.035 366.102 105.685C365.612 105.33 365.241 104.852 364.989 104.25C364.737 103.648 364.611 102.969 364.611 102.213C364.611 101.457 364.734 100.778 364.982 100.176C365.234 99.574 365.602 99.1003 366.088 98.755C366.578 98.405 367.18 98.23 367.894 98.23C368.603 98.23 369.214 98.405 369.728 98.755C370.246 99.1003 370.645 99.574 370.925 100.176C371.205 100.773 371.345 101.452 371.345 102.213C371.345 102.969 371.205 103.65 370.925 104.257C370.649 104.859 370.255 105.335 369.742 105.685C369.233 106.035 368.626 106.21 367.922 106.21ZM364.366 109.36V98.44H365.668V103.879H365.836V109.36H364.366ZM367.719 104.887C368.185 104.887 368.57 104.768 368.874 104.53C369.182 104.292 369.41 103.972 369.56 103.571C369.714 103.165 369.791 102.712 369.791 102.213C369.791 101.718 369.714 101.27 369.56 100.869C369.41 100.468 369.179 100.148 368.867 99.91C368.554 99.672 368.155 99.553 367.67 99.553C367.212 99.553 366.834 99.665 366.536 99.889C366.242 100.113 366.022 100.426 365.878 100.827C365.738 101.228 365.668 101.69 365.668 102.213C365.668 102.736 365.738 103.198 365.878 103.599C366.018 104 366.239 104.315 366.543 104.544C366.846 104.773 367.238 104.887 367.719 104.887ZM376.439 106.21C375.716 106.21 375.109 106.035 374.619 105.685C374.129 105.33 373.758 104.852 373.506 104.25C373.254 103.648 373.128 102.969 373.128 102.213C373.128 101.457 373.252 100.778 373.499 100.176C373.751 99.574 374.12 99.1003 374.605 98.755C375.095 98.405 375.697 98.23 376.411 98.23C377.12 98.23 377.732 98.405 378.245 98.755C378.763 99.1003 379.162 99.574 379.442 100.176C379.722 100.773 379.862 101.452 379.862 102.213C379.862 102.969 379.722 103.65 379.442 104.257C379.167 104.859 378.772 105.335 378.259 105.685C377.75 106.035 377.144 106.21 376.439 106.21ZM372.883 106V95.92H374.353V100.561H374.185V106H372.883ZM376.236 104.887C376.703 104.887 377.088 104.768 377.391 104.53C377.699 104.292 377.928 103.972 378.077 103.571C378.231 103.165 378.308 102.712 378.308 102.213C378.308 101.718 378.231 101.27 378.077 100.869C377.928 100.468 377.697 100.148 377.384 99.91C377.071 99.672 376.672 99.553 376.187 99.553C375.73 99.553 375.352 99.665 375.053 99.889C374.759 100.113 374.54 100.426 374.395 100.827C374.255 101.228 374.185 101.69 374.185 102.213C374.185 102.736 374.255 103.198 374.395 103.599C374.535 104 374.757 104.315 375.06 104.544C375.363 104.773 375.755 104.887 376.236 104.887ZM384.691 106.21C383.935 106.21 383.279 106.04 382.724 105.699C382.168 105.358 381.739 104.889 381.436 104.292C381.137 103.69 380.988 102.997 380.988 102.213C380.988 101.424 381.142 100.731 381.45 100.134C381.758 99.532 382.189 99.0653 382.745 98.734C383.3 98.398 383.949 98.23 384.691 98.23C385.447 98.23 386.102 98.4003 386.658 98.741C387.213 99.0817 387.642 99.5507 387.946 100.148C388.249 100.745 388.401 101.434 388.401 102.213C388.401 103.002 388.247 103.697 387.939 104.299C387.635 104.896 387.206 105.365 386.651 105.706C386.095 106.042 385.442 106.21 384.691 106.21ZM384.691 104.831C385.414 104.831 385.953 104.588 386.308 104.103C386.667 103.613 386.847 102.983 386.847 102.213C386.847 101.424 386.665 100.794 386.301 100.323C385.941 99.847 385.405 99.609 384.691 99.609C384.201 99.609 383.797 99.721 383.48 99.945C383.162 100.164 382.927 100.47 382.773 100.862C382.619 101.249 382.542 101.7 382.542 102.213C382.542 103.006 382.724 103.641 383.088 104.117C383.452 104.593 383.986 104.831 384.691 104.831ZM392.074 106.21C391.514 106.21 391.045 106.107 390.667 105.902C390.289 105.692 390.002 105.417 389.806 105.076C389.615 104.731 389.519 104.353 389.519 103.942C389.519 103.559 389.587 103.223 389.722 102.934C389.857 102.645 390.058 102.4 390.324 102.199C390.59 101.994 390.917 101.828 391.304 101.702C391.64 101.604 392.02 101.518 392.445 101.443C392.87 101.368 393.315 101.298 393.782 101.233C394.253 101.168 394.72 101.102 395.182 101.037L394.65 101.331C394.659 100.738 394.533 100.3 394.272 100.015C394.015 99.7257 393.572 99.581 392.942 99.581C392.545 99.581 392.181 99.6743 391.85 99.861C391.519 100.043 391.288 100.346 391.157 100.771L389.792 100.351C389.979 99.7023 390.333 99.1867 390.856 98.804C391.383 98.4213 392.083 98.23 392.956 98.23C393.633 98.23 394.221 98.3467 394.72 98.58C395.224 98.8087 395.593 99.1727 395.826 99.672C395.947 99.9193 396.022 100.181 396.05 100.456C396.078 100.731 396.092 101.028 396.092 101.345V106H394.797V104.271L395.049 104.495C394.736 105.074 394.337 105.505 393.852 105.79C393.371 106.07 392.779 106.21 392.074 106.21ZM392.333 105.013C392.748 105.013 393.105 104.941 393.404 104.796C393.703 104.647 393.943 104.458 394.125 104.229C394.307 104 394.426 103.762 394.482 103.515C394.561 103.291 394.606 103.039 394.615 102.759C394.629 102.479 394.636 102.255 394.636 102.087L395.112 102.262C394.65 102.332 394.23 102.395 393.852 102.451C393.474 102.507 393.131 102.563 392.823 102.619C392.52 102.67 392.249 102.733 392.011 102.808C391.81 102.878 391.631 102.962 391.472 103.06C391.318 103.158 391.194 103.277 391.101 103.417C391.012 103.557 390.968 103.727 390.968 103.928C390.968 104.124 391.017 104.306 391.115 104.474C391.213 104.637 391.362 104.768 391.563 104.866C391.764 104.964 392.02 105.013 392.333 105.013ZM397.91 106V98.44H399.212V100.274L399.03 100.036C399.123 99.7933 399.244 99.5717 399.394 99.371C399.543 99.1657 399.716 98.9977 399.912 98.867C400.103 98.727 400.315 98.6197 400.549 98.545C400.787 98.4657 401.029 98.419 401.277 98.405C401.524 98.3863 401.762 98.398 401.991 98.44V99.812C401.743 99.7467 401.468 99.728 401.165 99.756C400.866 99.784 400.591 99.8797 400.339 100.043C400.101 100.197 399.912 100.384 399.772 100.603C399.636 100.822 399.538 101.067 399.478 101.338C399.417 101.604 399.387 101.886 399.387 102.185V106H397.91ZM406.19 106.21C405.485 106.21 404.876 106.035 404.363 105.685C403.854 105.335 403.46 104.859 403.18 104.257C402.905 103.65 402.767 102.969 402.767 102.213C402.767 101.452 402.907 100.773 403.187 100.176C403.467 99.574 403.864 99.1003 404.377 98.755C404.895 98.405 405.509 98.23 406.218 98.23C406.932 98.23 407.532 98.405 408.017 98.755C408.507 99.1003 408.876 99.574 409.123 100.176C409.375 100.778 409.501 101.457 409.501 102.213C409.501 102.969 409.375 103.648 409.123 104.25C408.871 104.852 408.5 105.33 408.01 105.685C407.52 106.035 406.913 106.21 406.19 106.21ZM406.393 104.887C406.874 104.887 407.266 104.773 407.569 104.544C407.872 104.315 408.094 104 408.234 103.599C408.374 103.198 408.444 102.736 408.444 102.213C408.444 101.69 408.372 101.228 408.227 100.827C408.087 100.426 407.868 100.113 407.569 99.889C407.275 99.665 406.899 99.553 406.442 99.553C405.957 99.553 405.558 99.672 405.245 99.91C404.932 100.148 404.699 100.468 404.545 100.869C404.396 101.27 404.321 101.718 404.321 102.213C404.321 102.712 404.396 103.165 404.545 103.571C404.699 103.972 404.928 104.292 405.231 104.53C405.539 104.768 405.926 104.887 406.393 104.887ZM408.444 106V100.561H408.276V95.92H409.746V106H408.444Z\" fill=\"#FF7F33\"/>\n          <path d=\"M40.98 105V94.92H45.054C45.152 94.92 45.2733 94.9247 45.418 94.934C45.5627 94.9387 45.7003 94.9527 45.831 94.976C46.391 95.0647 46.8577 95.256 47.231 95.55C47.609 95.844 47.8913 96.215 48.078 96.663C48.2647 97.111 48.358 97.6057 48.358 98.147C48.358 98.693 48.2647 99.19 48.078 99.638C47.8913 100.086 47.609 100.457 47.231 100.751C46.8577 101.045 46.391 101.236 45.831 101.325C45.7003 101.344 45.5603 101.358 45.411 101.367C45.2663 101.376 45.1473 101.381 45.054 101.381H42.443V105H40.98ZM42.443 99.995H44.998C45.0913 99.995 45.194 99.9903 45.306 99.981C45.4227 99.9717 45.5323 99.9553 45.635 99.932C45.9337 99.862 46.174 99.7337 46.356 99.547C46.538 99.3557 46.6687 99.1363 46.748 98.889C46.8273 98.6417 46.867 98.3943 46.867 98.147C46.867 97.8997 46.8273 97.6547 46.748 97.412C46.6687 97.1647 46.538 96.9477 46.356 96.761C46.174 96.5697 45.9337 96.439 45.635 96.369C45.5323 96.341 45.4227 96.3223 45.306 96.313C45.194 96.3037 45.0913 96.299 44.998 96.299H42.443V99.995ZM51.7999 105.21C51.2399 105.21 50.7709 105.107 50.3929 104.902C50.0149 104.692 49.7279 104.417 49.5319 104.076C49.3406 103.731 49.2449 103.353 49.2449 102.942C49.2449 102.559 49.3126 102.223 49.4479 101.934C49.5833 101.645 49.7839 101.4 50.0499 101.199C50.3159 100.994 50.6426 100.828 51.0299 100.702C51.3659 100.604 51.7463 100.518 52.1709 100.443C52.5956 100.368 53.0413 100.298 53.5079 100.233C53.9793 100.168 54.4459 100.102 54.9079 100.037L54.3759 100.331C54.3853 99.7383 54.2593 99.2997 53.9979 99.015C53.7413 98.7257 53.2979 98.581 52.6679 98.581C52.2713 98.581 51.9073 98.6743 51.5759 98.861C51.2446 99.043 51.0136 99.3463 50.8829 99.771L49.5179 99.351C49.7046 98.7023 50.0593 98.1867 50.5819 97.804C51.1093 97.4213 51.8093 97.23 52.6819 97.23C53.3586 97.23 53.9466 97.3467 54.4459 97.58C54.9499 97.8087 55.3186 98.1727 55.5519 98.672C55.6733 98.9193 55.7479 99.1807 55.7759 99.456C55.8039 99.7313 55.8179 100.028 55.8179 100.345V105H54.5229V103.271L54.7749 103.495C54.4623 104.074 54.0633 104.505 53.5779 104.79C53.0973 105.07 52.5046 105.21 51.7999 105.21ZM52.0589 104.013C52.4743 104.013 52.8313 103.941 53.1299 103.796C53.4286 103.647 53.6689 103.458 53.8509 103.229C54.0329 103 54.1519 102.762 54.2079 102.515C54.2873 102.291 54.3316 102.039 54.3409 101.759C54.3549 101.479 54.3619 101.255 54.3619 101.087L54.8379 101.262C54.3759 101.332 53.9559 101.395 53.5779 101.451C53.1999 101.507 52.8569 101.563 52.5489 101.619C52.2456 101.67 51.9749 101.733 51.7369 101.808C51.5363 101.878 51.3566 101.962 51.1979 102.06C51.0439 102.158 50.9203 102.277 50.8269 102.417C50.7383 102.557 50.6939 102.727 50.6939 102.928C50.6939 103.124 50.7429 103.306 50.8409 103.474C50.9389 103.637 51.0883 103.768 51.2889 103.866C51.4896 103.964 51.7463 104.013 52.0589 104.013ZM60.6666 105.203C59.7473 105.203 58.9983 105 58.4196 104.594C57.841 104.188 57.4863 103.616 57.3556 102.879L58.8536 102.648C58.947 103.04 59.1616 103.35 59.4976 103.579C59.8383 103.803 60.2606 103.915 60.7646 103.915C61.222 103.915 61.579 103.822 61.8356 103.635C62.097 103.448 62.2276 103.192 62.2276 102.865C62.2276 102.674 62.181 102.52 62.0876 102.403C61.999 102.282 61.81 102.167 61.5206 102.06C61.2313 101.953 60.7903 101.82 60.1976 101.661C59.549 101.493 59.0333 101.313 58.6506 101.122C58.2726 100.926 58.002 100.7 57.8386 100.443C57.68 100.182 57.6006 99.8667 57.6006 99.498C57.6006 99.0407 57.722 98.6417 57.9646 98.301C58.2073 97.9603 58.548 97.6967 58.9866 97.51C59.43 97.3233 59.948 97.23 60.5406 97.23C61.1193 97.23 61.635 97.321 62.0876 97.503C62.5403 97.685 62.9066 97.944 63.1866 98.28C63.4666 98.6113 63.6346 99.001 63.6906 99.449L62.1926 99.722C62.1413 99.358 61.971 99.071 61.6816 98.861C61.3923 98.651 61.0166 98.5367 60.5546 98.518C60.1113 98.4993 59.752 98.574 59.4766 98.742C59.2013 98.9053 59.0636 99.1317 59.0636 99.421C59.0636 99.589 59.115 99.7313 59.2176 99.848C59.325 99.9647 59.5303 100.077 59.8336 100.184C60.137 100.291 60.585 100.42 61.1776 100.569C61.8123 100.732 62.3163 100.914 62.6896 101.115C63.063 101.311 63.329 101.547 63.4876 101.822C63.651 102.093 63.7326 102.422 63.7326 102.809C63.7326 103.556 63.4596 104.141 62.9136 104.566C62.3723 104.991 61.6233 105.203 60.6666 105.203ZM69.7475 105C69.2715 105.093 68.8048 105.133 68.3475 105.119C67.8902 105.105 67.4818 105.016 67.1225 104.853C66.7632 104.69 66.4925 104.433 66.3105 104.083C66.1472 103.77 66.0585 103.453 66.0445 103.131C66.0352 102.804 66.0305 102.436 66.0305 102.025V95.34H67.5005V101.955C67.5005 102.258 67.5028 102.522 67.5075 102.746C67.5168 102.97 67.5658 103.159 67.6545 103.313C67.8225 103.602 68.0885 103.768 68.4525 103.81C68.8212 103.847 69.2528 103.831 69.7475 103.761V105ZM64.5815 98.616V97.44H69.7475V98.616H64.5815ZM74.4926 105.21C73.7413 105.21 73.0809 105.047 72.5116 104.72C71.9469 104.389 71.5059 103.929 71.1886 103.341C70.8759 102.748 70.7196 102.062 70.7196 101.283C70.7196 100.457 70.8736 99.7407 71.1816 99.134C71.4943 98.5273 71.9283 98.0583 72.4836 97.727C73.0389 97.3957 73.6853 97.23 74.4226 97.23C75.1926 97.23 75.8483 97.4097 76.3896 97.769C76.9309 98.1237 77.3346 98.63 77.6006 99.288C77.8713 99.946 77.9786 100.728 77.9226 101.633H76.4596V101.101C76.4503 100.224 76.2823 99.575 75.9556 99.155C75.6336 98.735 75.1413 98.525 74.4786 98.525C73.7459 98.525 73.1953 98.756 72.8266 99.218C72.4579 99.68 72.2736 100.347 72.2736 101.22C72.2736 102.051 72.4579 102.695 72.8266 103.152C73.1953 103.605 73.7273 103.831 74.4226 103.831C74.8799 103.831 75.2743 103.728 75.6056 103.523C75.9416 103.313 76.2029 103.014 76.3896 102.627L77.8246 103.082C77.5306 103.759 77.0849 104.284 76.4876 104.657C75.8903 105.026 75.2253 105.21 74.4926 105.21ZM71.7976 101.633V100.492H77.1946V101.633H71.7976ZM86.7829 105.21C85.7749 105.21 84.9162 104.991 84.2069 104.552C83.4975 104.109 82.9539 103.493 82.5759 102.704C82.2025 101.915 82.0159 101.001 82.0159 99.96C82.0159 98.9193 82.2025 98.0047 82.5759 97.216C82.9539 96.4273 83.4975 95.8137 84.2069 95.375C84.9162 94.9317 85.7749 94.71 86.7829 94.71C87.9449 94.71 88.9062 95.004 89.6669 95.592C90.4322 96.18 90.9642 96.971 91.2629 97.965L89.7789 98.364C89.5829 97.6593 89.2329 97.1063 88.7289 96.705C88.2295 96.3037 87.5809 96.103 86.7829 96.103C86.0689 96.103 85.4739 96.264 84.9979 96.586C84.5219 96.908 84.1625 97.3583 83.9199 97.937C83.6819 98.5157 83.5629 99.19 83.5629 99.96C83.5582 100.73 83.6749 101.404 83.9129 101.983C84.1555 102.562 84.5149 103.012 84.9909 103.334C85.4715 103.656 86.0689 103.817 86.7829 103.817C87.5809 103.817 88.2295 103.616 88.7289 103.215C89.2329 102.809 89.5829 102.256 89.7789 101.556L91.2629 101.955C90.9642 102.949 90.4322 103.74 89.6669 104.328C88.9062 104.916 87.9449 105.21 86.7829 105.21ZM97.0202 105.21C96.2969 105.21 95.6436 105.086 95.0602 104.839C94.4816 104.587 94.0032 104.23 93.6252 103.768C93.2519 103.301 93.0092 102.748 92.8972 102.109L94.4232 101.878C94.5772 102.494 94.8992 102.975 95.3892 103.32C95.8792 103.661 96.4509 103.831 97.1042 103.831C97.5102 103.831 97.8836 103.768 98.2242 103.642C98.5649 103.511 98.8379 103.327 99.0432 103.089C99.2532 102.846 99.3582 102.557 99.3582 102.221C99.3582 102.039 99.3256 101.878 99.2602 101.738C99.1996 101.598 99.1132 101.477 99.0012 101.374C98.8939 101.267 98.7609 101.176 98.6023 101.101C98.4482 101.022 98.2779 100.954 98.0912 100.898L95.5082 100.135C95.2562 100.06 94.9996 99.9647 94.7382 99.848C94.4769 99.7267 94.2366 99.5703 94.0172 99.379C93.8026 99.183 93.6276 98.9427 93.4922 98.658C93.3569 98.3687 93.2892 98.0187 93.2892 97.608C93.2892 96.9873 93.4479 96.4623 93.7652 96.033C94.0872 95.599 94.5212 95.2723 95.0672 95.053C95.6132 94.829 96.2246 94.717 96.9012 94.717C97.5826 94.7263 98.1916 94.8477 98.7282 95.081C99.2696 95.3143 99.7176 95.6503 100.072 96.089C100.432 96.523 100.679 97.0503 100.814 97.671L99.2462 97.937C99.1762 97.559 99.0269 97.2347 98.7983 96.964C98.5696 96.6887 98.2896 96.4787 97.9582 96.334C97.6269 96.1847 97.2676 96.1077 96.8802 96.103C96.5069 96.0937 96.1639 96.1497 95.8512 96.271C95.5432 96.3923 95.2959 96.5627 95.1092 96.782C94.9272 97.0013 94.8362 97.2533 94.8362 97.538C94.8362 97.818 94.9179 98.0443 95.0812 98.217C95.2446 98.3897 95.4452 98.5273 95.6832 98.63C95.9259 98.728 96.1662 98.8097 96.4042 98.875L98.2662 99.4C98.4996 99.4653 98.7632 99.554 99.0573 99.666C99.3559 99.7733 99.6429 99.925 99.9183 100.121C100.198 100.317 100.429 100.578 100.611 100.905C100.793 101.227 100.884 101.633 100.884 102.123C100.884 102.632 100.782 103.08 100.576 103.467C100.371 103.85 100.089 104.172 99.7292 104.433C99.3746 104.69 98.9639 104.883 98.4972 105.014C98.0306 105.145 97.5382 105.21 97.0202 105.21ZM106.375 105.21C105.652 105.21 104.998 105.086 104.415 104.839C103.836 104.587 103.358 104.23 102.98 103.768C102.607 103.301 102.364 102.748 102.252 102.109L103.778 101.878C103.932 102.494 104.254 102.975 104.744 103.32C105.234 103.661 105.806 103.831 106.459 103.831C106.865 103.831 107.238 103.768 107.579 103.642C107.92 103.511 108.193 103.327 108.398 103.089C108.608 102.846 108.713 102.557 108.713 102.221C108.713 102.039 108.68 101.878 108.615 101.738C108.554 101.598 108.468 101.477 108.356 101.374C108.249 101.267 108.116 101.176 107.957 101.101C107.803 101.022 107.633 100.954 107.446 100.898L104.863 100.135C104.611 100.06 104.354 99.9647 104.093 99.848C103.832 99.7267 103.591 99.5703 103.372 99.379C103.157 99.183 102.982 98.9427 102.847 98.658C102.712 98.3687 102.644 98.0187 102.644 97.608C102.644 96.9873 102.803 96.4623 103.12 96.033C103.442 95.599 103.876 95.2723 104.422 95.053C104.968 94.829 105.579 94.717 106.256 94.717C106.937 94.7263 107.546 94.8477 108.083 95.081C108.624 95.3143 109.072 95.6503 109.427 96.089C109.786 96.523 110.034 97.0503 110.169 97.671L108.601 97.937C108.531 97.559 108.382 97.2347 108.153 96.964C107.924 96.6887 107.644 96.4787 107.313 96.334C106.982 96.1847 106.622 96.1077 106.235 96.103C105.862 96.0937 105.519 96.1497 105.206 96.271C104.898 96.3923 104.651 96.5627 104.464 96.782C104.282 97.0013 104.191 97.2533 104.191 97.538C104.191 97.818 104.273 98.0443 104.436 98.217C104.599 98.3897 104.8 98.5273 105.038 98.63C105.281 98.728 105.521 98.8097 105.759 98.875L107.621 99.4C107.854 99.4653 108.118 99.554 108.412 99.666C108.711 99.7733 108.998 99.925 109.273 100.121C109.553 100.317 109.784 100.578 109.966 100.905C110.148 101.227 110.239 101.633 110.239 102.123C110.239 102.632 110.136 103.08 109.931 103.467C109.726 103.85 109.443 104.172 109.084 104.433C108.729 104.69 108.319 104.883 107.852 105.014C107.385 105.145 106.893 105.21 106.375 105.21ZM114.954 105V94.92H116.417V105H114.954ZM118.659 105V94.92H121.816C121.909 94.92 122.082 94.9223 122.334 94.927C122.59 94.9317 122.835 94.9503 123.069 94.983C123.857 95.081 124.52 95.3633 125.057 95.83C125.598 96.2967 126.006 96.8893 126.282 97.608C126.557 98.322 126.695 99.106 126.695 99.96C126.695 100.819 126.557 101.607 126.282 102.326C126.006 103.04 125.598 103.63 125.057 104.097C124.52 104.559 123.857 104.839 123.069 104.937C122.835 104.97 122.59 104.988 122.334 104.993C122.082 104.998 121.909 105 121.816 105H118.659ZM120.157 103.607H121.816C121.974 103.607 122.163 103.602 122.383 103.593C122.602 103.584 122.796 103.565 122.964 103.537C123.477 103.439 123.892 103.217 124.21 102.872C124.532 102.522 124.767 102.093 124.917 101.584C125.066 101.075 125.141 100.534 125.141 99.96C125.141 99.3673 125.064 98.819 124.91 98.315C124.756 97.8063 124.518 97.3817 124.196 97.041C123.878 96.6957 123.468 96.4763 122.964 96.383C122.796 96.3503 122.6 96.3317 122.376 96.327C122.156 96.3177 121.97 96.313 121.816 96.313H120.157V103.607Z\" fill=\"#B3BEC6\"/>\n          <path d=\"M34 48C28.4903 48 24 52.4903 24 58C24 63.5097 28.4903 68 34 68C39.5097 68 44 63.5097 44 58C44 52.4903 39.5097 48 34 48ZM34 67.0291C29.0243 67.0291 24.9709 62.9757 24.9709 58C24.9709 53.0243 29.0243 48.9709 34 48.9709C38.9757 48.9709 43.0291 53.0243 43.0291 58C43.0291 62.9757 38.9757 67.0291 34 67.0291Z\" fill=\"#FF7F33\"/>\n          <path d=\"M33.9985 64.0907C37.3631 64.0907 40.0907 61.3631 40.0907 57.9985C40.0907 54.6338 37.3631 51.9062 33.9985 51.9062C30.6338 51.9062 27.9062 54.6338 27.9062 57.9985C27.9062 61.3631 30.6338 64.0907 33.9985 64.0907Z\" fill=\"#FF7F33\"/>\n          <path d=\"M59.5575 64.225C58.4775 64.225 57.5575 63.99 56.7975 63.52C56.0375 63.045 55.455 62.385 55.05 61.54C54.65 60.695 54.45 59.715 54.45 58.6C54.45 57.485 54.65 56.505 55.05 55.66C55.455 54.815 56.0375 54.1575 56.7975 53.6875C57.5575 53.2125 58.4775 52.975 59.5575 52.975C60.8025 52.975 61.8325 53.29 62.6475 53.92C63.4675 54.55 64.0375 55.3975 64.3575 56.4625L62.7675 56.89C62.5575 56.135 62.1825 55.5425 61.6425 55.1125C61.1075 54.6825 60.4125 54.4675 59.5575 54.4675C58.7925 54.4675 58.155 54.64 57.645 54.985C57.135 55.33 56.75 55.8125 56.49 56.4325C56.235 57.0525 56.1075 57.775 56.1075 58.6C56.1025 59.425 56.2275 60.1475 56.4825 60.7675C56.7425 61.3875 57.1275 61.87 57.6375 62.215C58.1525 62.56 58.7925 62.7325 59.5575 62.7325C60.4125 62.7325 61.1075 62.5175 61.6425 62.0875C62.1825 61.6525 62.5575 61.06 62.7675 60.31L64.3575 60.7375C64.0375 61.8025 63.4675 62.65 62.6475 63.28C61.8325 63.91 60.8025 64.225 59.5575 64.225ZM70.3761 64.225C69.6011 64.225 68.9011 64.0925 68.2761 63.8275C67.6561 63.5575 67.1436 63.175 66.7386 62.68C66.3386 62.18 66.0786 61.5875 65.9586 60.9025L67.5936 60.655C67.7586 61.315 68.1036 61.83 68.6286 62.2C69.1536 62.565 69.7661 62.7475 70.4661 62.7475C70.9011 62.7475 71.3011 62.68 71.6661 62.545C72.0311 62.405 72.3236 62.2075 72.5436 61.9525C72.7686 61.6925 72.8811 61.3825 72.8811 61.0225C72.8811 60.8275 72.8461 60.655 72.7761 60.505C72.7111 60.355 72.6186 60.225 72.4986 60.115C72.3836 60 72.2411 59.9025 72.0711 59.8225C71.9061 59.7375 71.7236 59.665 71.5236 59.605L68.7561 58.7875C68.4861 58.7075 68.2111 58.605 67.9311 58.48C67.6511 58.35 67.3936 58.1825 67.1586 57.9775C66.9286 57.7675 66.7411 57.51 66.5961 57.205C66.4511 56.895 66.3786 56.52 66.3786 56.08C66.3786 55.415 66.5486 54.8525 66.8886 54.3925C67.2336 53.9275 67.6986 53.5775 68.2836 53.3425C68.8686 53.1025 69.5236 52.9825 70.2486 52.9825C70.9786 52.9925 71.6311 53.1225 72.2061 53.3725C72.7861 53.6225 73.2661 53.9825 73.6461 54.4525C74.0311 54.9175 74.2961 55.4825 74.4411 56.1475L72.7611 56.4325C72.6861 56.0275 72.5261 55.68 72.2811 55.39C72.0361 55.095 71.7361 54.87 71.3811 54.715C71.0261 54.555 70.6411 54.4725 70.2261 54.4675C69.8261 54.4575 69.4586 54.5175 69.1236 54.6475C68.7936 54.7775 68.5286 54.96 68.3286 55.195C68.1336 55.43 68.0361 55.7 68.0361 56.005C68.0361 56.305 68.1236 56.5475 68.2986 56.7325C68.4736 56.9175 68.6886 57.065 68.9436 57.175C69.2036 57.28 69.4611 57.3675 69.7161 57.4375L71.7111 58C71.9611 58.07 72.2436 58.165 72.5586 58.285C72.8786 58.4 73.1861 58.5625 73.4811 58.7725C73.7811 58.9825 74.0286 59.2625 74.2236 59.6125C74.4186 59.9575 74.5161 60.3925 74.5161 60.9175C74.5161 61.4625 74.4061 61.9425 74.1861 62.3575C73.9661 62.7675 73.6636 63.1125 73.2786 63.3925C72.8986 63.6675 72.4586 63.875 71.9586 64.015C71.4586 64.155 70.9311 64.225 70.3761 64.225ZM80.2492 64.225C79.4742 64.225 78.7742 64.0925 78.1492 63.8275C77.5292 63.5575 77.0167 63.175 76.6117 62.68C76.2117 62.18 75.9517 61.5875 75.8317 60.9025L77.4667 60.655C77.6317 61.315 77.9767 61.83 78.5017 62.2C79.0267 62.565 79.6392 62.7475 80.3392 62.7475C80.7742 62.7475 81.1742 62.68 81.5392 62.545C81.9042 62.405 82.1967 62.2075 82.4167 61.9525C82.6417 61.6925 82.7542 61.3825 82.7542 61.0225C82.7542 60.8275 82.7192 60.655 82.6492 60.505C82.5842 60.355 82.4917 60.225 82.3717 60.115C82.2567 60 82.1142 59.9025 81.9442 59.8225C81.7792 59.7375 81.5967 59.665 81.3967 59.605L78.6292 58.7875C78.3592 58.7075 78.0842 58.605 77.8042 58.48C77.5242 58.35 77.2667 58.1825 77.0317 57.9775C76.8017 57.7675 76.6142 57.51 76.4692 57.205C76.3242 56.895 76.2517 56.52 76.2517 56.08C76.2517 55.415 76.4217 54.8525 76.7617 54.3925C77.1067 53.9275 77.5717 53.5775 78.1567 53.3425C78.7417 53.1025 79.3967 52.9825 80.1217 52.9825C80.8517 52.9925 81.5042 53.1225 82.0792 53.3725C82.6592 53.6225 83.1392 53.9825 83.5192 54.4525C83.9042 54.9175 84.1692 55.4825 84.3142 56.1475L82.6342 56.4325C82.5592 56.0275 82.3992 55.68 82.1542 55.39C81.9092 55.095 81.6092 54.87 81.2542 54.715C80.8992 54.555 80.5142 54.4725 80.0992 54.4675C79.6992 54.4575 79.3317 54.5175 78.9967 54.6475C78.6667 54.7775 78.4017 54.96 78.2017 55.195C78.0067 55.43 77.9092 55.7 77.9092 56.005C77.9092 56.305 77.9967 56.5475 78.1717 56.7325C78.3467 56.9175 78.5617 57.065 78.8167 57.175C79.0767 57.28 79.3342 57.3675 79.5892 57.4375L81.5842 58C81.8342 58.07 82.1167 58.165 82.4317 58.285C82.7517 58.4 83.0592 58.5625 83.3542 58.7725C83.6542 58.9825 83.9017 59.2625 84.0967 59.6125C84.2917 59.9575 84.3892 60.3925 84.3892 60.9175C84.3892 61.4625 84.2792 61.9425 84.0592 62.3575C83.8392 62.7675 83.5367 63.1125 83.1517 63.3925C82.7717 63.6675 82.3317 63.875 81.8317 64.015C81.3317 64.155 80.8042 64.225 80.2492 64.225Z\" fill=\"#002845\"/>\n          <path opacity=\"0.3\" d=\"M125 48C119.49 48 115 52.4903 115 58C115 63.5097 119.49 68 125 68C130.51 68 135 63.5097 135 58C135 52.4903 130.51 48 125 48ZM125 67.0291C120.024 67.0291 115.971 62.9757 115.971 58C115.971 53.0243 120.024 48.9709 125 48.9709C129.976 48.9709 134.029 53.0243 134.029 58C134.029 62.9757 129.976 67.0291 125 67.0291Z\" fill=\"#002845\"/>\n          <path d=\"M145.15 64L148.833 58.5325L145.247 53.2H147.168L149.8 57.205L152.418 53.2H154.345L150.76 58.5325L154.435 64H152.515L149.8 59.8675L147.078 64H145.15ZM155.63 64V53.2H159.995C160.1 53.2 160.23 53.205 160.385 53.215C160.54 53.22 160.688 53.235 160.828 53.26C161.428 53.355 161.928 53.56 162.328 53.875C162.733 54.19 163.035 54.5875 163.235 55.0675C163.435 55.5475 163.535 56.0775 163.535 56.6575C163.535 57.2425 163.435 57.775 163.235 58.255C163.035 58.735 162.733 59.1325 162.328 59.4475C161.928 59.7625 161.428 59.9675 160.828 60.0625C160.688 60.0825 160.538 60.0975 160.378 60.1075C160.223 60.1175 160.095 60.1225 159.995 60.1225H157.198V64H155.63ZM157.198 58.6375H159.935C160.035 58.6375 160.145 58.6325 160.265 58.6225C160.39 58.6125 160.508 58.595 160.618 58.57C160.938 58.495 161.195 58.3575 161.39 58.1575C161.585 57.9525 161.725 57.7175 161.81 57.4525C161.895 57.1875 161.938 56.9225 161.938 56.6575C161.938 56.3925 161.895 56.13 161.81 55.87C161.725 55.605 161.585 55.3725 161.39 55.1725C161.195 54.9675 160.938 54.8275 160.618 54.7525C160.508 54.7225 160.39 54.7025 160.265 54.6925C160.145 54.6825 160.035 54.6775 159.935 54.6775H157.198V58.6375ZM167.073 64.225C166.473 64.225 165.97 64.115 165.565 63.895C165.16 63.67 164.853 63.375 164.643 63.01C164.438 62.64 164.335 62.235 164.335 61.795C164.335 61.385 164.408 61.025 164.553 60.715C164.698 60.405 164.913 60.1425 165.198 59.9275C165.483 59.7075 165.833 59.53 166.248 59.395C166.608 59.29 167.015 59.1975 167.47 59.1175C167.925 59.0375 168.403 58.9625 168.903 58.8925C169.408 58.8225 169.908 58.7525 170.403 58.6825L169.833 58.9975C169.843 58.3625 169.708 57.8925 169.428 57.5875C169.153 57.2775 168.678 57.1225 168.003 57.1225C167.578 57.1225 167.188 57.2225 166.833 57.4225C166.478 57.6175 166.23 57.9425 166.09 58.3975L164.628 57.9475C164.828 57.2525 165.208 56.7 165.768 56.29C166.333 55.88 167.083 55.675 168.018 55.675C168.743 55.675 169.373 55.8 169.908 56.05C170.448 56.295 170.843 56.685 171.093 57.22C171.223 57.485 171.303 57.765 171.333 58.06C171.363 58.355 171.378 58.6725 171.378 59.0125V64H169.99V62.1475L170.26 62.3875C169.925 63.0075 169.498 63.47 168.978 63.775C168.463 64.075 167.828 64.225 167.073 64.225ZM167.35 62.9425C167.795 62.9425 168.178 62.865 168.498 62.71C168.818 62.55 169.075 62.3475 169.27 62.1025C169.465 61.8575 169.593 61.6025 169.653 61.3375C169.738 61.0975 169.785 60.8275 169.795 60.5275C169.81 60.2275 169.818 59.9875 169.818 59.8075L170.328 59.995C169.833 60.07 169.383 60.1375 168.978 60.1975C168.573 60.2575 168.205 60.3175 167.875 60.3775C167.55 60.4325 167.26 60.5 167.005 60.58C166.79 60.655 166.598 60.745 166.428 60.85C166.263 60.955 166.13 61.0825 166.03 61.2325C165.935 61.3825 165.888 61.565 165.888 61.78C165.888 61.99 165.94 62.185 166.045 62.365C166.15 62.54 166.31 62.68 166.525 62.785C166.74 62.89 167.015 62.9425 167.35 62.9425ZM177.96 64C177.45 64.1 176.95 64.1425 176.46 64.1275C175.97 64.1125 175.533 64.0175 175.148 63.8425C174.763 63.6675 174.473 63.3925 174.278 63.0175C174.103 62.6825 174.008 62.3425 173.993 61.9975C173.983 61.6475 173.978 61.2525 173.978 60.8125V53.65H175.553V60.7375C175.553 61.0625 175.555 61.345 175.56 61.585C175.57 61.825 175.623 62.0275 175.718 62.1925C175.898 62.5025 176.183 62.68 176.573 62.725C176.968 62.765 177.43 62.7475 177.96 62.6725V64ZM172.425 57.16V55.9H177.96V57.16H172.425ZM185.353 64V60.0175C185.353 59.7025 185.326 59.38 185.271 59.05C185.221 58.715 185.121 58.405 184.971 58.12C184.826 57.835 184.618 57.605 184.348 57.43C184.083 57.255 183.736 57.1675 183.306 57.1675C183.026 57.1675 182.761 57.215 182.511 57.31C182.261 57.4 182.041 57.5475 181.851 57.7525C181.666 57.9575 181.518 58.2275 181.408 58.5625C181.303 58.8975 181.251 59.305 181.251 59.785L180.276 59.4175C180.276 58.6825 180.413 58.035 180.688 57.475C180.963 56.91 181.358 56.47 181.873 56.155C182.388 55.84 183.011 55.6825 183.741 55.6825C184.301 55.6825 184.771 55.7725 185.151 55.9525C185.531 56.1325 185.838 56.37 186.073 56.665C186.313 56.955 186.496 57.2725 186.621 57.6175C186.746 57.9625 186.831 58.3 186.876 58.63C186.921 58.96 186.943 59.25 186.943 59.5V64H185.353ZM179.661 64V53.2H181.063V59.0275H181.251V64H179.661Z\" fill=\"#002845\"/>\n          <path d=\"M208 99L242.569 96.7705L223.354 67.9475L208 99ZM232.129 86.5192L287.664 49.4962L284.336 44.5039L228.801 81.5269L232.129 86.5192Z\" fill=\"#00BDE1\"/>\n        </svg>\n      ";
        if (_this._type !== "Desktop") {
          message = "Element selected! Now go back to the apxor dashboard to proceed";
          uiElementPasteSVG = "";
        }
        var feedbackModal = "\n        <style> \n          .apx-container{\n            padding:20px;\n          }\n        </style>\n        <div id=\"apx-container\" class=\"apx-container\">\n              <div id=\"close-button\" style=\"position:fixed;top:20px;right:10px;\"><svg width=\"18\" height=\"18\" viewBox=\"0 0 18 18\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n                <path opacity=\"0.5\" d=\"M11.0962 9.07071L17.8586 15.8331L15.8331 17.8586L9.0707 11.0962L8.99999 11.0255L8.92928 11.0962L2.16693 17.8586L0.141421 15.8331L6.90379 9.07071L6.9745 9L6.90379 8.92929L0.141421 2.16694L2.16693 0.141422L8.92928 6.9038L8.99999 6.97451L9.0707 6.9038L15.8331 0.141422L17.8586 2.16694L11.0962 8.92929L11.0255 9L11.0962 9.07071Z\" fill=\"white\" stroke=\"#002845\" stroke-width=\"0.2\"/>\n                </svg>\n              </div>\n              <div style=\"font-family: 'Manrope';font-style: normal;font-weight: 600;font-size: 16px;line-height: 22px;\n              color: #FFFFFF;\">".concat(message, "</div>\n              ").concat(uiElementPasteSVG, "\n        </div>\n      ");
        var feedbackParentDiv = document.createElement("div");
        feedbackParentDiv.style = "\n        z-index:99999999;\n        background:#002845;\n        position:fixed;\n        top:50%;\n        left:50%;\n        transform:translate(-50%, -50%);\n      ";
        feedbackParentDiv.innerHTML = feedbackModal;
        document.body.appendChild(feedbackParentDiv);
        var closeButton = document.getElementById("close-button");
        closeButton.addEventListener("click", function () {
          var conatiner = document.getElementById("apx-container");
          conatiner.remove();
          enableViewSelectionBtn.disabled = false;
        });
      };

      /**
       * @function showFeedbackAfterViewIdCopyForFlutter
       * @description  creating container for indicating user to paste the code in dashboard, and selected element is highlighted
       * @params(object) bounds of selected element
       **/
      var showFeedbackAfterViewIdCopyForFlutter = function showFeedbackAfterViewIdCopyForFlutter(bounds) {
        var divELement = document.createElement("div");
        var width = bounds.right - bounds.left;
        var height = bounds.bottom - bounds.top;
        divELement.style = "\n        position:absolute;\n        top:".concat(bounds.top, "px;\n        left:").concat(bounds.left, "px;\n        width:").concat(width, "px;\n        height:").concat(height, "px;\n        z-index:99999;outline: 2px solid red;cursor:default;\n        ");
        document.body.appendChild(divELement);
        var enableViewSelectionBtn = document.querySelector("#apx-ev");
        enableViewSelectionBtn.disabled = true;
        var message = "ID Copied! Now go back to apxor dashboard and paste <br> the element ID";
        var uiElementPasteSVG = "\n        <svg width=\"447\" height=\"144\" viewBox=\"0 0 447 144\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n          <rect width=\"447\" height=\"144\" fill=\"white\"/>\n          <path d=\"M24.84 35V26.36H28.488C28.572 26.36 28.684 26.364 28.824 26.372C28.968 26.376 29.096 26.388 29.208 26.408C29.724 26.488 30.146 26.658 30.474 26.918C30.806 27.178 31.05 27.506 31.206 27.902C31.362 28.294 31.44 28.732 31.44 29.216C31.44 29.7 31.36 30.14 31.2 30.536C31.044 30.928 30.8 31.254 30.468 31.514C30.14 31.774 29.72 31.944 29.208 32.024C29.096 32.04 28.968 32.052 28.824 32.06C28.68 32.068 28.568 32.072 28.488 32.072H26.472V35H24.84ZM26.472 30.548H28.416C28.5 30.548 28.592 30.544 28.692 30.536C28.792 30.528 28.884 30.512 28.968 30.488C29.188 30.428 29.358 30.328 29.478 30.188C29.598 30.044 29.68 29.886 29.724 29.714C29.772 29.538 29.796 29.372 29.796 29.216C29.796 29.06 29.772 28.896 29.724 28.724C29.68 28.548 29.598 28.39 29.478 28.25C29.358 28.106 29.188 28.004 28.968 27.944C28.884 27.92 28.792 27.904 28.692 27.896C28.592 27.888 28.5 27.884 28.416 27.884H26.472V30.548ZM32.767 35L35.407 26.36H37.843L40.483 35H38.803L36.451 27.38H36.763L34.447 35H32.767ZM34.351 33.2V31.676H38.911V33.2H34.351ZM45.9081 35.18C45.2681 35.18 44.6901 35.068 44.1741 34.844C43.6621 34.616 43.2401 34.292 42.9081 33.872C42.5801 33.448 42.3721 32.944 42.2841 32.36L43.9881 32.108C44.1081 32.604 44.3561 32.986 44.7321 33.254C45.1081 33.522 45.5361 33.656 46.0161 33.656C46.2841 33.656 46.5441 33.614 46.7961 33.53C47.0481 33.446 47.2541 33.322 47.4141 33.158C47.5781 32.994 47.6601 32.792 47.6601 32.552C47.6601 32.464 47.6461 32.38 47.6181 32.3C47.5941 32.216 47.5521 32.138 47.4921 32.066C47.4321 31.994 47.3461 31.926 47.2341 31.862C47.1261 31.798 46.9881 31.74 46.8201 31.688L44.5761 31.028C44.4081 30.98 44.2121 30.912 43.9881 30.824C43.7681 30.736 43.5541 30.61 43.3461 30.446C43.1381 30.282 42.9641 30.066 42.8241 29.798C42.6881 29.526 42.6201 29.184 42.6201 28.772C42.6201 28.192 42.7661 27.71 43.0581 27.326C43.3501 26.942 43.7401 26.656 44.2281 26.468C44.7161 26.28 45.2561 26.188 45.8481 26.192C46.4441 26.2 46.9761 26.302 47.4441 26.498C47.9121 26.694 48.3041 26.98 48.6201 27.356C48.9361 27.728 49.1641 28.184 49.3041 28.724L47.5401 29.024C47.4761 28.744 47.3581 28.508 47.1861 28.316C47.0141 28.124 46.8081 27.978 46.5681 27.878C46.3321 27.778 46.0841 27.724 45.8241 27.716C45.5681 27.708 45.3261 27.744 45.0981 27.824C44.8741 27.9 44.6901 28.012 44.5461 28.16C44.4061 28.308 44.3361 28.484 44.3361 28.688C44.3361 28.876 44.3941 29.03 44.5101 29.15C44.6261 29.266 44.7721 29.36 44.9481 29.432C45.1241 29.504 45.3041 29.564 45.4881 29.612L46.9881 30.02C47.2121 30.08 47.4601 30.16 47.7321 30.26C48.0041 30.356 48.2641 30.492 48.5121 30.668C48.7641 30.84 48.9701 31.068 49.1301 31.352C49.2941 31.636 49.3761 31.996 49.3761 32.432C49.3761 32.896 49.2781 33.302 49.0821 33.65C48.8901 33.994 48.6301 34.28 48.3021 34.508C47.9741 34.732 47.6021 34.9 47.1861 35.012C46.7741 35.124 46.3481 35.18 45.9081 35.18ZM54.0188 35V27.884H51.2948V26.36H58.3748V27.884H55.6508V35H54.0188ZM60.6591 35V26.36H66.2991V27.884H62.2911V29.732H65.5791V31.256H62.2911V33.476H66.2991V35H60.6591ZM76.2955 35.18C75.5995 35.18 74.9875 35.04 74.4595 34.76C73.9315 34.476 73.5195 34.078 73.2235 33.566C72.9275 33.054 72.7795 32.452 72.7795 31.76V26.372L74.4355 26.36V31.748C74.4355 32.032 74.4835 32.29 74.5795 32.522C74.6755 32.754 74.8075 32.954 74.9755 33.122C75.1475 33.29 75.3455 33.42 75.5695 33.512C75.7975 33.6 76.0395 33.644 76.2955 33.644C76.5595 33.644 76.8035 33.598 77.0275 33.506C77.2555 33.414 77.4535 33.284 77.6215 33.116C77.7895 32.948 77.9195 32.748 78.0115 32.516C78.1075 32.284 78.1555 32.028 78.1555 31.748V26.36H79.8115V31.76C79.8115 32.452 79.6635 33.054 79.3675 33.566C79.0715 34.078 78.6595 34.476 78.1315 34.76C77.6035 35.04 76.9915 35.18 76.2955 35.18ZM82.9266 35V26.36H84.5586V35H82.9266ZM91.3997 35V26.36H97.0397V27.884H93.0317V29.732H96.3197V31.256H93.0317V33.476H97.0397V35H91.3997ZM99.9178 35V26.36H101.55V33.476H105.27V35H99.9178ZM107.61 35V26.36H113.25V27.884H109.242V29.732H112.53V31.256H109.242V33.476H113.25V35H107.61ZM116.008 35V26.36H117.472L120.328 32.096L123.184 26.36H124.648V35H123.124V29.84L120.616 35H120.04L117.532 29.84V35H116.008ZM127.652 35V26.36H133.292V27.884H129.284V29.732H132.572V31.256H129.284V33.476H133.292V35H127.652ZM136.05 35V26.36H137.706L141.462 32.12V26.36H143.118V35H141.462L137.706 29.24V35H136.05ZM148.117 35V27.884H145.393V26.36H152.473V27.884H149.749V35H148.117ZM158.236 35V26.36H159.868V35H158.236ZM162.987 35V26.36H165.783C165.851 26.36 165.991 26.362 166.203 26.366C166.415 26.37 166.619 26.384 166.815 26.408C167.511 26.492 168.101 26.734 168.585 27.134C169.069 27.534 169.437 28.042 169.689 28.658C169.941 29.274 170.067 29.948 170.067 30.68C170.067 31.412 169.941 32.086 169.689 32.702C169.437 33.318 169.069 33.826 168.585 34.226C168.101 34.626 167.511 34.868 166.815 34.952C166.619 34.976 166.415 34.99 166.203 34.994C165.991 34.998 165.851 35 165.783 35H162.987ZM164.643 33.464H165.783C165.891 33.464 166.037 33.462 166.221 33.458C166.405 33.45 166.571 33.432 166.719 33.404C167.095 33.328 167.401 33.152 167.637 32.876C167.877 32.6 168.053 32.268 168.165 31.88C168.281 31.492 168.339 31.092 168.339 30.68C168.339 30.248 168.279 29.838 168.159 29.45C168.043 29.062 167.865 28.734 167.625 28.466C167.385 28.198 167.083 28.028 166.719 27.956C166.571 27.924 166.405 27.906 166.221 27.902C166.037 27.898 165.891 27.896 165.783 27.896H164.643V33.464Z\" fill=\"#FF7F33\"/>\n          <rect x=\"24\" y=\"78\" width=\"399\" height=\"44\" rx=\"2\" fill=\"white\" stroke=\"#CCD4DA\"/>\n          <path d=\"M305.98 106V95.92H310.054C310.152 95.92 310.273 95.9247 310.418 95.934C310.563 95.9387 310.7 95.9527 310.831 95.976C311.391 96.0647 311.858 96.256 312.231 96.55C312.609 96.844 312.891 97.215 313.078 97.663C313.265 98.111 313.358 98.6057 313.358 99.147C313.358 99.693 313.265 100.19 313.078 100.638C312.891 101.086 312.609 101.457 312.231 101.751C311.858 102.045 311.391 102.236 310.831 102.325C310.7 102.344 310.56 102.358 310.411 102.367C310.266 102.376 310.147 102.381 310.054 102.381H307.443V106H305.98ZM307.443 100.995H309.998C310.091 100.995 310.194 100.99 310.306 100.981C310.423 100.972 310.532 100.955 310.635 100.932C310.934 100.862 311.174 100.734 311.356 100.547C311.538 100.356 311.669 100.136 311.748 99.889C311.827 99.6417 311.867 99.3943 311.867 99.147C311.867 98.8997 311.827 98.6547 311.748 98.412C311.669 98.1647 311.538 97.9477 311.356 97.761C311.174 97.5697 310.934 97.439 310.635 97.369C310.532 97.341 310.423 97.3223 310.306 97.313C310.194 97.3037 310.091 97.299 309.998 97.299H307.443V100.995ZM316.66 106.21C316.1 106.21 315.631 106.107 315.253 105.902C314.875 105.692 314.588 105.417 314.392 105.076C314.201 104.731 314.105 104.353 314.105 103.942C314.105 103.559 314.173 103.223 314.308 102.934C314.443 102.645 314.644 102.4 314.91 102.199C315.176 101.994 315.503 101.828 315.89 101.702C316.226 101.604 316.606 101.518 317.031 101.443C317.456 101.368 317.901 101.298 318.368 101.233C318.839 101.168 319.306 101.102 319.768 101.037L319.236 101.331C319.245 100.738 319.119 100.3 318.858 100.015C318.601 99.7257 318.158 99.581 317.528 99.581C317.131 99.581 316.767 99.6743 316.436 99.861C316.105 100.043 315.874 100.346 315.743 100.771L314.378 100.351C314.565 99.7023 314.919 99.1867 315.442 98.804C315.969 98.4213 316.669 98.23 317.542 98.23C318.219 98.23 318.807 98.3467 319.306 98.58C319.81 98.8087 320.179 99.1727 320.412 99.672C320.533 99.9193 320.608 100.181 320.636 100.456C320.664 100.731 320.678 101.028 320.678 101.345V106H319.383V104.271L319.635 104.495C319.322 105.074 318.923 105.505 318.438 105.79C317.957 106.07 317.365 106.21 316.66 106.21ZM316.919 105.013C317.334 105.013 317.691 104.941 317.99 104.796C318.289 104.647 318.529 104.458 318.711 104.229C318.893 104 319.012 103.762 319.068 103.515C319.147 103.291 319.192 103.039 319.201 102.759C319.215 102.479 319.222 102.255 319.222 102.087L319.698 102.262C319.236 102.332 318.816 102.395 318.438 102.451C318.06 102.507 317.717 102.563 317.409 102.619C317.106 102.67 316.835 102.733 316.597 102.808C316.396 102.878 316.217 102.962 316.058 103.06C315.904 103.158 315.78 103.277 315.687 103.417C315.598 103.557 315.554 103.727 315.554 103.928C315.554 104.124 315.603 104.306 315.701 104.474C315.799 104.637 315.948 104.768 316.149 104.866C316.35 104.964 316.606 105.013 316.919 105.013ZM325.387 106.203C324.467 106.203 323.718 106 323.14 105.594C322.561 105.188 322.206 104.616 322.076 103.879L323.574 103.648C323.667 104.04 323.882 104.35 324.218 104.579C324.558 104.803 324.981 104.915 325.485 104.915C325.942 104.915 326.299 104.822 326.556 104.635C326.817 104.448 326.948 104.192 326.948 103.865C326.948 103.674 326.901 103.52 326.808 103.403C326.719 103.282 326.53 103.167 326.241 103.06C325.951 102.953 325.51 102.82 324.918 102.661C324.269 102.493 323.753 102.313 323.371 102.122C322.993 101.926 322.722 101.7 322.559 101.443C322.4 101.182 322.321 100.867 322.321 100.498C322.321 100.041 322.442 99.6417 322.685 99.301C322.927 98.9603 323.268 98.6967 323.707 98.51C324.15 98.3233 324.668 98.23 325.261 98.23C325.839 98.23 326.355 98.321 326.808 98.503C327.26 98.685 327.627 98.944 327.907 99.28C328.187 99.6113 328.355 100.001 328.411 100.449L326.913 100.722C326.861 100.358 326.691 100.071 326.402 99.861C326.112 99.651 325.737 99.5367 325.275 99.518C324.831 99.4993 324.472 99.574 324.197 99.742C323.921 99.9053 323.784 100.132 323.784 100.421C323.784 100.589 323.835 100.731 323.938 100.848C324.045 100.965 324.25 101.077 324.554 101.184C324.857 101.291 325.305 101.42 325.898 101.569C326.532 101.732 327.036 101.914 327.41 102.115C327.783 102.311 328.049 102.547 328.208 102.822C328.371 103.093 328.453 103.422 328.453 103.809C328.453 104.556 328.18 105.141 327.634 105.566C327.092 105.991 326.343 106.203 325.387 106.203ZM334.327 106C333.851 106.093 333.385 106.133 332.927 106.119C332.47 106.105 332.062 106.016 331.702 105.853C331.343 105.69 331.072 105.433 330.89 105.083C330.727 104.77 330.638 104.453 330.624 104.131C330.615 103.804 330.61 103.436 330.61 103.025V96.34H332.08V102.955C332.08 103.258 332.083 103.522 332.087 103.746C332.097 103.97 332.146 104.159 332.234 104.313C332.402 104.602 332.668 104.768 333.032 104.81C333.401 104.847 333.833 104.831 334.327 104.761V106ZM329.161 99.616V98.44H334.327V99.616H329.161ZM338.933 106.21C338.181 106.21 337.521 106.047 336.952 105.72C336.387 105.389 335.946 104.929 335.629 104.341C335.316 103.748 335.16 103.062 335.16 102.283C335.16 101.457 335.314 100.741 335.622 100.134C335.934 99.5273 336.368 99.0583 336.924 98.727C337.479 98.3957 338.125 98.23 338.863 98.23C339.633 98.23 340.288 98.4097 340.83 98.769C341.371 99.1237 341.775 99.63 342.041 100.288C342.311 100.946 342.419 101.728 342.363 102.633H340.9V102.101C340.89 101.224 340.722 100.575 340.396 100.155C340.074 99.735 339.581 99.525 338.919 99.525C338.186 99.525 337.635 99.756 337.267 100.218C336.898 100.68 336.714 101.347 336.714 102.22C336.714 103.051 336.898 103.695 337.267 104.152C337.635 104.605 338.167 104.831 338.863 104.831C339.32 104.831 339.714 104.728 340.046 104.523C340.382 104.313 340.643 104.014 340.83 103.627L342.265 104.082C341.971 104.759 341.525 105.284 340.928 105.657C340.33 106.026 339.665 106.21 338.933 106.21ZM336.238 102.633V101.492H341.635V102.633H336.238ZM350.943 106.21C349.935 106.21 349.076 105.991 348.367 105.552C347.658 105.109 347.114 104.493 346.736 103.704C346.363 102.915 346.176 102.001 346.176 100.96C346.176 99.9193 346.363 99.0047 346.736 98.216C347.114 97.4273 347.658 96.8137 348.367 96.375C349.076 95.9317 349.935 95.71 350.943 95.71C352.105 95.71 353.066 96.004 353.827 96.592C354.592 97.18 355.124 97.971 355.423 98.965L353.939 99.364C353.743 98.6593 353.393 98.1063 352.889 97.705C352.39 97.3037 351.741 97.103 350.943 97.103C350.229 97.103 349.634 97.264 349.158 97.586C348.682 97.908 348.323 98.3583 348.08 98.937C347.842 99.5157 347.723 100.19 347.723 100.96C347.718 101.73 347.835 102.404 348.073 102.983C348.316 103.562 348.675 104.012 349.151 104.334C349.632 104.656 350.229 104.817 350.943 104.817C351.741 104.817 352.39 104.616 352.889 104.215C353.393 103.809 353.743 103.256 353.939 102.556L355.423 102.955C355.124 103.949 354.592 104.74 353.827 105.328C353.066 105.916 352.105 106.21 350.943 106.21ZM357.102 106V95.71H358.565V106H357.102ZM360.808 97.201V95.78H362.271V97.201H360.808ZM360.808 106V98.44H362.271V106H360.808ZM367.922 106.21C367.198 106.21 366.592 106.035 366.102 105.685C365.612 105.33 365.241 104.852 364.989 104.25C364.737 103.648 364.611 102.969 364.611 102.213C364.611 101.457 364.734 100.778 364.982 100.176C365.234 99.574 365.602 99.1003 366.088 98.755C366.578 98.405 367.18 98.23 367.894 98.23C368.603 98.23 369.214 98.405 369.728 98.755C370.246 99.1003 370.645 99.574 370.925 100.176C371.205 100.773 371.345 101.452 371.345 102.213C371.345 102.969 371.205 103.65 370.925 104.257C370.649 104.859 370.255 105.335 369.742 105.685C369.233 106.035 368.626 106.21 367.922 106.21ZM364.366 109.36V98.44H365.668V103.879H365.836V109.36H364.366ZM367.719 104.887C368.185 104.887 368.57 104.768 368.874 104.53C369.182 104.292 369.41 103.972 369.56 103.571C369.714 103.165 369.791 102.712 369.791 102.213C369.791 101.718 369.714 101.27 369.56 100.869C369.41 100.468 369.179 100.148 368.867 99.91C368.554 99.672 368.155 99.553 367.67 99.553C367.212 99.553 366.834 99.665 366.536 99.889C366.242 100.113 366.022 100.426 365.878 100.827C365.738 101.228 365.668 101.69 365.668 102.213C365.668 102.736 365.738 103.198 365.878 103.599C366.018 104 366.239 104.315 366.543 104.544C366.846 104.773 367.238 104.887 367.719 104.887ZM376.439 106.21C375.716 106.21 375.109 106.035 374.619 105.685C374.129 105.33 373.758 104.852 373.506 104.25C373.254 103.648 373.128 102.969 373.128 102.213C373.128 101.457 373.252 100.778 373.499 100.176C373.751 99.574 374.12 99.1003 374.605 98.755C375.095 98.405 375.697 98.23 376.411 98.23C377.12 98.23 377.732 98.405 378.245 98.755C378.763 99.1003 379.162 99.574 379.442 100.176C379.722 100.773 379.862 101.452 379.862 102.213C379.862 102.969 379.722 103.65 379.442 104.257C379.167 104.859 378.772 105.335 378.259 105.685C377.75 106.035 377.144 106.21 376.439 106.21ZM372.883 106V95.92H374.353V100.561H374.185V106H372.883ZM376.236 104.887C376.703 104.887 377.088 104.768 377.391 104.53C377.699 104.292 377.928 103.972 378.077 103.571C378.231 103.165 378.308 102.712 378.308 102.213C378.308 101.718 378.231 101.27 378.077 100.869C377.928 100.468 377.697 100.148 377.384 99.91C377.071 99.672 376.672 99.553 376.187 99.553C375.73 99.553 375.352 99.665 375.053 99.889C374.759 100.113 374.54 100.426 374.395 100.827C374.255 101.228 374.185 101.69 374.185 102.213C374.185 102.736 374.255 103.198 374.395 103.599C374.535 104 374.757 104.315 375.06 104.544C375.363 104.773 375.755 104.887 376.236 104.887ZM384.691 106.21C383.935 106.21 383.279 106.04 382.724 105.699C382.168 105.358 381.739 104.889 381.436 104.292C381.137 103.69 380.988 102.997 380.988 102.213C380.988 101.424 381.142 100.731 381.45 100.134C381.758 99.532 382.189 99.0653 382.745 98.734C383.3 98.398 383.949 98.23 384.691 98.23C385.447 98.23 386.102 98.4003 386.658 98.741C387.213 99.0817 387.642 99.5507 387.946 100.148C388.249 100.745 388.401 101.434 388.401 102.213C388.401 103.002 388.247 103.697 387.939 104.299C387.635 104.896 387.206 105.365 386.651 105.706C386.095 106.042 385.442 106.21 384.691 106.21ZM384.691 104.831C385.414 104.831 385.953 104.588 386.308 104.103C386.667 103.613 386.847 102.983 386.847 102.213C386.847 101.424 386.665 100.794 386.301 100.323C385.941 99.847 385.405 99.609 384.691 99.609C384.201 99.609 383.797 99.721 383.48 99.945C383.162 100.164 382.927 100.47 382.773 100.862C382.619 101.249 382.542 101.7 382.542 102.213C382.542 103.006 382.724 103.641 383.088 104.117C383.452 104.593 383.986 104.831 384.691 104.831ZM392.074 106.21C391.514 106.21 391.045 106.107 390.667 105.902C390.289 105.692 390.002 105.417 389.806 105.076C389.615 104.731 389.519 104.353 389.519 103.942C389.519 103.559 389.587 103.223 389.722 102.934C389.857 102.645 390.058 102.4 390.324 102.199C390.59 101.994 390.917 101.828 391.304 101.702C391.64 101.604 392.02 101.518 392.445 101.443C392.87 101.368 393.315 101.298 393.782 101.233C394.253 101.168 394.72 101.102 395.182 101.037L394.65 101.331C394.659 100.738 394.533 100.3 394.272 100.015C394.015 99.7257 393.572 99.581 392.942 99.581C392.545 99.581 392.181 99.6743 391.85 99.861C391.519 100.043 391.288 100.346 391.157 100.771L389.792 100.351C389.979 99.7023 390.333 99.1867 390.856 98.804C391.383 98.4213 392.083 98.23 392.956 98.23C393.633 98.23 394.221 98.3467 394.72 98.58C395.224 98.8087 395.593 99.1727 395.826 99.672C395.947 99.9193 396.022 100.181 396.05 100.456C396.078 100.731 396.092 101.028 396.092 101.345V106H394.797V104.271L395.049 104.495C394.736 105.074 394.337 105.505 393.852 105.79C393.371 106.07 392.779 106.21 392.074 106.21ZM392.333 105.013C392.748 105.013 393.105 104.941 393.404 104.796C393.703 104.647 393.943 104.458 394.125 104.229C394.307 104 394.426 103.762 394.482 103.515C394.561 103.291 394.606 103.039 394.615 102.759C394.629 102.479 394.636 102.255 394.636 102.087L395.112 102.262C394.65 102.332 394.23 102.395 393.852 102.451C393.474 102.507 393.131 102.563 392.823 102.619C392.52 102.67 392.249 102.733 392.011 102.808C391.81 102.878 391.631 102.962 391.472 103.06C391.318 103.158 391.194 103.277 391.101 103.417C391.012 103.557 390.968 103.727 390.968 103.928C390.968 104.124 391.017 104.306 391.115 104.474C391.213 104.637 391.362 104.768 391.563 104.866C391.764 104.964 392.02 105.013 392.333 105.013ZM397.91 106V98.44H399.212V100.274L399.03 100.036C399.123 99.7933 399.244 99.5717 399.394 99.371C399.543 99.1657 399.716 98.9977 399.912 98.867C400.103 98.727 400.315 98.6197 400.549 98.545C400.787 98.4657 401.029 98.419 401.277 98.405C401.524 98.3863 401.762 98.398 401.991 98.44V99.812C401.743 99.7467 401.468 99.728 401.165 99.756C400.866 99.784 400.591 99.8797 400.339 100.043C400.101 100.197 399.912 100.384 399.772 100.603C399.636 100.822 399.538 101.067 399.478 101.338C399.417 101.604 399.387 101.886 399.387 102.185V106H397.91ZM406.19 106.21C405.485 106.21 404.876 106.035 404.363 105.685C403.854 105.335 403.46 104.859 403.18 104.257C402.905 103.65 402.767 102.969 402.767 102.213C402.767 101.452 402.907 100.773 403.187 100.176C403.467 99.574 403.864 99.1003 404.377 98.755C404.895 98.405 405.509 98.23 406.218 98.23C406.932 98.23 407.532 98.405 408.017 98.755C408.507 99.1003 408.876 99.574 409.123 100.176C409.375 100.778 409.501 101.457 409.501 102.213C409.501 102.969 409.375 103.648 409.123 104.25C408.871 104.852 408.5 105.33 408.01 105.685C407.52 106.035 406.913 106.21 406.19 106.21ZM406.393 104.887C406.874 104.887 407.266 104.773 407.569 104.544C407.872 104.315 408.094 104 408.234 103.599C408.374 103.198 408.444 102.736 408.444 102.213C408.444 101.69 408.372 101.228 408.227 100.827C408.087 100.426 407.868 100.113 407.569 99.889C407.275 99.665 406.899 99.553 406.442 99.553C405.957 99.553 405.558 99.672 405.245 99.91C404.932 100.148 404.699 100.468 404.545 100.869C404.396 101.27 404.321 101.718 404.321 102.213C404.321 102.712 404.396 103.165 404.545 103.571C404.699 103.972 404.928 104.292 405.231 104.53C405.539 104.768 405.926 104.887 406.393 104.887ZM408.444 106V100.561H408.276V95.92H409.746V106H408.444Z\" fill=\"#FF7F33\"/>\n          <path d=\"M40.98 105V94.92H45.054C45.152 94.92 45.2733 94.9247 45.418 94.934C45.5627 94.9387 45.7003 94.9527 45.831 94.976C46.391 95.0647 46.8577 95.256 47.231 95.55C47.609 95.844 47.8913 96.215 48.078 96.663C48.2647 97.111 48.358 97.6057 48.358 98.147C48.358 98.693 48.2647 99.19 48.078 99.638C47.8913 100.086 47.609 100.457 47.231 100.751C46.8577 101.045 46.391 101.236 45.831 101.325C45.7003 101.344 45.5603 101.358 45.411 101.367C45.2663 101.376 45.1473 101.381 45.054 101.381H42.443V105H40.98ZM42.443 99.995H44.998C45.0913 99.995 45.194 99.9903 45.306 99.981C45.4227 99.9717 45.5323 99.9553 45.635 99.932C45.9337 99.862 46.174 99.7337 46.356 99.547C46.538 99.3557 46.6687 99.1363 46.748 98.889C46.8273 98.6417 46.867 98.3943 46.867 98.147C46.867 97.8997 46.8273 97.6547 46.748 97.412C46.6687 97.1647 46.538 96.9477 46.356 96.761C46.174 96.5697 45.9337 96.439 45.635 96.369C45.5323 96.341 45.4227 96.3223 45.306 96.313C45.194 96.3037 45.0913 96.299 44.998 96.299H42.443V99.995ZM51.7999 105.21C51.2399 105.21 50.7709 105.107 50.3929 104.902C50.0149 104.692 49.7279 104.417 49.5319 104.076C49.3406 103.731 49.2449 103.353 49.2449 102.942C49.2449 102.559 49.3126 102.223 49.4479 101.934C49.5833 101.645 49.7839 101.4 50.0499 101.199C50.3159 100.994 50.6426 100.828 51.0299 100.702C51.3659 100.604 51.7463 100.518 52.1709 100.443C52.5956 100.368 53.0413 100.298 53.5079 100.233C53.9793 100.168 54.4459 100.102 54.9079 100.037L54.3759 100.331C54.3853 99.7383 54.2593 99.2997 53.9979 99.015C53.7413 98.7257 53.2979 98.581 52.6679 98.581C52.2713 98.581 51.9073 98.6743 51.5759 98.861C51.2446 99.043 51.0136 99.3463 50.8829 99.771L49.5179 99.351C49.7046 98.7023 50.0593 98.1867 50.5819 97.804C51.1093 97.4213 51.8093 97.23 52.6819 97.23C53.3586 97.23 53.9466 97.3467 54.4459 97.58C54.9499 97.8087 55.3186 98.1727 55.5519 98.672C55.6733 98.9193 55.7479 99.1807 55.7759 99.456C55.8039 99.7313 55.8179 100.028 55.8179 100.345V105H54.5229V103.271L54.7749 103.495C54.4623 104.074 54.0633 104.505 53.5779 104.79C53.0973 105.07 52.5046 105.21 51.7999 105.21ZM52.0589 104.013C52.4743 104.013 52.8313 103.941 53.1299 103.796C53.4286 103.647 53.6689 103.458 53.8509 103.229C54.0329 103 54.1519 102.762 54.2079 102.515C54.2873 102.291 54.3316 102.039 54.3409 101.759C54.3549 101.479 54.3619 101.255 54.3619 101.087L54.8379 101.262C54.3759 101.332 53.9559 101.395 53.5779 101.451C53.1999 101.507 52.8569 101.563 52.5489 101.619C52.2456 101.67 51.9749 101.733 51.7369 101.808C51.5363 101.878 51.3566 101.962 51.1979 102.06C51.0439 102.158 50.9203 102.277 50.8269 102.417C50.7383 102.557 50.6939 102.727 50.6939 102.928C50.6939 103.124 50.7429 103.306 50.8409 103.474C50.9389 103.637 51.0883 103.768 51.2889 103.866C51.4896 103.964 51.7463 104.013 52.0589 104.013ZM60.6666 105.203C59.7473 105.203 58.9983 105 58.4196 104.594C57.841 104.188 57.4863 103.616 57.3556 102.879L58.8536 102.648C58.947 103.04 59.1616 103.35 59.4976 103.579C59.8383 103.803 60.2606 103.915 60.7646 103.915C61.222 103.915 61.579 103.822 61.8356 103.635C62.097 103.448 62.2276 103.192 62.2276 102.865C62.2276 102.674 62.181 102.52 62.0876 102.403C61.999 102.282 61.81 102.167 61.5206 102.06C61.2313 101.953 60.7903 101.82 60.1976 101.661C59.549 101.493 59.0333 101.313 58.6506 101.122C58.2726 100.926 58.002 100.7 57.8386 100.443C57.68 100.182 57.6006 99.8667 57.6006 99.498C57.6006 99.0407 57.722 98.6417 57.9646 98.301C58.2073 97.9603 58.548 97.6967 58.9866 97.51C59.43 97.3233 59.948 97.23 60.5406 97.23C61.1193 97.23 61.635 97.321 62.0876 97.503C62.5403 97.685 62.9066 97.944 63.1866 98.28C63.4666 98.6113 63.6346 99.001 63.6906 99.449L62.1926 99.722C62.1413 99.358 61.971 99.071 61.6816 98.861C61.3923 98.651 61.0166 98.5367 60.5546 98.518C60.1113 98.4993 59.752 98.574 59.4766 98.742C59.2013 98.9053 59.0636 99.1317 59.0636 99.421C59.0636 99.589 59.115 99.7313 59.2176 99.848C59.325 99.9647 59.5303 100.077 59.8336 100.184C60.137 100.291 60.585 100.42 61.1776 100.569C61.8123 100.732 62.3163 100.914 62.6896 101.115C63.063 101.311 63.329 101.547 63.4876 101.822C63.651 102.093 63.7326 102.422 63.7326 102.809C63.7326 103.556 63.4596 104.141 62.9136 104.566C62.3723 104.991 61.6233 105.203 60.6666 105.203ZM69.7475 105C69.2715 105.093 68.8048 105.133 68.3475 105.119C67.8902 105.105 67.4818 105.016 67.1225 104.853C66.7632 104.69 66.4925 104.433 66.3105 104.083C66.1472 103.77 66.0585 103.453 66.0445 103.131C66.0352 102.804 66.0305 102.436 66.0305 102.025V95.34H67.5005V101.955C67.5005 102.258 67.5028 102.522 67.5075 102.746C67.5168 102.97 67.5658 103.159 67.6545 103.313C67.8225 103.602 68.0885 103.768 68.4525 103.81C68.8212 103.847 69.2528 103.831 69.7475 103.761V105ZM64.5815 98.616V97.44H69.7475V98.616H64.5815ZM74.4926 105.21C73.7413 105.21 73.0809 105.047 72.5116 104.72C71.9469 104.389 71.5059 103.929 71.1886 103.341C70.8759 102.748 70.7196 102.062 70.7196 101.283C70.7196 100.457 70.8736 99.7407 71.1816 99.134C71.4943 98.5273 71.9283 98.0583 72.4836 97.727C73.0389 97.3957 73.6853 97.23 74.4226 97.23C75.1926 97.23 75.8483 97.4097 76.3896 97.769C76.9309 98.1237 77.3346 98.63 77.6006 99.288C77.8713 99.946 77.9786 100.728 77.9226 101.633H76.4596V101.101C76.4503 100.224 76.2823 99.575 75.9556 99.155C75.6336 98.735 75.1413 98.525 74.4786 98.525C73.7459 98.525 73.1953 98.756 72.8266 99.218C72.4579 99.68 72.2736 100.347 72.2736 101.22C72.2736 102.051 72.4579 102.695 72.8266 103.152C73.1953 103.605 73.7273 103.831 74.4226 103.831C74.8799 103.831 75.2743 103.728 75.6056 103.523C75.9416 103.313 76.2029 103.014 76.3896 102.627L77.8246 103.082C77.5306 103.759 77.0849 104.284 76.4876 104.657C75.8903 105.026 75.2253 105.21 74.4926 105.21ZM71.7976 101.633V100.492H77.1946V101.633H71.7976ZM86.7829 105.21C85.7749 105.21 84.9162 104.991 84.2069 104.552C83.4975 104.109 82.9539 103.493 82.5759 102.704C82.2025 101.915 82.0159 101.001 82.0159 99.96C82.0159 98.9193 82.2025 98.0047 82.5759 97.216C82.9539 96.4273 83.4975 95.8137 84.2069 95.375C84.9162 94.9317 85.7749 94.71 86.7829 94.71C87.9449 94.71 88.9062 95.004 89.6669 95.592C90.4322 96.18 90.9642 96.971 91.2629 97.965L89.7789 98.364C89.5829 97.6593 89.2329 97.1063 88.7289 96.705C88.2295 96.3037 87.5809 96.103 86.7829 96.103C86.0689 96.103 85.4739 96.264 84.9979 96.586C84.5219 96.908 84.1625 97.3583 83.9199 97.937C83.6819 98.5157 83.5629 99.19 83.5629 99.96C83.5582 100.73 83.6749 101.404 83.9129 101.983C84.1555 102.562 84.5149 103.012 84.9909 103.334C85.4715 103.656 86.0689 103.817 86.7829 103.817C87.5809 103.817 88.2295 103.616 88.7289 103.215C89.2329 102.809 89.5829 102.256 89.7789 101.556L91.2629 101.955C90.9642 102.949 90.4322 103.74 89.6669 104.328C88.9062 104.916 87.9449 105.21 86.7829 105.21ZM97.0202 105.21C96.2969 105.21 95.6436 105.086 95.0602 104.839C94.4816 104.587 94.0032 104.23 93.6252 103.768C93.2519 103.301 93.0092 102.748 92.8972 102.109L94.4232 101.878C94.5772 102.494 94.8992 102.975 95.3892 103.32C95.8792 103.661 96.4509 103.831 97.1042 103.831C97.5102 103.831 97.8836 103.768 98.2242 103.642C98.5649 103.511 98.8379 103.327 99.0432 103.089C99.2532 102.846 99.3582 102.557 99.3582 102.221C99.3582 102.039 99.3256 101.878 99.2602 101.738C99.1996 101.598 99.1132 101.477 99.0012 101.374C98.8939 101.267 98.7609 101.176 98.6023 101.101C98.4482 101.022 98.2779 100.954 98.0912 100.898L95.5082 100.135C95.2562 100.06 94.9996 99.9647 94.7382 99.848C94.4769 99.7267 94.2366 99.5703 94.0172 99.379C93.8026 99.183 93.6276 98.9427 93.4922 98.658C93.3569 98.3687 93.2892 98.0187 93.2892 97.608C93.2892 96.9873 93.4479 96.4623 93.7652 96.033C94.0872 95.599 94.5212 95.2723 95.0672 95.053C95.6132 94.829 96.2246 94.717 96.9012 94.717C97.5826 94.7263 98.1916 94.8477 98.7282 95.081C99.2696 95.3143 99.7176 95.6503 100.072 96.089C100.432 96.523 100.679 97.0503 100.814 97.671L99.2462 97.937C99.1762 97.559 99.0269 97.2347 98.7983 96.964C98.5696 96.6887 98.2896 96.4787 97.9582 96.334C97.6269 96.1847 97.2676 96.1077 96.8802 96.103C96.5069 96.0937 96.1639 96.1497 95.8512 96.271C95.5432 96.3923 95.2959 96.5627 95.1092 96.782C94.9272 97.0013 94.8362 97.2533 94.8362 97.538C94.8362 97.818 94.9179 98.0443 95.0812 98.217C95.2446 98.3897 95.4452 98.5273 95.6832 98.63C95.9259 98.728 96.1662 98.8097 96.4042 98.875L98.2662 99.4C98.4996 99.4653 98.7632 99.554 99.0573 99.666C99.3559 99.7733 99.6429 99.925 99.9183 100.121C100.198 100.317 100.429 100.578 100.611 100.905C100.793 101.227 100.884 101.633 100.884 102.123C100.884 102.632 100.782 103.08 100.576 103.467C100.371 103.85 100.089 104.172 99.7292 104.433C99.3746 104.69 98.9639 104.883 98.4972 105.014C98.0306 105.145 97.5382 105.21 97.0202 105.21ZM106.375 105.21C105.652 105.21 104.998 105.086 104.415 104.839C103.836 104.587 103.358 104.23 102.98 103.768C102.607 103.301 102.364 102.748 102.252 102.109L103.778 101.878C103.932 102.494 104.254 102.975 104.744 103.32C105.234 103.661 105.806 103.831 106.459 103.831C106.865 103.831 107.238 103.768 107.579 103.642C107.92 103.511 108.193 103.327 108.398 103.089C108.608 102.846 108.713 102.557 108.713 102.221C108.713 102.039 108.68 101.878 108.615 101.738C108.554 101.598 108.468 101.477 108.356 101.374C108.249 101.267 108.116 101.176 107.957 101.101C107.803 101.022 107.633 100.954 107.446 100.898L104.863 100.135C104.611 100.06 104.354 99.9647 104.093 99.848C103.832 99.7267 103.591 99.5703 103.372 99.379C103.157 99.183 102.982 98.9427 102.847 98.658C102.712 98.3687 102.644 98.0187 102.644 97.608C102.644 96.9873 102.803 96.4623 103.12 96.033C103.442 95.599 103.876 95.2723 104.422 95.053C104.968 94.829 105.579 94.717 106.256 94.717C106.937 94.7263 107.546 94.8477 108.083 95.081C108.624 95.3143 109.072 95.6503 109.427 96.089C109.786 96.523 110.034 97.0503 110.169 97.671L108.601 97.937C108.531 97.559 108.382 97.2347 108.153 96.964C107.924 96.6887 107.644 96.4787 107.313 96.334C106.982 96.1847 106.622 96.1077 106.235 96.103C105.862 96.0937 105.519 96.1497 105.206 96.271C104.898 96.3923 104.651 96.5627 104.464 96.782C104.282 97.0013 104.191 97.2533 104.191 97.538C104.191 97.818 104.273 98.0443 104.436 98.217C104.599 98.3897 104.8 98.5273 105.038 98.63C105.281 98.728 105.521 98.8097 105.759 98.875L107.621 99.4C107.854 99.4653 108.118 99.554 108.412 99.666C108.711 99.7733 108.998 99.925 109.273 100.121C109.553 100.317 109.784 100.578 109.966 100.905C110.148 101.227 110.239 101.633 110.239 102.123C110.239 102.632 110.136 103.08 109.931 103.467C109.726 103.85 109.443 104.172 109.084 104.433C108.729 104.69 108.319 104.883 107.852 105.014C107.385 105.145 106.893 105.21 106.375 105.21ZM114.954 105V94.92H116.417V105H114.954ZM118.659 105V94.92H121.816C121.909 94.92 122.082 94.9223 122.334 94.927C122.59 94.9317 122.835 94.9503 123.069 94.983C123.857 95.081 124.52 95.3633 125.057 95.83C125.598 96.2967 126.006 96.8893 126.282 97.608C126.557 98.322 126.695 99.106 126.695 99.96C126.695 100.819 126.557 101.607 126.282 102.326C126.006 103.04 125.598 103.63 125.057 104.097C124.52 104.559 123.857 104.839 123.069 104.937C122.835 104.97 122.59 104.988 122.334 104.993C122.082 104.998 121.909 105 121.816 105H118.659ZM120.157 103.607H121.816C121.974 103.607 122.163 103.602 122.383 103.593C122.602 103.584 122.796 103.565 122.964 103.537C123.477 103.439 123.892 103.217 124.21 102.872C124.532 102.522 124.767 102.093 124.917 101.584C125.066 101.075 125.141 100.534 125.141 99.96C125.141 99.3673 125.064 98.819 124.91 98.315C124.756 97.8063 124.518 97.3817 124.196 97.041C123.878 96.6957 123.468 96.4763 122.964 96.383C122.796 96.3503 122.6 96.3317 122.376 96.327C122.156 96.3177 121.97 96.313 121.816 96.313H120.157V103.607Z\" fill=\"#B3BEC6\"/>\n          <path d=\"M34 48C28.4903 48 24 52.4903 24 58C24 63.5097 28.4903 68 34 68C39.5097 68 44 63.5097 44 58C44 52.4903 39.5097 48 34 48ZM34 67.0291C29.0243 67.0291 24.9709 62.9757 24.9709 58C24.9709 53.0243 29.0243 48.9709 34 48.9709C38.9757 48.9709 43.0291 53.0243 43.0291 58C43.0291 62.9757 38.9757 67.0291 34 67.0291Z\" fill=\"#FF7F33\"/>\n          <path d=\"M33.9985 64.0907C37.3631 64.0907 40.0907 61.3631 40.0907 57.9985C40.0907 54.6338 37.3631 51.9062 33.9985 51.9062C30.6338 51.9062 27.9062 54.6338 27.9062 57.9985C27.9062 61.3631 30.6338 64.0907 33.9985 64.0907Z\" fill=\"#FF7F33\"/>\n          <path d=\"M59.5575 64.225C58.4775 64.225 57.5575 63.99 56.7975 63.52C56.0375 63.045 55.455 62.385 55.05 61.54C54.65 60.695 54.45 59.715 54.45 58.6C54.45 57.485 54.65 56.505 55.05 55.66C55.455 54.815 56.0375 54.1575 56.7975 53.6875C57.5575 53.2125 58.4775 52.975 59.5575 52.975C60.8025 52.975 61.8325 53.29 62.6475 53.92C63.4675 54.55 64.0375 55.3975 64.3575 56.4625L62.7675 56.89C62.5575 56.135 62.1825 55.5425 61.6425 55.1125C61.1075 54.6825 60.4125 54.4675 59.5575 54.4675C58.7925 54.4675 58.155 54.64 57.645 54.985C57.135 55.33 56.75 55.8125 56.49 56.4325C56.235 57.0525 56.1075 57.775 56.1075 58.6C56.1025 59.425 56.2275 60.1475 56.4825 60.7675C56.7425 61.3875 57.1275 61.87 57.6375 62.215C58.1525 62.56 58.7925 62.7325 59.5575 62.7325C60.4125 62.7325 61.1075 62.5175 61.6425 62.0875C62.1825 61.6525 62.5575 61.06 62.7675 60.31L64.3575 60.7375C64.0375 61.8025 63.4675 62.65 62.6475 63.28C61.8325 63.91 60.8025 64.225 59.5575 64.225ZM70.3761 64.225C69.6011 64.225 68.9011 64.0925 68.2761 63.8275C67.6561 63.5575 67.1436 63.175 66.7386 62.68C66.3386 62.18 66.0786 61.5875 65.9586 60.9025L67.5936 60.655C67.7586 61.315 68.1036 61.83 68.6286 62.2C69.1536 62.565 69.7661 62.7475 70.4661 62.7475C70.9011 62.7475 71.3011 62.68 71.6661 62.545C72.0311 62.405 72.3236 62.2075 72.5436 61.9525C72.7686 61.6925 72.8811 61.3825 72.8811 61.0225C72.8811 60.8275 72.8461 60.655 72.7761 60.505C72.7111 60.355 72.6186 60.225 72.4986 60.115C72.3836 60 72.2411 59.9025 72.0711 59.8225C71.9061 59.7375 71.7236 59.665 71.5236 59.605L68.7561 58.7875C68.4861 58.7075 68.2111 58.605 67.9311 58.48C67.6511 58.35 67.3936 58.1825 67.1586 57.9775C66.9286 57.7675 66.7411 57.51 66.5961 57.205C66.4511 56.895 66.3786 56.52 66.3786 56.08C66.3786 55.415 66.5486 54.8525 66.8886 54.3925C67.2336 53.9275 67.6986 53.5775 68.2836 53.3425C68.8686 53.1025 69.5236 52.9825 70.2486 52.9825C70.9786 52.9925 71.6311 53.1225 72.2061 53.3725C72.7861 53.6225 73.2661 53.9825 73.6461 54.4525C74.0311 54.9175 74.2961 55.4825 74.4411 56.1475L72.7611 56.4325C72.6861 56.0275 72.5261 55.68 72.2811 55.39C72.0361 55.095 71.7361 54.87 71.3811 54.715C71.0261 54.555 70.6411 54.4725 70.2261 54.4675C69.8261 54.4575 69.4586 54.5175 69.1236 54.6475C68.7936 54.7775 68.5286 54.96 68.3286 55.195C68.1336 55.43 68.0361 55.7 68.0361 56.005C68.0361 56.305 68.1236 56.5475 68.2986 56.7325C68.4736 56.9175 68.6886 57.065 68.9436 57.175C69.2036 57.28 69.4611 57.3675 69.7161 57.4375L71.7111 58C71.9611 58.07 72.2436 58.165 72.5586 58.285C72.8786 58.4 73.1861 58.5625 73.4811 58.7725C73.7811 58.9825 74.0286 59.2625 74.2236 59.6125C74.4186 59.9575 74.5161 60.3925 74.5161 60.9175C74.5161 61.4625 74.4061 61.9425 74.1861 62.3575C73.9661 62.7675 73.6636 63.1125 73.2786 63.3925C72.8986 63.6675 72.4586 63.875 71.9586 64.015C71.4586 64.155 70.9311 64.225 70.3761 64.225ZM80.2492 64.225C79.4742 64.225 78.7742 64.0925 78.1492 63.8275C77.5292 63.5575 77.0167 63.175 76.6117 62.68C76.2117 62.18 75.9517 61.5875 75.8317 60.9025L77.4667 60.655C77.6317 61.315 77.9767 61.83 78.5017 62.2C79.0267 62.565 79.6392 62.7475 80.3392 62.7475C80.7742 62.7475 81.1742 62.68 81.5392 62.545C81.9042 62.405 82.1967 62.2075 82.4167 61.9525C82.6417 61.6925 82.7542 61.3825 82.7542 61.0225C82.7542 60.8275 82.7192 60.655 82.6492 60.505C82.5842 60.355 82.4917 60.225 82.3717 60.115C82.2567 60 82.1142 59.9025 81.9442 59.8225C81.7792 59.7375 81.5967 59.665 81.3967 59.605L78.6292 58.7875C78.3592 58.7075 78.0842 58.605 77.8042 58.48C77.5242 58.35 77.2667 58.1825 77.0317 57.9775C76.8017 57.7675 76.6142 57.51 76.4692 57.205C76.3242 56.895 76.2517 56.52 76.2517 56.08C76.2517 55.415 76.4217 54.8525 76.7617 54.3925C77.1067 53.9275 77.5717 53.5775 78.1567 53.3425C78.7417 53.1025 79.3967 52.9825 80.1217 52.9825C80.8517 52.9925 81.5042 53.1225 82.0792 53.3725C82.6592 53.6225 83.1392 53.9825 83.5192 54.4525C83.9042 54.9175 84.1692 55.4825 84.3142 56.1475L82.6342 56.4325C82.5592 56.0275 82.3992 55.68 82.1542 55.39C81.9092 55.095 81.6092 54.87 81.2542 54.715C80.8992 54.555 80.5142 54.4725 80.0992 54.4675C79.6992 54.4575 79.3317 54.5175 78.9967 54.6475C78.6667 54.7775 78.4017 54.96 78.2017 55.195C78.0067 55.43 77.9092 55.7 77.9092 56.005C77.9092 56.305 77.9967 56.5475 78.1717 56.7325C78.3467 56.9175 78.5617 57.065 78.8167 57.175C79.0767 57.28 79.3342 57.3675 79.5892 57.4375L81.5842 58C81.8342 58.07 82.1167 58.165 82.4317 58.285C82.7517 58.4 83.0592 58.5625 83.3542 58.7725C83.6542 58.9825 83.9017 59.2625 84.0967 59.6125C84.2917 59.9575 84.3892 60.3925 84.3892 60.9175C84.3892 61.4625 84.2792 61.9425 84.0592 62.3575C83.8392 62.7675 83.5367 63.1125 83.1517 63.3925C82.7717 63.6675 82.3317 63.875 81.8317 64.015C81.3317 64.155 80.8042 64.225 80.2492 64.225Z\" fill=\"#002845\"/>\n          <path opacity=\"0.3\" d=\"M125 48C119.49 48 115 52.4903 115 58C115 63.5097 119.49 68 125 68C130.51 68 135 63.5097 135 58C135 52.4903 130.51 48 125 48ZM125 67.0291C120.024 67.0291 115.971 62.9757 115.971 58C115.971 53.0243 120.024 48.9709 125 48.9709C129.976 48.9709 134.029 53.0243 134.029 58C134.029 62.9757 129.976 67.0291 125 67.0291Z\" fill=\"#002845\"/>\n          <path d=\"M145.15 64L148.833 58.5325L145.247 53.2H147.168L149.8 57.205L152.418 53.2H154.345L150.76 58.5325L154.435 64H152.515L149.8 59.8675L147.078 64H145.15ZM155.63 64V53.2H159.995C160.1 53.2 160.23 53.205 160.385 53.215C160.54 53.22 160.688 53.235 160.828 53.26C161.428 53.355 161.928 53.56 162.328 53.875C162.733 54.19 163.035 54.5875 163.235 55.0675C163.435 55.5475 163.535 56.0775 163.535 56.6575C163.535 57.2425 163.435 57.775 163.235 58.255C163.035 58.735 162.733 59.1325 162.328 59.4475C161.928 59.7625 161.428 59.9675 160.828 60.0625C160.688 60.0825 160.538 60.0975 160.378 60.1075C160.223 60.1175 160.095 60.1225 159.995 60.1225H157.198V64H155.63ZM157.198 58.6375H159.935C160.035 58.6375 160.145 58.6325 160.265 58.6225C160.39 58.6125 160.508 58.595 160.618 58.57C160.938 58.495 161.195 58.3575 161.39 58.1575C161.585 57.9525 161.725 57.7175 161.81 57.4525C161.895 57.1875 161.938 56.9225 161.938 56.6575C161.938 56.3925 161.895 56.13 161.81 55.87C161.725 55.605 161.585 55.3725 161.39 55.1725C161.195 54.9675 160.938 54.8275 160.618 54.7525C160.508 54.7225 160.39 54.7025 160.265 54.6925C160.145 54.6825 160.035 54.6775 159.935 54.6775H157.198V58.6375ZM167.073 64.225C166.473 64.225 165.97 64.115 165.565 63.895C165.16 63.67 164.853 63.375 164.643 63.01C164.438 62.64 164.335 62.235 164.335 61.795C164.335 61.385 164.408 61.025 164.553 60.715C164.698 60.405 164.913 60.1425 165.198 59.9275C165.483 59.7075 165.833 59.53 166.248 59.395C166.608 59.29 167.015 59.1975 167.47 59.1175C167.925 59.0375 168.403 58.9625 168.903 58.8925C169.408 58.8225 169.908 58.7525 170.403 58.6825L169.833 58.9975C169.843 58.3625 169.708 57.8925 169.428 57.5875C169.153 57.2775 168.678 57.1225 168.003 57.1225C167.578 57.1225 167.188 57.2225 166.833 57.4225C166.478 57.6175 166.23 57.9425 166.09 58.3975L164.628 57.9475C164.828 57.2525 165.208 56.7 165.768 56.29C166.333 55.88 167.083 55.675 168.018 55.675C168.743 55.675 169.373 55.8 169.908 56.05C170.448 56.295 170.843 56.685 171.093 57.22C171.223 57.485 171.303 57.765 171.333 58.06C171.363 58.355 171.378 58.6725 171.378 59.0125V64H169.99V62.1475L170.26 62.3875C169.925 63.0075 169.498 63.47 168.978 63.775C168.463 64.075 167.828 64.225 167.073 64.225ZM167.35 62.9425C167.795 62.9425 168.178 62.865 168.498 62.71C168.818 62.55 169.075 62.3475 169.27 62.1025C169.465 61.8575 169.593 61.6025 169.653 61.3375C169.738 61.0975 169.785 60.8275 169.795 60.5275C169.81 60.2275 169.818 59.9875 169.818 59.8075L170.328 59.995C169.833 60.07 169.383 60.1375 168.978 60.1975C168.573 60.2575 168.205 60.3175 167.875 60.3775C167.55 60.4325 167.26 60.5 167.005 60.58C166.79 60.655 166.598 60.745 166.428 60.85C166.263 60.955 166.13 61.0825 166.03 61.2325C165.935 61.3825 165.888 61.565 165.888 61.78C165.888 61.99 165.94 62.185 166.045 62.365C166.15 62.54 166.31 62.68 166.525 62.785C166.74 62.89 167.015 62.9425 167.35 62.9425ZM177.96 64C177.45 64.1 176.95 64.1425 176.46 64.1275C175.97 64.1125 175.533 64.0175 175.148 63.8425C174.763 63.6675 174.473 63.3925 174.278 63.0175C174.103 62.6825 174.008 62.3425 173.993 61.9975C173.983 61.6475 173.978 61.2525 173.978 60.8125V53.65H175.553V60.7375C175.553 61.0625 175.555 61.345 175.56 61.585C175.57 61.825 175.623 62.0275 175.718 62.1925C175.898 62.5025 176.183 62.68 176.573 62.725C176.968 62.765 177.43 62.7475 177.96 62.6725V64ZM172.425 57.16V55.9H177.96V57.16H172.425ZM185.353 64V60.0175C185.353 59.7025 185.326 59.38 185.271 59.05C185.221 58.715 185.121 58.405 184.971 58.12C184.826 57.835 184.618 57.605 184.348 57.43C184.083 57.255 183.736 57.1675 183.306 57.1675C183.026 57.1675 182.761 57.215 182.511 57.31C182.261 57.4 182.041 57.5475 181.851 57.7525C181.666 57.9575 181.518 58.2275 181.408 58.5625C181.303 58.8975 181.251 59.305 181.251 59.785L180.276 59.4175C180.276 58.6825 180.413 58.035 180.688 57.475C180.963 56.91 181.358 56.47 181.873 56.155C182.388 55.84 183.011 55.6825 183.741 55.6825C184.301 55.6825 184.771 55.7725 185.151 55.9525C185.531 56.1325 185.838 56.37 186.073 56.665C186.313 56.955 186.496 57.2725 186.621 57.6175C186.746 57.9625 186.831 58.3 186.876 58.63C186.921 58.96 186.943 59.25 186.943 59.5V64H185.353ZM179.661 64V53.2H181.063V59.0275H181.251V64H179.661Z\" fill=\"#002845\"/>\n          <path d=\"M208 99L242.569 96.7705L223.354 67.9475L208 99ZM232.129 86.5192L287.664 49.4962L284.336 44.5039L228.801 81.5269L232.129 86.5192Z\" fill=\"#00BDE1\"/>\n        </svg>\n      ";
        if (_this._type !== "Desktop") {
          message = "Element selected! Now go back to the apxor dashboard to proceed";
          uiElementPasteSVG = "";
        }
        var feedbackModal = "\n        <style> \n          .apx-container{\n            padding:20px;\n          }\n        </style>\n        <div id=\"apx-container\" class=\"apx-container\">\n              <div id=\"close-button\" style=\"position:fixed;top:20px;right:10px;\"><svg width=\"18\" height=\"18\" viewBox=\"0 0 18 18\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n                <path opacity=\"0.5\" d=\"M11.0962 9.07071L17.8586 15.8331L15.8331 17.8586L9.0707 11.0962L8.99999 11.0255L8.92928 11.0962L2.16693 17.8586L0.141421 15.8331L6.90379 9.07071L6.9745 9L6.90379 8.92929L0.141421 2.16694L2.16693 0.141422L8.92928 6.9038L8.99999 6.97451L9.0707 6.9038L15.8331 0.141422L17.8586 2.16694L11.0962 8.92929L11.0255 9L11.0962 9.07071Z\" fill=\"white\" stroke=\"#002845\" stroke-width=\"0.2\"/>\n                </svg>\n              </div>\n              <div style=\"font-family: 'Manrope';font-style: normal;font-weight: 600;font-size: 16px;line-height: 22px;\n              color: #FFFFFF;\">".concat(message, "</div>\n              ").concat(uiElementPasteSVG, "\n        </div>\n      ");
        var feedbackParentDiv = document.createElement("div");
        feedbackParentDiv.style = "\n        z-index:99999999;\n        background:#002845;\n        position:fixed;\n        top:50%;\n        left:50%;\n        transform:translate(-50%, -50%);\n      ";
        feedbackParentDiv.innerHTML = feedbackModal;
        document.body.appendChild(feedbackParentDiv);
        var closeButton = document.getElementById("close-button");
        closeButton.addEventListener("click", function () {
          var conatiner = document.getElementById("apx-container");
          conatiner.remove();
          divELement.remove();
          enableViewSelectionBtn.disabled = false;
          var helper = Apxor.getApxorFlutterHelper(); /*getApxorFlutterHelper:returns object*/
          helper.enableClick();
        });
      };
      /**
       * Hides this button, Shows the Enable View Selection button and remove all attached event listeners
       *
       * At last, show a toast kind of message at the center of the screen
       */
      var disableViewSelectionHandler = function disableViewSelectionHandler() {
        _this._hideSelectionMode();
        disableViewSelectionButton.style.display = "none";
        enableViewSelectionButton.style.display = "block";
      };
      disableViewSelectionButton.onclick = disableViewSelectionHandler;

      // Listen on these custom external events to control the show/hide behaviour of the buttons reside in this div
      _this._wysiwygRoot.addEventListener("preview", disableViewSelectionHandler);
      _this._wysiwygRoot.addEventListener("added", function () {
        addDeviceButton.style.display = "none";
        removeDeviceButton.style.display = "block";
        buttons.style.display = "flex";
        enableViewSelectionButton.style.display = "block";
      });
      dragElement(node);
    });
    _defineProperty$1(this, "_hideSelectionMode", function () {
      var hideHTML = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : OFF_HTML;
      if (!_this.isSelectionMode) {
        return;
      }
      // Remove the mouseover and mouseout listeners
      window.removeEventListener("mouseover", onMouseOver, true);
      window.removeEventListener("mouseout", onMouseOut, true);
      window.removeEventListener("click", _this.clickListener, true);
      var nodes = document.querySelectorAll(".apx-highlight");
      for (var index = 0; index < nodes.length; index++) {
        var node = nodes[index];
        node.classList.remove("apx-highlight");
      }
      _this._hideToast(true, hideHTML);
      _this.isSelectionMode = false;
    });
    _defineProperty$1(this, "_hideToast", function () {
      var hide = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var hideHTML = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : OFF_HTML;
      _this._viewPickerNode.style.visibility = "visible";
      if (hide) {
        _this._viewPickerNode.innerHTML = hideHTML;
        _this._viewPickerNode.style.opacity = 1;
      } else {
        _this._viewPickerNode.innerHTML = ON_HTML;
        _this._viewPickerNode.style.opacity = 1;
      }
      setTimeout(function () {
        _this._viewPickerNode.style.opacity = 0;
        _this._viewPickerNode.style.visibility = "hidden";
      }, 1000);
    });
    /**
     * Dialog that shows helps to add this device as test device
     */
    _defineProperty$1(this, "_showAddTestDeviceDialog", function (rtmInstance) {
      var dialog = createDialog$1(500, 20, {});
      var dialogContent = dialog.children[0];
      dialogContent.style.flex = "0 1 auto";
      dialogContent.style.maxHeight = "calc(100% - 96px)";
      dialogContent.style.display = "flex";
      dialogContent.style.flexDirection = "column";
      var deviceInfo = Apxor.getController().getDevInfo();
      var _Apxor$getController$ = Apxor.getController().getUserAttributes(),
        apx_browser = _Apxor$getController$.apx_browser;
      var hardware_model = deviceInfo.hardware_model,
        os_version = deviceInfo.os_version,
        id = deviceInfo.id;
      var styles = "<style>\n        .apx-loading{\n          background:#333 url('https://code.jquery.com/mobile/1.3.1/images/ajax-loader.gif') no-repeat 50% 50%;\n          -webkit-transition:background-color 0;transition:background-color 0;opacity: 1;\n          -webkit-transition:opacity 1;transition:opacity 1\n        }\n        .apx-t{\n          flex:0 0 auto;\n          margin:0;\n          padding:24px 24px 20px\n        }\n        .apx-tt{\n          color:rgba(0,72,114,0.87);\n          font-size:1.3125rem;\n          font-weight:500;\n          font-family: 'Roboto', 'Helvetica', 'Arial', sans-serif;\n          line-height: 1.16667em;\n          margin:0\n        }\n        .apx-c{\n          flex:1 1 auto;padding:0 24px 24px;overflow-y: auto\n        }\n        .apx-de{\n          line-height:1.5;color:rgba(0,72,114,0.54);font-size:1rem;font-weight:400;\n          font-family:\"Roboto\", \"Helvetica\", \"Arial\", sans-serif;margin:0;display:block\n        }\n        .apx-id{\n          width:100%;margin-top:8px;margin-bottom:4px;margin:0;border:0;flex-direction:column;\n          display:inline-flex;padding:0;position:relative;min-width:0;vertical-align:top\n        }\n        .apx-il{\n          transition:color 200ms cubic-bezier(0.0, 0, 0.2, 1) 0ms,transform 200ms cubic-bezier(0.0, 0, 0.2, 1) 0ms;\n          transform:translate(0, 21px) scale(1);top:0;left:0;position:absolute;\n          color:rgba(0,72,114, 0.54);padding: 0;font-size: 1rem;transform-origin:top left;\n          font-family: \"Roboto\", \"Helvetica\", \"Arial\", sans-serif;line-height: 1\n        }\n        .apx-il-f{\n          transform:translate(0, 1.5px) scale(0.75)\n        }\n        label + .apx-iid {\n          margin-top:16px;position:relative;width: 100%;color: rgba(0,72,114, 0.87);\n          cursor: text;display: inline-flex;font-size: 1rem;\n          font-family:\"Roboto\", \"Helvetica\", \"Arial\", sans-serif;\n          line-height: 1.1875em;align-items: center\n        }\n        .apx-iid.apx-iid-f:after{\n          transform:scaleX(1)\n        }\n        .apx-iid:hover:before{\n          border-bottom: 2px solid rgba(0,72,114, 0.87)\n        }\n        .apx-iid:before{\n          left: 0;right: 0;bottom: 0;content: '\\00a0';position: absolute;\n          transition: border-bottom-color 200ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;\n          border-bottom: 1px solid rgba(0, 0, 0, 0.42);pointer-events: none\n        }\n        .apx-iid:after{\n          left: 0;right: 0;bottom: 0;content: \"\";position: absolute;transform: scaleX(0);\n          transition: transform 200ms cubic-bezier(0.0, 0, 0.2, 1) 0ms;\n          border-bottom: 2px solid rgb(44, 56, 126);pointer-events: none\n        }\n        .apx-ii{\n          padding-top:3px;font: inherit;color: currentColor;width: 100%;border: 0;margin: 0;\n          display: block;min-width: 0;box-sizing: content-box;background: none;padding: 6px 0 7px;outline:0\n        }\n        .apx-ul{\n          padding-top:8px;padding-bottom:8px;margin:0;padding:0;position:relative;list-style:none\n        }\n        .apx-li{\n          padding-left:16px;padding-right:16px;width:100%;display:flex;list-style:none;\n          position:relative;box-sizing:border-box;text-align:left;align-items:center;\n          padding-top:11px;padding-bottom:11px;justify-content:flex-start;text-decoration:none\n        }\n        .apx-lid:first-child{\n          padding-left:0\n        }\n        .apx-lid{\n          flex:1 1 auto;padding:0 16px;min-width:0\n        }\n        .apx-lids{\n          color:rgba(0,72,114, 0.87);font-weight:400;line-height:1.5em;\n          font-family:\"Roboto\", \"Helvetica\", \"Arial\", sans-seriffont-size:1rem\n        }\n        .apx-a{\n          flex:0 0 auto;margin:8px 4px;display:flex;align-items:center;justify-content:flex-end\n        }\n        .apx-b{\n          font-size:0.875rem;min-width:64px;box-sizing:border-box;min-height:36px;border:0;\n          transition:background-color 250ms cubic-bezier(0.4, 0, 0.2, 1) 0ms,box-shadow 250ms cubic-bezier(0.4, 0, 0.2, 1) 0ms,border 250ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;\n          line-height:1.3125;font-weight:500;font-family:\"Roboto\", \"Helvetica\", \"Arial\", sans-serif;\n          border-radius:4px;text-transform:uppercase;cursor:pointer;display:inline-flex;outline:none;\n          position:relative;align-items:center;user-select:none;vertical-align:middle;\n          justify-content:center;text-decoration:none;background-color:transparent\n        }\n        .apx-bl{\n          width: 100%;display:inherit;align-items:inherit;justify-content:inherit\n        }\n        .apx-btr{\n          top:0;left:0;width:100%;height:100%;display:block;z-index:0;position:absolute;\n          overflow:hidden;border-radius:inherit;pointer-events:none\n        }\n      </style>\n    ";
      var html = "\n        ".concat(styles, "\n        <div>\n          <div class=\"apx-t\"><h2 class=\"apx-tt\">Set device nick name</h2></div>\n          <div class=\"apx-c\">\n            <p class=\"apx-de\">Give this device a nick name for easy identification</p>\n            <div class=\"apx-id\">\n              <label class=\"apx-il\">Nick name</label>\n              <div class=\"apx-iid\">\n                <input class=\"apx-ii\" type=\"text\" id=\"apx-ii\" value=\"\">\n              </div>\n            </div>\n            <ul class=\"apx-ul\">\n              <li class=\"apx-li\">\n                <div class=\"apx-lid\">\n                  <span class=\"apx-lids\">\n                    <span>Model <strong style=\"float:right\">").concat(hardware_model, " - ").concat(os_version, "</strong></span>\n                  </span>\n                </div>\n              </li>\n              <li class=\"apx-li\">\n                <div class=\"apx-lid\">\n                  <span class=\"apx-lids\">\n                    <span>Browser <strong style=\"float:right\">").concat(apx_browser, "</strong></span>\n                  </span>\n                </div>\n              </li>\n              <li class=\"apx-li\">\n                <div class=\"apx-lid\">\n                  <span class=\"apx-lids\">\n                    <span>Device ID <strong style=\"float:right\">").concat(id, "</strong></span>\n                  </span>\n                </div>\n              </li>\n            </ul>\n          </div>\n          <div class=\"apx-a\">\n          <button id=\"apx-bc\" class=\"apx-b\"><span class=\"apx-bl\" style=\"color:#295e8c6b\">Cancel</span><span class=\"apx-btr\"/></button>\n          <button id=\"apx-bd\" class=\"apx-b\"><span class=\"apx-bl\" style=\"color:#295e8c\">Done</span><span class=\"apx-btr\"/></button>\n          </div>\n        </div>\n    ");
      dialog.style.visibility = "hidden";
      dialogContent.style.visibility = "hidden";
      dialogContent.innerHTML = html;
      var input = document.getElementById("apx-ii");
      if (_this.testDeviceData) {
        var _this$testDeviceData$3, _this$testDeviceData2;
        input.value = (_this$testDeviceData$3 = (_this$testDeviceData2 = _this.testDeviceData) === null || _this$testDeviceData2 === void 0 ? void 0 : _this$testDeviceData2.name) !== null && _this$testDeviceData$3 !== void 0 ? _this$testDeviceData$3 : "";
      }
      input.onfocus = function () {
        input.parentNode.classList.add("apx-iid-f");
        input.parentNode.parentNode.children[0].classList.add("apx-il-f");
      };
      input.onblur = function () {
        input.parentNode.classList.remove("apx-iid-f");
        input.parentNode.parentNode.children[0].classList.remove("apx-il-f");
      };
      input.oninput = function () {
        if (input.value.trim() !== "") {
          done.removeAttribute("disabled");
        } else {
          done.setAttribute("disabled", "");
        }
      };

      // Show the dialog with some timeout to animate the dialog
      setTimeout(function () {
        dialog.style.visibility = "visible";
        dialogContent.style.visibility = "visible";
        dialogContent.classList.toggle("open");
        input.parentNode.parentNode.children[0].classList.add("apx-il-f");
      }, 100);
      var hideDialog = function hideDialog() {
        dialogContent.classList.toggle("open");
        setTimeout(function () {
          dialog.parentNode.removeChild(dialog);
        }, 400);
      };
      var cancel = document.getElementById("apx-bc");
      cancel.onclick = function () {
        hideDialog();
      };
      var done = document.getElementById("apx-bd");
      done.onclick = function () {
        // Make Add Test Device network request
        dialogContent.children[1].classList.add("apx-loading");
        Apxor.getController().makePostRequest(ADD_TEST_DEVICE_API.replace("<aid>", Apxor.getSiteId()), {
          model: hardware_model,
          id: id,
          nick_name: input.value
        }, {
          apx_web_key: "WTCKFAIVAJKYJA3HCV80WIKZU98R9NJG"
        }, function () {
          var newInfo = {
            id: id,
            name: input.value
          };
          Apxor.getController().persistToStorage("_apx_td", newInfo, true);
          _this.testDeviceData = newInfo;
          _this._makeSSERequest("select", "".concat(input.value, " - ").concat(id), id, function () {
            dialogContent.children[1].classList.remove("apx-loading");
            _this._wysiwygRoot.dispatchEvent(new CustomEvent("added"));
          });
          var previewEventSource = new EventSource(PREVIEW_API.replace("<aid>", Apxor.getSiteId()).replace("<uid>", id));
          var artConfigEventSource = new EventSource(CONFIG_API.replace("<aid>", Apxor.getSiteId()).replace("<uid>", id));
          previewEventSource.onmessage = artConfigEventSource.onmessage = function (e) {
            if (e && e.data && e.data !== "{}") {
              _this._handleSSEResponse(rtmInstance, e.data);
            }
          };
          hideDialog();
        }, function () {});
      };
    });
    /**
     * Helper SSE code to send the commands in a reusable way
     */
    _defineProperty$1(this, "_makeSSERequest", function (type, key1, key2) {
      var successCallback = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : function () {};
      var errorCallback = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : function () {};
      var deviceInfo = Apxor.getController().getDevInfo();
      var postBody = {
        device_info: {
          id: deviceInfo.id,
          hardware_model: deviceInfo.hardware_model,
          os_version: deviceInfo.os_version,
          width: deviceInfo.dimensions.width,
          height: deviceInfo.dimensions.height
        },
        screen: {
          image: type,
          navigation: key1,
          orientation: key2
        },
        layout: []
      };
      Apxor.getController().makePostRequest(LAYOUT_URL.replace("<aid>", Apxor.getSiteId()).replace("<uid>", _this._vid), postBody, {}, successCallback, errorCallback);
    });
    // Below 5 helper methods were grabbed from
    // https://chromium.googlesource.com/chromium/blink/+/refs/heads/main/Source/devtools/front_end/components/DOMPresentationUtils.js
    // Above URL has a bug, below is the URL with proper fix
    // https://github.com/ChromeDevTools/devtools-frontend/blob/master/front_end/panels/elements/DOMPath.ts
    _defineProperty$1(this, "cssPath", function (node, optimized) {
      if (node.nodeType !== Node.ELEMENT_NODE) return "";
      var steps = [];
      var contextNode = node;
      while (contextNode) {
        var step = _this._cssPathStep(contextNode, !!optimized, contextNode === node);
        if (!step) break; // Error - bail out early.
        steps.push(step);
        if (step.optimized) break;
        contextNode = contextNode.parentNode;
      }
      steps.reverse();
      return steps.join(" > ");
    });
    _defineProperty$1(this, "_cssPathStep", function (node, optimized, isTargetNode) {
      if (node.nodeType !== Node.ELEMENT_NODE) return null;
      var id = node.getAttribute("id");
      if (optimized) {
        if (id) return new DOMNodePathStep$1(idSelector(id), true);
        var nodeNameLower = node.nodeName.toLowerCase();
        if (nodeNameLower === "body" || nodeNameLower === "head" || nodeNameLower === "html") return new DOMNodePathStep$1(node.nodeName.toLowerCase(), true);
      }
      var nodeName = node.nodeName.toLowerCase();
      if (id) return new DOMNodePathStep$1(nodeName.toLowerCase() + idSelector(id), true);
      var parent = node.parentNode;
      if (!parent || parent.nodeType === Node.DOCUMENT_NODE) return new DOMNodePathStep$1(nodeName.toLowerCase(), true);
      function prefixedElementClassNames(node) {
        var classAttribute = node.getAttribute("class");
        if (!classAttribute) return [];
        return classAttribute.split(/\s+/g).filter(Boolean).map(function (name) {
          // The prefix is required to store "__proto__" in a object-based map.
          return "$" + name;
        });
      }
      function idSelector(id) {
        return "#" + escapeIdentifierIfNeeded(id);
      }
      function escapeIdentifierIfNeeded(ident) {
        if (isCSSIdentifier(ident)) return ident;
        var shouldEscapeFirst = /^(?:[0-9]|-[0-9-]?)/.test(ident);
        var lastIndex = ident.length - 1;
        return ident.replace(/./g, function (c, i) {
          return shouldEscapeFirst && i === 0 || !isCSSIdentChar(c) ? escapeAsciiChar(c, i === lastIndex) : c;
        });
      }
      function escapeAsciiChar(c, isLast) {
        return "\\" + toHexByte(c) + (isLast ? "" : " ");
      }
      function toHexByte(c) {
        var hexByte = c.charCodeAt(0).toString(16);
        if (hexByte.length === 1) hexByte = "0" + hexByte;
        return hexByte;
      }
      function isCSSIdentChar(c) {
        if (/[a-zA-Z0-9_-]/.test(c)) return true;
        return c.charCodeAt(0) >= 0xa0;
      }
      function isCSSIdentifier(value) {
        return /^-?[a-zA-Z_][a-zA-Z0-9_-]*$/.test(value);
      }
      var prefixedOwnClassNamesArray = prefixedElementClassNames(node);
      var needsClassNames = false;
      var needsNthChild = false;
      var ownIndex = -1;
      var elementIndex = -1;
      var siblings = parent.children;
      for (var i = 0; (ownIndex === -1 || !needsNthChild) && i < siblings.length; ++i) {
        var sibling = siblings[i];
        if (sibling.nodeType !== Node.ELEMENT_NODE) continue;
        elementIndex += 1;
        if (sibling === node) {
          ownIndex = elementIndex;
          continue;
        }
        if (needsNthChild) continue;
        if (sibling.nodeName.toLowerCase() !== nodeName.toLowerCase()) continue;
        needsClassNames = true;
        var ownClassNames = new Set(prefixedOwnClassNamesArray);
        if (!ownClassNames.size) {
          needsNthChild = true;
          continue;
        }
        var siblingClassNamesArray = prefixedElementClassNames(sibling);
        for (var j = 0; j < siblingClassNamesArray.length; ++j) {
          var siblingClass = siblingClassNamesArray[j];
          if (!ownClassNames.has(siblingClass)) continue;
          ownClassNames["delete"](siblingClass);
          if (!ownClassNames.size) {
            needsNthChild = true;
            break;
          }
        }
      }
      var result = nodeName.toLowerCase();
      if (isTargetNode && nodeName.toLowerCase() === "input" && node.getAttribute("type") && !node.getAttribute("id") && !node.getAttribute("class")) result += '[type="' + node.getAttribute("type") + '"]';
      if (needsNthChild) {
        result += ":nth-child(" + (ownIndex + 1) + ")";
      } else if (needsClassNames) {
        for (var prefixedName in prefixedOwnClassNamesArray) result += "." + escapeIdentifierIfNeeded(prefixedOwnClassNamesArray[prefixedName].substr(1));
      }
      return new DOMNodePathStep$1(result, false);
    });
    _defineProperty$1(this, "xPath", function (node, optimized) {
      if (node.nodeType === Node.DOCUMENT_NODE) return "/";
      var steps = [];
      var contextNode = node;
      while (contextNode) {
        var step = _this._xPathValue(contextNode, optimized);
        if (!step) break; // Error - bail out early.
        steps.push(step);
        if (step.optimized) break;
        contextNode = contextNode.parentNode;
      }
      steps.reverse();
      return (steps.length && steps[0].optimized ? "" : "/") + steps.join("/");
    });
    _defineProperty$1(this, "_xPathValue", function (node, optimized) {
      var ownValue;
      var ownIndex = _this._xPathIndex(node);
      if (ownIndex === -1) return null; // Error.
      switch (node.nodeType) {
        case Node.ELEMENT_NODE:
          if (optimized && node.getAttribute("id")) return new DOMNodePathStep$1('//*[@id="' + node.getAttribute("id") + '"]', true);
          ownValue = node.localName;
          break;
        case Node.ATTRIBUTE_NODE:
          ownValue = "@" + node.nodeName;
          break;
        case Node.TEXT_NODE:
        case Node.CDATA_SECTION_NODE:
          ownValue = "text()";
          break;
        case Node.PROCESSING_INSTRUCTION_NODE:
          ownValue = "processing-instruction()";
          break;
        case Node.COMMENT_NODE:
          ownValue = "comment()";
          break;
        case Node.DOCUMENT_NODE:
          ownValue = "";
          break;
        default:
          ownValue = "";
          break;
      }
      if (ownIndex > 0) ownValue += "[" + ownIndex + "]";
      return new DOMNodePathStep$1(ownValue, node.nodeType === Node.DOCUMENT_NODE);
    });
    _defineProperty$1(this, "_xPathIndex", function (node) {
      // Returns -1 in case of error, 0 if no siblings matching the same expression, <XPath index among the same expression-matching sibling nodes> otherwise.
      function areNodesSimilar(left, right) {
        if (left === right) return true;
        if (left.nodeType === Node.ELEMENT_NODE && right.nodeType === Node.ELEMENT_NODE) return left.localName === right.localName;
        if (left.nodeType === right.nodeType) return true;
        // XPath treats CDATA as text nodes.
        var leftType = left.nodeType === Node.CDATA_SECTION_NODE ? Node.TEXT_NODE : left.nodeType;
        var rightType = right.nodeType === Node.CDATA_SECTION_NODE ? Node.TEXT_NODE : right.nodeType;
        return leftType === rightType;
      }
      var siblings = node.parentNode ? node.parentNode.children : null;
      if (!siblings) return 0; // Root node - no siblings.
      var hasSameNamedElements;
      for (var i = 0; i < siblings.length; ++i) {
        if (areNodesSimilar(node, siblings[i]) && siblings[i] !== node) {
          hasSameNamedElements = true;
          break;
        }
      }
      if (!hasSameNamedElements) return 0;
      var ownIndex = 1; // XPath indices start with 1.
      for (var j = 0; j < siblings.length; ++j) {
        if (areNodesSimilar(node, siblings[j])) {
          if (siblings[j] === node) return ownIndex;
          ++ownIndex;
        }
      }
      return -1; // An error occurred: |node| not found in parent's children.
    });
    this.result = null;
  });
  var DOMNodePathStep$1 = function DOMNodePathStep(value, optimized) {
    this.value = value;
    this.optimized = optimized || false;
  };
  DOMNodePathStep$1.prototype = {
    toString: function toString() {
      return this.value;
    }
  };

  var top = 'top';
  var bottom = 'bottom';
  var right = 'right';
  var left = 'left';
  var auto = 'auto';
  var basePlacements = [top, bottom, right, left];
  var start = 'start';
  var end = 'end';
  var clippingParents = 'clippingParents';
  var viewport = 'viewport';
  var popper = 'popper';
  var reference = 'reference';
  var variationPlacements = /*#__PURE__*/basePlacements.reduce(function (acc, placement) {
    return acc.concat([placement + "-" + start, placement + "-" + end]);
  }, []);
  var placements = /*#__PURE__*/[].concat(basePlacements, [auto]).reduce(function (acc, placement) {
    return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
  }, []); // modifiers that need to read the DOM

  var beforeRead = 'beforeRead';
  var read = 'read';
  var afterRead = 'afterRead'; // pure-logic modifiers

  var beforeMain = 'beforeMain';
  var main = 'main';
  var afterMain = 'afterMain'; // modifier with the purpose to write to the DOM (or write into a framework state)

  var beforeWrite = 'beforeWrite';
  var write = 'write';
  var afterWrite = 'afterWrite';
  var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];

  function getNodeName(element) {
    return element ? (element.nodeName || '').toLowerCase() : null;
  }

  function getWindow(node) {
    if (node == null) {
      return window;
    }
    if (node.toString() !== '[object Window]') {
      var ownerDocument = node.ownerDocument;
      return ownerDocument ? ownerDocument.defaultView || window : window;
    }
    return node;
  }

  function isElement$1(node) {
    var OwnElement = getWindow(node).Element;
    return node instanceof OwnElement || node instanceof Element;
  }
  function isHTMLElement(node) {
    var OwnElement = getWindow(node).HTMLElement;
    return node instanceof OwnElement || node instanceof HTMLElement;
  }
  function isShadowRoot(node) {
    // IE 11 has no ShadowRoot
    if (typeof ShadowRoot === 'undefined') {
      return false;
    }
    var OwnElement = getWindow(node).ShadowRoot;
    return node instanceof OwnElement || node instanceof ShadowRoot;
  }

  // and applies them to the HTMLElements such as popper and arrow

  function applyStyles(_ref) {
    var state = _ref.state;
    Object.keys(state.elements).forEach(function (name) {
      var style = state.styles[name] || {};
      var attributes = state.attributes[name] || {};
      var element = state.elements[name]; // arrow is optional + virtual elements

      if (!isHTMLElement(element) || !getNodeName(element)) {
        return;
      } // Flow doesn't support to extend this property, but it's the most
      // effective way to apply styles to an HTMLElement
      // $FlowFixMe[cannot-write]

      Object.assign(element.style, style);
      Object.keys(attributes).forEach(function (name) {
        var value = attributes[name];
        if (value === false) {
          element.removeAttribute(name);
        } else {
          element.setAttribute(name, value === true ? '' : value);
        }
      });
    });
  }
  function effect$2(_ref2) {
    var state = _ref2.state;
    var initialStyles = {
      popper: {
        position: state.options.strategy,
        left: '0',
        top: '0',
        margin: '0'
      },
      arrow: {
        position: 'absolute'
      },
      reference: {}
    };
    Object.assign(state.elements.popper.style, initialStyles.popper);
    state.styles = initialStyles;
    if (state.elements.arrow) {
      Object.assign(state.elements.arrow.style, initialStyles.arrow);
    }
    return function () {
      Object.keys(state.elements).forEach(function (name) {
        var element = state.elements[name];
        var attributes = state.attributes[name] || {};
        var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]); // Set all values to an empty string to unset them

        var style = styleProperties.reduce(function (style, property) {
          style[property] = '';
          return style;
        }, {}); // arrow is optional + virtual elements

        if (!isHTMLElement(element) || !getNodeName(element)) {
          return;
        }
        Object.assign(element.style, style);
        Object.keys(attributes).forEach(function (attribute) {
          element.removeAttribute(attribute);
        });
      });
    };
  } // eslint-disable-next-line import/no-unused-modules

  var applyStyles$1 = {
    name: 'applyStyles',
    enabled: true,
    phase: 'write',
    fn: applyStyles,
    effect: effect$2,
    requires: ['computeStyles']
  };

  function getBasePlacement$1(placement) {
    return placement.split('-')[0];
  }

  var max = Math.max;
  var min = Math.min;
  var round = Math.round;

  function getUAString() {
    var uaData = navigator.userAgentData;
    if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {
      return uaData.brands.map(function (item) {
        return item.brand + "/" + item.version;
      }).join(' ');
    }
    return navigator.userAgent;
  }

  function isLayoutViewport() {
    return !/^((?!chrome|android).)*safari/i.test(getUAString());
  }

  function getBoundingClientRect(element, includeScale, isFixedStrategy) {
    if (includeScale === void 0) {
      includeScale = false;
    }
    if (isFixedStrategy === void 0) {
      isFixedStrategy = false;
    }
    var clientRect = element.getBoundingClientRect();
    var scaleX = 1;
    var scaleY = 1;
    if (includeScale && isHTMLElement(element)) {
      scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;
      scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;
    }
    var _ref = isElement$1(element) ? getWindow(element) : window,
      visualViewport = _ref.visualViewport;
    var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
    var x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
    var y = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
    var width = clientRect.width / scaleX;
    var height = clientRect.height / scaleY;
    return {
      width: width,
      height: height,
      top: y,
      right: x + width,
      bottom: y + height,
      left: x,
      x: x,
      y: y
    };
  }

  // means it doesn't take into account transforms.

  function getLayoutRect(element) {
    var clientRect = getBoundingClientRect(element); // Use the clientRect sizes if it's not been transformed.
    // Fixes https://github.com/popperjs/popper-core/issues/1223

    var width = element.offsetWidth;
    var height = element.offsetHeight;
    if (Math.abs(clientRect.width - width) <= 1) {
      width = clientRect.width;
    }
    if (Math.abs(clientRect.height - height) <= 1) {
      height = clientRect.height;
    }
    return {
      x: element.offsetLeft,
      y: element.offsetTop,
      width: width,
      height: height
    };
  }

  function contains(parent, child) {
    var rootNode = child.getRootNode && child.getRootNode(); // First, attempt with faster native method

    if (parent.contains(child)) {
      return true;
    } // then fallback to custom implementation with Shadow DOM support
    else if (rootNode && isShadowRoot(rootNode)) {
      var next = child;
      do {
        if (next && parent.isSameNode(next)) {
          return true;
        } // $FlowFixMe[prop-missing]: need a better way to handle this...

        next = next.parentNode || next.host;
      } while (next);
    } // Give up, the result is false

    return false;
  }

  function getComputedStyle$1(element) {
    return getWindow(element).getComputedStyle(element);
  }

  function isTableElement(element) {
    return ['table', 'td', 'th'].indexOf(getNodeName(element)) >= 0;
  }

  function getDocumentElement(element) {
    // $FlowFixMe[incompatible-return]: assume body is always available
    return ((isElement$1(element) ? element.ownerDocument :
    // $FlowFixMe[prop-missing]
    element.document) || window.document).documentElement;
  }

  function getParentNode(element) {
    if (getNodeName(element) === 'html') {
      return element;
    }
    return (
      // this is a quicker (but less type safe) way to save quite some bytes from the bundle
      // $FlowFixMe[incompatible-return]
      // $FlowFixMe[prop-missing]
      element.assignedSlot ||
      // step into the shadow DOM of the parent of a slotted node
      element.parentNode || (
      // DOM Element detected
      isShadowRoot(element) ? element.host : null) ||
      // ShadowRoot detected
      // $FlowFixMe[incompatible-call]: HTMLElement is a Node
      getDocumentElement(element) // fallback
    );
  }

  function getTrueOffsetParent(element) {
    if (!isHTMLElement(element) ||
    // https://github.com/popperjs/popper-core/issues/837
    getComputedStyle$1(element).position === 'fixed') {
      return null;
    }
    return element.offsetParent;
  } // `.offsetParent` reports `null` for fixed elements, while absolute elements
  // return the containing block

  function getContainingBlock(element) {
    var isFirefox = /firefox/i.test(getUAString());
    var isIE = /Trident/i.test(getUAString());
    if (isIE && isHTMLElement(element)) {
      // In IE 9, 10 and 11 fixed elements containing block is always established by the viewport
      var elementCss = getComputedStyle$1(element);
      if (elementCss.position === 'fixed') {
        return null;
      }
    }
    var currentNode = getParentNode(element);
    if (isShadowRoot(currentNode)) {
      currentNode = currentNode.host;
    }
    while (isHTMLElement(currentNode) && ['html', 'body'].indexOf(getNodeName(currentNode)) < 0) {
      var css = getComputedStyle$1(currentNode); // This is non-exhaustive but covers the most common CSS properties that
      // create a containing block.
      // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block

      if (css.transform !== 'none' || css.perspective !== 'none' || css.contain === 'paint' || ['transform', 'perspective'].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === 'filter' || isFirefox && css.filter && css.filter !== 'none') {
        return currentNode;
      } else {
        currentNode = currentNode.parentNode;
      }
    }
    return null;
  } // Gets the closest ancestor positioned element. Handles some edge cases,
  // such as table ancestors and cross browser bugs.

  function getOffsetParent(element) {
    var window = getWindow(element);
    var offsetParent = getTrueOffsetParent(element);
    while (offsetParent && isTableElement(offsetParent) && getComputedStyle$1(offsetParent).position === 'static') {
      offsetParent = getTrueOffsetParent(offsetParent);
    }
    if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle$1(offsetParent).position === 'static')) {
      return window;
    }
    return offsetParent || getContainingBlock(element) || window;
  }

  function getMainAxisFromPlacement(placement) {
    return ['top', 'bottom'].indexOf(placement) >= 0 ? 'x' : 'y';
  }

  function within(min$1, value, max$1) {
    return max(min$1, min(value, max$1));
  }
  function withinMaxClamp(min, value, max) {
    var v = within(min, value, max);
    return v > max ? max : v;
  }

  function getFreshSideObject() {
    return {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    };
  }

  function mergePaddingObject(paddingObject) {
    return Object.assign({}, getFreshSideObject(), paddingObject);
  }

  function expandToHashMap(value, keys) {
    return keys.reduce(function (hashMap, key) {
      hashMap[key] = value;
      return hashMap;
    }, {});
  }

  var toPaddingObject = function toPaddingObject(padding, state) {
    padding = typeof padding === 'function' ? padding(Object.assign({}, state.rects, {
      placement: state.placement
    })) : padding;
    return mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));
  };
  function arrow(_ref) {
    var _state$modifiersData$;
    var state = _ref.state,
      name = _ref.name,
      options = _ref.options;
    var arrowElement = state.elements.arrow;
    var popperOffsets = state.modifiersData.popperOffsets;
    var basePlacement = getBasePlacement$1(state.placement);
    var axis = getMainAxisFromPlacement(basePlacement);
    var isVertical = [left, right].indexOf(basePlacement) >= 0;
    var len = isVertical ? 'height' : 'width';
    if (!arrowElement || !popperOffsets) {
      return;
    }
    var paddingObject = toPaddingObject(options.padding, state);
    var arrowRect = getLayoutRect(arrowElement);
    var minProp = axis === 'y' ? top : left;
    var maxProp = axis === 'y' ? bottom : right;
    var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];
    var startDiff = popperOffsets[axis] - state.rects.reference[axis];
    var arrowOffsetParent = getOffsetParent(arrowElement);
    var clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
    var centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the popper if the center point is
    // outside of the popper bounds

    var min = paddingObject[minProp];
    var max = clientSize - arrowRect[len] - paddingObject[maxProp];
    var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
    var offset = within(min, center, max); // Prevents breaking syntax highlighting...

    var axisProp = axis;
    state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset, _state$modifiersData$.centerOffset = offset - center, _state$modifiersData$);
  }
  function effect$1(_ref2) {
    var state = _ref2.state,
      options = _ref2.options;
    var _options$element = options.element,
      arrowElement = _options$element === void 0 ? '[data-popper-arrow]' : _options$element;
    if (arrowElement == null) {
      return;
    } // CSS selector

    if (typeof arrowElement === 'string') {
      arrowElement = state.elements.popper.querySelector(arrowElement);
      if (!arrowElement) {
        return;
      }
    }
    if (!contains(state.elements.popper, arrowElement)) {
      return;
    }
    state.elements.arrow = arrowElement;
  } // eslint-disable-next-line import/no-unused-modules

  var arrow$1 = {
    name: 'arrow',
    enabled: true,
    phase: 'main',
    fn: arrow,
    effect: effect$1,
    requires: ['popperOffsets'],
    requiresIfExists: ['preventOverflow']
  };

  function getVariation(placement) {
    return placement.split('-')[1];
  }

  var unsetSides = {
    top: 'auto',
    right: 'auto',
    bottom: 'auto',
    left: 'auto'
  }; // Round the offsets to the nearest suitable subpixel based on the DPR.
  // Zooming can change the DPR, but it seems to report a value that will
  // cleanly divide the values into the appropriate subpixels.

  function roundOffsetsByDPR(_ref, win) {
    var x = _ref.x,
      y = _ref.y;
    var dpr = win.devicePixelRatio || 1;
    return {
      x: round(x * dpr) / dpr || 0,
      y: round(y * dpr) / dpr || 0
    };
  }
  function mapToStyles(_ref2) {
    var _Object$assign2;
    var popper = _ref2.popper,
      popperRect = _ref2.popperRect,
      placement = _ref2.placement,
      variation = _ref2.variation,
      offsets = _ref2.offsets,
      position = _ref2.position,
      gpuAcceleration = _ref2.gpuAcceleration,
      adaptive = _ref2.adaptive,
      roundOffsets = _ref2.roundOffsets,
      isFixed = _ref2.isFixed;
    var _offsets$x = offsets.x,
      x = _offsets$x === void 0 ? 0 : _offsets$x,
      _offsets$y = offsets.y,
      y = _offsets$y === void 0 ? 0 : _offsets$y;
    var _ref3 = typeof roundOffsets === 'function' ? roundOffsets({
      x: x,
      y: y
    }) : {
      x: x,
      y: y
    };
    x = _ref3.x;
    y = _ref3.y;
    var hasX = offsets.hasOwnProperty('x');
    var hasY = offsets.hasOwnProperty('y');
    var sideX = left;
    var sideY = top;
    var win = window;
    if (adaptive) {
      var offsetParent = getOffsetParent(popper);
      var heightProp = 'clientHeight';
      var widthProp = 'clientWidth';
      if (offsetParent === getWindow(popper)) {
        offsetParent = getDocumentElement(popper);
        if (getComputedStyle$1(offsetParent).position !== 'static' && position === 'absolute') {
          heightProp = 'scrollHeight';
          widthProp = 'scrollWidth';
        }
      } // $FlowFixMe[incompatible-cast]: force type refinement, we compare offsetParent with window above, but Flow doesn't detect it

      offsetParent = offsetParent;
      if (placement === top || (placement === left || placement === right) && variation === end) {
        sideY = bottom;
        var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height :
        // $FlowFixMe[prop-missing]
        offsetParent[heightProp];
        y -= offsetY - popperRect.height;
        y *= gpuAcceleration ? 1 : -1;
      }
      if (placement === left || (placement === top || placement === bottom) && variation === end) {
        sideX = right;
        var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width :
        // $FlowFixMe[prop-missing]
        offsetParent[widthProp];
        x -= offsetX - popperRect.width;
        x *= gpuAcceleration ? 1 : -1;
      }
    }
    var commonStyles = Object.assign({
      position: position
    }, adaptive && unsetSides);
    var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
      x: x,
      y: y
    }, getWindow(popper)) : {
      x: x,
      y: y
    };
    x = _ref4.x;
    y = _ref4.y;
    if (gpuAcceleration) {
      var _Object$assign;
      return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? '0' : '', _Object$assign[sideX] = hasX ? '0' : '', _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
    }
    return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : '', _Object$assign2[sideX] = hasX ? x + "px" : '', _Object$assign2.transform = '', _Object$assign2));
  }
  function computeStyles(_ref5) {
    var state = _ref5.state,
      options = _ref5.options;
    var _options$gpuAccelerat = options.gpuAcceleration,
      gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat,
      _options$adaptive = options.adaptive,
      adaptive = _options$adaptive === void 0 ? true : _options$adaptive,
      _options$roundOffsets = options.roundOffsets,
      roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
    var commonStyles = {
      placement: getBasePlacement$1(state.placement),
      variation: getVariation(state.placement),
      popper: state.elements.popper,
      popperRect: state.rects.popper,
      gpuAcceleration: gpuAcceleration,
      isFixed: state.options.strategy === 'fixed'
    };
    if (state.modifiersData.popperOffsets != null) {
      state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
        offsets: state.modifiersData.popperOffsets,
        position: state.options.strategy,
        adaptive: adaptive,
        roundOffsets: roundOffsets
      })));
    }
    if (state.modifiersData.arrow != null) {
      state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
        offsets: state.modifiersData.arrow,
        position: 'absolute',
        adaptive: false,
        roundOffsets: roundOffsets
      })));
    }
    state.attributes.popper = Object.assign({}, state.attributes.popper, {
      'data-popper-placement': state.placement
    });
  } // eslint-disable-next-line import/no-unused-modules

  var computeStyles$1 = {
    name: 'computeStyles',
    enabled: true,
    phase: 'beforeWrite',
    fn: computeStyles,
    data: {}
  };

  var passive = {
    passive: true
  };
  function effect(_ref) {
    var state = _ref.state,
      instance = _ref.instance,
      options = _ref.options;
    var _options$scroll = options.scroll,
      scroll = _options$scroll === void 0 ? true : _options$scroll,
      _options$resize = options.resize,
      resize = _options$resize === void 0 ? true : _options$resize;
    var window = getWindow(state.elements.popper);
    var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
    if (scroll) {
      scrollParents.forEach(function (scrollParent) {
        scrollParent.addEventListener('scroll', instance.update, passive);
      });
    }
    if (resize) {
      window.addEventListener('resize', instance.update, passive);
    }
    return function () {
      if (scroll) {
        scrollParents.forEach(function (scrollParent) {
          scrollParent.removeEventListener('scroll', instance.update, passive);
        });
      }
      if (resize) {
        window.removeEventListener('resize', instance.update, passive);
      }
    };
  } // eslint-disable-next-line import/no-unused-modules

  var eventListeners = {
    name: 'eventListeners',
    enabled: true,
    phase: 'write',
    fn: function fn() {},
    effect: effect,
    data: {}
  };

  var hash$1 = {
    left: 'right',
    right: 'left',
    bottom: 'top',
    top: 'bottom'
  };
  function getOppositePlacement(placement) {
    return placement.replace(/left|right|bottom|top/g, function (matched) {
      return hash$1[matched];
    });
  }

  var hash = {
    start: 'end',
    end: 'start'
  };
  function getOppositeVariationPlacement(placement) {
    return placement.replace(/start|end/g, function (matched) {
      return hash[matched];
    });
  }

  function getWindowScroll(node) {
    var win = getWindow(node);
    var scrollLeft = win.pageXOffset;
    var scrollTop = win.pageYOffset;
    return {
      scrollLeft: scrollLeft,
      scrollTop: scrollTop
    };
  }

  function getWindowScrollBarX(element) {
    // If <html> has a CSS width greater than the viewport, then this will be
    // incorrect for RTL.
    // Popper 1 is broken in this case and never had a bug report so let's assume
    // it's not an issue. I don't think anyone ever specifies width on <html>
    // anyway.
    // Browsers where the left scrollbar doesn't cause an issue report `0` for
    // this (e.g. Edge 2019, IE11, Safari)
    return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
  }

  function getViewportRect(element, strategy) {
    var win = getWindow(element);
    var html = getDocumentElement(element);
    var visualViewport = win.visualViewport;
    var width = html.clientWidth;
    var height = html.clientHeight;
    var x = 0;
    var y = 0;
    if (visualViewport) {
      width = visualViewport.width;
      height = visualViewport.height;
      var layoutViewport = isLayoutViewport();
      if (layoutViewport || !layoutViewport && strategy === 'fixed') {
        x = visualViewport.offsetLeft;
        y = visualViewport.offsetTop;
      }
    }
    return {
      width: width,
      height: height,
      x: x + getWindowScrollBarX(element),
      y: y
    };
  }

  // of the `<html>` and `<body>` rect bounds if horizontally scrollable

  function getDocumentRect(element) {
    var _element$ownerDocumen;
    var html = getDocumentElement(element);
    var winScroll = getWindowScroll(element);
    var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
    var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
    var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
    var x = -winScroll.scrollLeft + getWindowScrollBarX(element);
    var y = -winScroll.scrollTop;
    if (getComputedStyle$1(body || html).direction === 'rtl') {
      x += max(html.clientWidth, body ? body.clientWidth : 0) - width;
    }
    return {
      width: width,
      height: height,
      x: x,
      y: y
    };
  }

  function isScrollParent(element) {
    // Firefox wants us to check `-x` and `-y` variations as well
    var _getComputedStyle = getComputedStyle$1(element),
      overflow = _getComputedStyle.overflow,
      overflowX = _getComputedStyle.overflowX,
      overflowY = _getComputedStyle.overflowY;
    return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
  }

  function getScrollParent(node) {
    if (['html', 'body', '#document'].indexOf(getNodeName(node)) >= 0) {
      // $FlowFixMe[incompatible-return]: assume body is always available
      return node.ownerDocument.body;
    }
    if (isHTMLElement(node) && isScrollParent(node)) {
      return node;
    }
    return getScrollParent(getParentNode(node));
  }

  /*
  given a DOM element, return the list of all scroll parents, up the list of ancesors
  until we get to the top window object. This list is what we attach scroll listeners
  to, because if any of these parent elements scroll, we'll need to re-calculate the
  reference element's position.
  */

  function listScrollParents(element, list) {
    var _element$ownerDocumen;
    if (list === void 0) {
      list = [];
    }
    var scrollParent = getScrollParent(element);
    var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
    var win = getWindow(scrollParent);
    var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
    var updatedList = list.concat(target);
    return isBody ? updatedList :
    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
    updatedList.concat(listScrollParents(getParentNode(target)));
  }

  function rectToClientRect(rect) {
    return Object.assign({}, rect, {
      left: rect.x,
      top: rect.y,
      right: rect.x + rect.width,
      bottom: rect.y + rect.height
    });
  }

  function getInnerBoundingClientRect(element, strategy) {
    var rect = getBoundingClientRect(element, false, strategy === 'fixed');
    rect.top = rect.top + element.clientTop;
    rect.left = rect.left + element.clientLeft;
    rect.bottom = rect.top + element.clientHeight;
    rect.right = rect.left + element.clientWidth;
    rect.width = element.clientWidth;
    rect.height = element.clientHeight;
    rect.x = rect.left;
    rect.y = rect.top;
    return rect;
  }
  function getClientRectFromMixedType(element, clippingParent, strategy) {
    return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement$1(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
  } // A "clipping parent" is an overflowable container with the characteristic of
  // clipping (or hiding) overflowing elements with a position different from
  // `initial`

  function getClippingParents(element) {
    var clippingParents = listScrollParents(getParentNode(element));
    var canEscapeClipping = ['absolute', 'fixed'].indexOf(getComputedStyle$1(element).position) >= 0;
    var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
    if (!isElement$1(clipperElement)) {
      return [];
    } // $FlowFixMe[incompatible-return]: https://github.com/facebook/flow/issues/1414

    return clippingParents.filter(function (clippingParent) {
      return isElement$1(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== 'body';
    });
  } // Gets the maximum area that the element is visible in due to any number of
  // clipping parents

  function getClippingRect(element, boundary, rootBoundary, strategy) {
    var mainClippingParents = boundary === 'clippingParents' ? getClippingParents(element) : [].concat(boundary);
    var clippingParents = [].concat(mainClippingParents, [rootBoundary]);
    var firstClippingParent = clippingParents[0];
    var clippingRect = clippingParents.reduce(function (accRect, clippingParent) {
      var rect = getClientRectFromMixedType(element, clippingParent, strategy);
      accRect.top = max(rect.top, accRect.top);
      accRect.right = min(rect.right, accRect.right);
      accRect.bottom = min(rect.bottom, accRect.bottom);
      accRect.left = max(rect.left, accRect.left);
      return accRect;
    }, getClientRectFromMixedType(element, firstClippingParent, strategy));
    clippingRect.width = clippingRect.right - clippingRect.left;
    clippingRect.height = clippingRect.bottom - clippingRect.top;
    clippingRect.x = clippingRect.left;
    clippingRect.y = clippingRect.top;
    return clippingRect;
  }

  function computeOffsets(_ref) {
    var reference = _ref.reference,
      element = _ref.element,
      placement = _ref.placement;
    var basePlacement = placement ? getBasePlacement$1(placement) : null;
    var variation = placement ? getVariation(placement) : null;
    var commonX = reference.x + reference.width / 2 - element.width / 2;
    var commonY = reference.y + reference.height / 2 - element.height / 2;
    var offsets;
    switch (basePlacement) {
      case top:
        offsets = {
          x: commonX,
          y: reference.y - element.height
        };
        break;
      case bottom:
        offsets = {
          x: commonX,
          y: reference.y + reference.height
        };
        break;
      case right:
        offsets = {
          x: reference.x + reference.width,
          y: commonY
        };
        break;
      case left:
        offsets = {
          x: reference.x - element.width,
          y: commonY
        };
        break;
      default:
        offsets = {
          x: reference.x,
          y: reference.y
        };
    }
    var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
    if (mainAxis != null) {
      var len = mainAxis === 'y' ? 'height' : 'width';
      switch (variation) {
        case start:
          offsets[mainAxis] = offsets[mainAxis] - (reference[len] / 2 - element[len] / 2);
          break;
        case end:
          offsets[mainAxis] = offsets[mainAxis] + (reference[len] / 2 - element[len] / 2);
          break;
      }
    }
    return offsets;
  }

  function detectOverflow(state, options) {
    if (options === void 0) {
      options = {};
    }
    var _options = options,
      _options$placement = _options.placement,
      placement = _options$placement === void 0 ? state.placement : _options$placement,
      _options$strategy = _options.strategy,
      strategy = _options$strategy === void 0 ? state.strategy : _options$strategy,
      _options$boundary = _options.boundary,
      boundary = _options$boundary === void 0 ? clippingParents : _options$boundary,
      _options$rootBoundary = _options.rootBoundary,
      rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary,
      _options$elementConte = _options.elementContext,
      elementContext = _options$elementConte === void 0 ? popper : _options$elementConte,
      _options$altBoundary = _options.altBoundary,
      altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary,
      _options$padding = _options.padding,
      padding = _options$padding === void 0 ? 0 : _options$padding;
    var paddingObject = mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));
    var altContext = elementContext === popper ? reference : popper;
    var popperRect = state.rects.popper;
    var element = state.elements[altBoundary ? altContext : elementContext];
    var clippingClientRect = getClippingRect(isElement$1(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);
    var referenceClientRect = getBoundingClientRect(state.elements.reference);
    var popperOffsets = computeOffsets({
      reference: referenceClientRect,
      element: popperRect,
      strategy: 'absolute',
      placement: placement
    });
    var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets));
    var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect; // positive = overflowing the clipping rect
    // 0 or negative = within the clipping rect

    var overflowOffsets = {
      top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
      bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
      left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
      right: elementClientRect.right - clippingClientRect.right + paddingObject.right
    };
    var offsetData = state.modifiersData.offset; // Offsets can be applied only to the popper element

    if (elementContext === popper && offsetData) {
      var offset = offsetData[placement];
      Object.keys(overflowOffsets).forEach(function (key) {
        var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
        var axis = [top, bottom].indexOf(key) >= 0 ? 'y' : 'x';
        overflowOffsets[key] += offset[axis] * multiply;
      });
    }
    return overflowOffsets;
  }

  function computeAutoPlacement(state, options) {
    if (options === void 0) {
      options = {};
    }
    var _options = options,
      placement = _options.placement,
      boundary = _options.boundary,
      rootBoundary = _options.rootBoundary,
      padding = _options.padding,
      flipVariations = _options.flipVariations,
      _options$allowedAutoP = _options.allowedAutoPlacements,
      allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
    var variation = getVariation(placement);
    var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function (placement) {
      return getVariation(placement) === variation;
    }) : basePlacements;
    var allowedPlacements = placements$1.filter(function (placement) {
      return allowedAutoPlacements.indexOf(placement) >= 0;
    });
    if (allowedPlacements.length === 0) {
      allowedPlacements = placements$1;
    } // $FlowFixMe[incompatible-type]: Flow seems to have problems with two array unions...

    var overflows = allowedPlacements.reduce(function (acc, placement) {
      acc[placement] = detectOverflow(state, {
        placement: placement,
        boundary: boundary,
        rootBoundary: rootBoundary,
        padding: padding
      })[getBasePlacement$1(placement)];
      return acc;
    }, {});
    return Object.keys(overflows).sort(function (a, b) {
      return overflows[a] - overflows[b];
    });
  }

  function getExpandedFallbackPlacements(placement) {
    if (getBasePlacement$1(placement) === auto) {
      return [];
    }
    var oppositePlacement = getOppositePlacement(placement);
    return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
  }
  function flip(_ref) {
    var state = _ref.state,
      options = _ref.options,
      name = _ref.name;
    if (state.modifiersData[name]._skip) {
      return;
    }
    var _options$mainAxis = options.mainAxis,
      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
      _options$altAxis = options.altAxis,
      checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis,
      specifiedFallbackPlacements = options.fallbackPlacements,
      padding = options.padding,
      boundary = options.boundary,
      rootBoundary = options.rootBoundary,
      altBoundary = options.altBoundary,
      _options$flipVariatio = options.flipVariations,
      flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio,
      allowedAutoPlacements = options.allowedAutoPlacements;
    var preferredPlacement = state.options.placement;
    var basePlacement = getBasePlacement$1(preferredPlacement);
    var isBasePlacement = basePlacement === preferredPlacement;
    var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
    var placements = [preferredPlacement].concat(fallbackPlacements).reduce(function (acc, placement) {
      return acc.concat(getBasePlacement$1(placement) === auto ? computeAutoPlacement(state, {
        placement: placement,
        boundary: boundary,
        rootBoundary: rootBoundary,
        padding: padding,
        flipVariations: flipVariations,
        allowedAutoPlacements: allowedAutoPlacements
      }) : placement);
    }, []);
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var checksMap = new Map();
    var makeFallbackChecks = true;
    var firstFittingPlacement = placements[0];
    for (var i = 0; i < placements.length; i++) {
      var placement = placements[i];
      var _basePlacement = getBasePlacement$1(placement);
      var isStartVariation = getVariation(placement) === start;
      var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
      var len = isVertical ? 'width' : 'height';
      var overflow = detectOverflow(state, {
        placement: placement,
        boundary: boundary,
        rootBoundary: rootBoundary,
        altBoundary: altBoundary,
        padding: padding
      });
      var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
      if (referenceRect[len] > popperRect[len]) {
        mainVariationSide = getOppositePlacement(mainVariationSide);
      }
      var altVariationSide = getOppositePlacement(mainVariationSide);
      var checks = [];
      if (checkMainAxis) {
        checks.push(overflow[_basePlacement] <= 0);
      }
      if (checkAltAxis) {
        checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
      }
      if (checks.every(function (check) {
        return check;
      })) {
        firstFittingPlacement = placement;
        makeFallbackChecks = false;
        break;
      }
      checksMap.set(placement, checks);
    }
    if (makeFallbackChecks) {
      // `2` may be desired in some cases  research later
      var numberOfChecks = flipVariations ? 3 : 1;
      var _loop = function _loop(_i) {
        var fittingPlacement = placements.find(function (placement) {
          var checks = checksMap.get(placement);
          if (checks) {
            return checks.slice(0, _i).every(function (check) {
              return check;
            });
          }
        });
        if (fittingPlacement) {
          firstFittingPlacement = fittingPlacement;
          return "break";
        }
      };
      for (var _i = numberOfChecks; _i > 0; _i--) {
        var _ret = _loop(_i);
        if (_ret === "break") break;
      }
    }
    if (state.placement !== firstFittingPlacement) {
      state.modifiersData[name]._skip = true;
      state.placement = firstFittingPlacement;
      state.reset = true;
    }
  } // eslint-disable-next-line import/no-unused-modules

  var flip$1 = {
    name: 'flip',
    enabled: true,
    phase: 'main',
    fn: flip,
    requiresIfExists: ['offset'],
    data: {
      _skip: false
    }
  };

  function getSideOffsets(overflow, rect, preventedOffsets) {
    if (preventedOffsets === void 0) {
      preventedOffsets = {
        x: 0,
        y: 0
      };
    }
    return {
      top: overflow.top - rect.height - preventedOffsets.y,
      right: overflow.right - rect.width + preventedOffsets.x,
      bottom: overflow.bottom - rect.height + preventedOffsets.y,
      left: overflow.left - rect.width - preventedOffsets.x
    };
  }
  function isAnySideFullyClipped(overflow) {
    return [top, right, bottom, left].some(function (side) {
      return overflow[side] >= 0;
    });
  }
  function hide(_ref) {
    var state = _ref.state,
      name = _ref.name;
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var preventedOffsets = state.modifiersData.preventOverflow;
    var referenceOverflow = detectOverflow(state, {
      elementContext: 'reference'
    });
    var popperAltOverflow = detectOverflow(state, {
      altBoundary: true
    });
    var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
    var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
    var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
    var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
    state.modifiersData[name] = {
      referenceClippingOffsets: referenceClippingOffsets,
      popperEscapeOffsets: popperEscapeOffsets,
      isReferenceHidden: isReferenceHidden,
      hasPopperEscaped: hasPopperEscaped
    };
    state.attributes.popper = Object.assign({}, state.attributes.popper, {
      'data-popper-reference-hidden': isReferenceHidden,
      'data-popper-escaped': hasPopperEscaped
    });
  } // eslint-disable-next-line import/no-unused-modules

  var hide$1 = {
    name: 'hide',
    enabled: true,
    phase: 'main',
    requiresIfExists: ['preventOverflow'],
    fn: hide
  };

  function distanceAndSkiddingToXY(placement, rects, offset) {
    var basePlacement = getBasePlacement$1(placement);
    var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
    var _ref = typeof offset === 'function' ? offset(Object.assign({}, rects, {
        placement: placement
      })) : offset,
      skidding = _ref[0],
      distance = _ref[1];
    skidding = skidding || 0;
    distance = (distance || 0) * invertDistance;
    return [left, right].indexOf(basePlacement) >= 0 ? {
      x: distance,
      y: skidding
    } : {
      x: skidding,
      y: distance
    };
  }
  function offset(_ref2) {
    var state = _ref2.state,
      options = _ref2.options,
      name = _ref2.name;
    var _options$offset = options.offset,
      offset = _options$offset === void 0 ? [0, 0] : _options$offset;
    var data = placements.reduce(function (acc, placement) {
      acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset);
      return acc;
    }, {});
    var _data$state$placement = data[state.placement],
      x = _data$state$placement.x,
      y = _data$state$placement.y;
    if (state.modifiersData.popperOffsets != null) {
      state.modifiersData.popperOffsets.x += x;
      state.modifiersData.popperOffsets.y += y;
    }
    state.modifiersData[name] = data;
  } // eslint-disable-next-line import/no-unused-modules

  var offset$1 = {
    name: 'offset',
    enabled: true,
    phase: 'main',
    requires: ['popperOffsets'],
    fn: offset
  };

  function popperOffsets(_ref) {
    var state = _ref.state,
      name = _ref.name;
    // Offsets are the actual position the popper needs to have to be
    // properly positioned near its reference element
    // This is the most basic placement, and will be adjusted by
    // the modifiers in the next step
    state.modifiersData[name] = computeOffsets({
      reference: state.rects.reference,
      element: state.rects.popper,
      strategy: 'absolute',
      placement: state.placement
    });
  } // eslint-disable-next-line import/no-unused-modules

  var popperOffsets$1 = {
    name: 'popperOffsets',
    enabled: true,
    phase: 'read',
    fn: popperOffsets,
    data: {}
  };

  function getAltAxis(axis) {
    return axis === 'x' ? 'y' : 'x';
  }

  function preventOverflow(_ref) {
    var state = _ref.state,
      options = _ref.options,
      name = _ref.name;
    var _options$mainAxis = options.mainAxis,
      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
      _options$altAxis = options.altAxis,
      checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis,
      boundary = options.boundary,
      rootBoundary = options.rootBoundary,
      altBoundary = options.altBoundary,
      padding = options.padding,
      _options$tether = options.tether,
      tether = _options$tether === void 0 ? true : _options$tether,
      _options$tetherOffset = options.tetherOffset,
      tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
    var overflow = detectOverflow(state, {
      boundary: boundary,
      rootBoundary: rootBoundary,
      padding: padding,
      altBoundary: altBoundary
    });
    var basePlacement = getBasePlacement$1(state.placement);
    var variation = getVariation(state.placement);
    var isBasePlacement = !variation;
    var mainAxis = getMainAxisFromPlacement(basePlacement);
    var altAxis = getAltAxis(mainAxis);
    var popperOffsets = state.modifiersData.popperOffsets;
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var tetherOffsetValue = typeof tetherOffset === 'function' ? tetherOffset(Object.assign({}, state.rects, {
      placement: state.placement
    })) : tetherOffset;
    var normalizedTetherOffsetValue = typeof tetherOffsetValue === 'number' ? {
      mainAxis: tetherOffsetValue,
      altAxis: tetherOffsetValue
    } : Object.assign({
      mainAxis: 0,
      altAxis: 0
    }, tetherOffsetValue);
    var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
    var data = {
      x: 0,
      y: 0
    };
    if (!popperOffsets) {
      return;
    }
    if (checkMainAxis) {
      var _offsetModifierState$;
      var mainSide = mainAxis === 'y' ? top : left;
      var altSide = mainAxis === 'y' ? bottom : right;
      var len = mainAxis === 'y' ? 'height' : 'width';
      var offset = popperOffsets[mainAxis];
      var min$1 = offset + overflow[mainSide];
      var max$1 = offset - overflow[altSide];
      var additive = tether ? -popperRect[len] / 2 : 0;
      var minLen = variation === start ? referenceRect[len] : popperRect[len];
      var maxLen = variation === start ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn't go
      // outside the reference bounds

      var arrowElement = state.elements.arrow;
      var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
        width: 0,
        height: 0
      };
      var arrowPaddingObject = state.modifiersData['arrow#persistent'] ? state.modifiersData['arrow#persistent'].padding : getFreshSideObject();
      var arrowPaddingMin = arrowPaddingObject[mainSide];
      var arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don't want
      // to include its full size in the calculation. If the reference is small
      // and near the edge of a boundary, the popper can overflow even if the
      // reference is not overflowing as well (e.g. virtual elements with no
      // width or height)

      var arrowLen = within(0, referenceRect[len], arrowRect[len]);
      var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
      var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
      var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
      var clientOffset = arrowOffsetParent ? mainAxis === 'y' ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
      var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
      var tetherMin = offset + minOffset - offsetModifierValue - clientOffset;
      var tetherMax = offset + maxOffset - offsetModifierValue;
      var preventedOffset = within(tether ? min(min$1, tetherMin) : min$1, offset, tether ? max(max$1, tetherMax) : max$1);
      popperOffsets[mainAxis] = preventedOffset;
      data[mainAxis] = preventedOffset - offset;
    }
    if (checkAltAxis) {
      var _offsetModifierState$2;
      var _mainSide = mainAxis === 'x' ? top : left;
      var _altSide = mainAxis === 'x' ? bottom : right;
      var _offset = popperOffsets[altAxis];
      var _len = altAxis === 'y' ? 'height' : 'width';
      var _min = _offset + overflow[_mainSide];
      var _max = _offset - overflow[_altSide];
      var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
      var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
      var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
      var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
      var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
      popperOffsets[altAxis] = _preventedOffset;
      data[altAxis] = _preventedOffset - _offset;
    }
    state.modifiersData[name] = data;
  } // eslint-disable-next-line import/no-unused-modules

  var preventOverflow$1 = {
    name: 'preventOverflow',
    enabled: true,
    phase: 'main',
    fn: preventOverflow,
    requiresIfExists: ['offset']
  };

  function getHTMLElementScroll(element) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }

  function getNodeScroll(node) {
    if (node === getWindow(node) || !isHTMLElement(node)) {
      return getWindowScroll(node);
    } else {
      return getHTMLElementScroll(node);
    }
  }

  function isElementScaled(element) {
    var rect = element.getBoundingClientRect();
    var scaleX = round(rect.width) / element.offsetWidth || 1;
    var scaleY = round(rect.height) / element.offsetHeight || 1;
    return scaleX !== 1 || scaleY !== 1;
  } // Returns the composite rect of an element relative to its offsetParent.
  // Composite means it takes into account transforms as well as layout.

  function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
    if (isFixed === void 0) {
      isFixed = false;
    }
    var isOffsetParentAnElement = isHTMLElement(offsetParent);
    var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
    var documentElement = getDocumentElement(offsetParent);
    var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
    var scroll = {
      scrollLeft: 0,
      scrollTop: 0
    };
    var offsets = {
      x: 0,
      y: 0
    };
    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
      if (getNodeName(offsetParent) !== 'body' ||
      // https://github.com/popperjs/popper-core/issues/1078
      isScrollParent(documentElement)) {
        scroll = getNodeScroll(offsetParent);
      }
      if (isHTMLElement(offsetParent)) {
        offsets = getBoundingClientRect(offsetParent, true);
        offsets.x += offsetParent.clientLeft;
        offsets.y += offsetParent.clientTop;
      } else if (documentElement) {
        offsets.x = getWindowScrollBarX(documentElement);
      }
    }
    return {
      x: rect.left + scroll.scrollLeft - offsets.x,
      y: rect.top + scroll.scrollTop - offsets.y,
      width: rect.width,
      height: rect.height
    };
  }

  function order(modifiers) {
    var map = new Map();
    var visited = new Set();
    var result = [];
    modifiers.forEach(function (modifier) {
      map.set(modifier.name, modifier);
    }); // On visiting object, check for its dependencies and visit them recursively

    function sort(modifier) {
      visited.add(modifier.name);
      var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
      requires.forEach(function (dep) {
        if (!visited.has(dep)) {
          var depModifier = map.get(dep);
          if (depModifier) {
            sort(depModifier);
          }
        }
      });
      result.push(modifier);
    }
    modifiers.forEach(function (modifier) {
      if (!visited.has(modifier.name)) {
        // check for visited object
        sort(modifier);
      }
    });
    return result;
  }
  function orderModifiers(modifiers) {
    // order based on dependencies
    var orderedModifiers = order(modifiers); // order based on phase

    return modifierPhases.reduce(function (acc, phase) {
      return acc.concat(orderedModifiers.filter(function (modifier) {
        return modifier.phase === phase;
      }));
    }, []);
  }

  function debounce$1(fn) {
    var pending;
    return function () {
      if (!pending) {
        pending = new Promise(function (resolve) {
          Promise.resolve().then(function () {
            pending = undefined;
            resolve(fn());
          });
        });
      }
      return pending;
    };
  }

  function mergeByName(modifiers) {
    var merged = modifiers.reduce(function (merged, current) {
      var existing = merged[current.name];
      merged[current.name] = existing ? Object.assign({}, existing, current, {
        options: Object.assign({}, existing.options, current.options),
        data: Object.assign({}, existing.data, current.data)
      }) : current;
      return merged;
    }, {}); // IE11 does not support Object.values

    return Object.keys(merged).map(function (key) {
      return merged[key];
    });
  }

  var DEFAULT_OPTIONS = {
    placement: 'bottom',
    modifiers: [],
    strategy: 'absolute'
  };
  function areValidElements() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return !args.some(function (element) {
      return !(element && typeof element.getBoundingClientRect === 'function');
    });
  }
  function popperGenerator(generatorOptions) {
    if (generatorOptions === void 0) {
      generatorOptions = {};
    }
    var _generatorOptions = generatorOptions,
      _generatorOptions$def = _generatorOptions.defaultModifiers,
      defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def,
      _generatorOptions$def2 = _generatorOptions.defaultOptions,
      defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
    return function createPopper(reference, popper, options) {
      if (options === void 0) {
        options = defaultOptions;
      }
      var state = {
        placement: 'bottom',
        orderedModifiers: [],
        options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
        modifiersData: {},
        elements: {
          reference: reference,
          popper: popper
        },
        attributes: {},
        styles: {}
      };
      var effectCleanupFns = [];
      var isDestroyed = false;
      var instance = {
        state: state,
        setOptions: function setOptions(setOptionsAction) {
          var options = typeof setOptionsAction === 'function' ? setOptionsAction(state.options) : setOptionsAction;
          cleanupModifierEffects();
          state.options = Object.assign({}, defaultOptions, state.options, options);
          state.scrollParents = {
            reference: isElement$1(reference) ? listScrollParents(reference) : reference.contextElement ? listScrollParents(reference.contextElement) : [],
            popper: listScrollParents(popper)
          }; // Orders the modifiers based on their dependencies and `phase`
          // properties

          var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers, state.options.modifiers))); // Strip out disabled modifiers

          state.orderedModifiers = orderedModifiers.filter(function (m) {
            return m.enabled;
          });
          runModifierEffects();
          return instance.update();
        },
        // Sync update  it will always be executed, even if not necessary. This
        // is useful for low frequency updates where sync behavior simplifies the
        // logic.
        // For high frequency updates (e.g. `resize` and `scroll` events), always
        // prefer the async Popper#update method
        forceUpdate: function forceUpdate() {
          if (isDestroyed) {
            return;
          }
          var _state$elements = state.elements,
            reference = _state$elements.reference,
            popper = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements
          // anymore

          if (!areValidElements(reference, popper)) {
            return;
          } // Store the reference and popper rects to be read by modifiers

          state.rects = {
            reference: getCompositeRect(reference, getOffsetParent(popper), state.options.strategy === 'fixed'),
            popper: getLayoutRect(popper)
          }; // Modifiers have the ability to reset the current update cycle. The
          // most common use case for this is the `flip` modifier changing the
          // placement, which then needs to re-run all the modifiers, because the
          // logic was previously ran for the previous placement and is therefore
          // stale/incorrect

          state.reset = false;
          state.placement = state.options.placement; // On each update cycle, the `modifiersData` property for each modifier
          // is filled with the initial data specified by the modifier. This means
          // it doesn't persist and is fresh on each update.
          // To ensure persistent data, use `${name}#persistent`

          state.orderedModifiers.forEach(function (modifier) {
            return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
          });
          for (var index = 0; index < state.orderedModifiers.length; index++) {
            if (state.reset === true) {
              state.reset = false;
              index = -1;
              continue;
            }
            var _state$orderedModifie = state.orderedModifiers[index],
              fn = _state$orderedModifie.fn,
              _state$orderedModifie2 = _state$orderedModifie.options,
              _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,
              name = _state$orderedModifie.name;
            if (typeof fn === 'function') {
              state = fn({
                state: state,
                options: _options,
                name: name,
                instance: instance
              }) || state;
            }
          }
        },
        // Async and optimistically optimized update  it will not be executed if
        // not necessary (debounced to run at most once-per-tick)
        update: debounce$1(function () {
          return new Promise(function (resolve) {
            instance.forceUpdate();
            resolve(state);
          });
        }),
        destroy: function destroy() {
          cleanupModifierEffects();
          isDestroyed = true;
        }
      };
      if (!areValidElements(reference, popper)) {
        return instance;
      }
      instance.setOptions(options).then(function (state) {
        if (!isDestroyed && options.onFirstUpdate) {
          options.onFirstUpdate(state);
        }
      }); // Modifiers have the ability to execute arbitrary code before the first
      // update cycle runs. They will be executed in the same order as the update
      // cycle. This is useful when a modifier adds some persistent data that
      // other modifiers need to use, but the modifier is run after the dependent
      // one.

      function runModifierEffects() {
        state.orderedModifiers.forEach(function (_ref) {
          var name = _ref.name,
            _ref$options = _ref.options,
            options = _ref$options === void 0 ? {} : _ref$options,
            effect = _ref.effect;
          if (typeof effect === 'function') {
            var cleanupFn = effect({
              state: state,
              name: name,
              instance: instance,
              options: options
            });
            var noopFn = function noopFn() {};
            effectCleanupFns.push(cleanupFn || noopFn);
          }
        });
      }
      function cleanupModifierEffects() {
        effectCleanupFns.forEach(function (fn) {
          return fn();
        });
        effectCleanupFns = [];
      }
      return instance;
    };
  }

  var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$1, hide$1];
  var createPopper = /*#__PURE__*/popperGenerator({
    defaultModifiers: defaultModifiers
  }); // eslint-disable-next-line import/no-unused-modules

  /**!
  * tippy.js v6.3.7
  * (c) 2017-2021 atomiks
  * MIT License
  */
  var BOX_CLASS = "tippy-box";
  var CONTENT_CLASS = "tippy-content";
  var BACKDROP_CLASS = "tippy-backdrop";
  var ARROW_CLASS = "tippy-arrow";
  var SVG_ARROW_CLASS = "tippy-svg-arrow";
  var TOUCH_OPTIONS = {
    passive: true,
    capture: true
  };
  var TIPPY_DEFAULT_APPEND_TO = function TIPPY_DEFAULT_APPEND_TO() {
    return document.body;
  };
  function getValueAtIndexOrReturn(value, index, defaultValue) {
    if (Array.isArray(value)) {
      var v = value[index];
      return v == null ? Array.isArray(defaultValue) ? defaultValue[index] : defaultValue : v;
    }
    return value;
  }
  function isType(value, type) {
    var str = {}.toString.call(value);
    return str.indexOf('[object') === 0 && str.indexOf(type + "]") > -1;
  }
  function invokeWithArgsOrReturn(value, args) {
    return typeof value === 'function' ? value.apply(void 0, args) : value;
  }
  function debounce(fn, ms) {
    // Avoid wrapping in `setTimeout` if ms is 0 anyway
    if (ms === 0) {
      return fn;
    }
    var timeout;
    return function (arg) {
      clearTimeout(timeout);
      timeout = setTimeout(function () {
        fn(arg);
      }, ms);
    };
  }
  function splitBySpaces(value) {
    return value.split(/\s+/).filter(Boolean);
  }
  function normalizeToArray(value) {
    return [].concat(value);
  }
  function pushIfUnique(arr, value) {
    if (arr.indexOf(value) === -1) {
      arr.push(value);
    }
  }
  function unique(arr) {
    return arr.filter(function (item, index) {
      return arr.indexOf(item) === index;
    });
  }
  function getBasePlacement(placement) {
    return placement.split('-')[0];
  }
  function arrayFrom(value) {
    return [].slice.call(value);
  }
  function removeUndefinedProps(obj) {
    return Object.keys(obj).reduce(function (acc, key) {
      if (obj[key] !== undefined) {
        acc[key] = obj[key];
      }
      return acc;
    }, {});
  }
  function div() {
    return document.createElement('div');
  }
  function isElement(value) {
    return ['Element', 'Fragment'].some(function (type) {
      return isType(value, type);
    });
  }
  function isNodeList(value) {
    return isType(value, 'NodeList');
  }
  function isMouseEvent(value) {
    return isType(value, 'MouseEvent');
  }
  function isReferenceElement(value) {
    return !!(value && value._tippy && value._tippy.reference === value);
  }
  function getArrayOfElements(value) {
    if (isElement(value)) {
      return [value];
    }
    if (isNodeList(value)) {
      return arrayFrom(value);
    }
    if (Array.isArray(value)) {
      return value;
    }
    return arrayFrom(document.querySelectorAll(value));
  }
  function setTransitionDuration(els, value) {
    els.forEach(function (el) {
      if (el) {
        el.style.transitionDuration = value + "ms";
      }
    });
  }
  function setVisibilityState(els, state) {
    els.forEach(function (el) {
      if (el) {
        el.setAttribute('data-state', state);
      }
    });
  }
  function getOwnerDocument(elementOrElements) {
    var _element$ownerDocumen;
    var _normalizeToArray = normalizeToArray(elementOrElements),
      element = _normalizeToArray[0]; // Elements created via a <template> have an ownerDocument with no reference to the body

    return element != null && (_element$ownerDocumen = element.ownerDocument) != null && _element$ownerDocumen.body ? element.ownerDocument : document;
  }
  function isCursorOutsideInteractiveBorder(popperTreeData, event) {
    var clientX = event.clientX,
      clientY = event.clientY;
    return popperTreeData.every(function (_ref) {
      var popperRect = _ref.popperRect,
        popperState = _ref.popperState,
        props = _ref.props;
      var interactiveBorder = props.interactiveBorder;
      var basePlacement = getBasePlacement(popperState.placement);
      var offsetData = popperState.modifiersData.offset;
      if (!offsetData) {
        return true;
      }
      var topDistance = basePlacement === 'bottom' ? offsetData.top.y : 0;
      var bottomDistance = basePlacement === 'top' ? offsetData.bottom.y : 0;
      var leftDistance = basePlacement === 'right' ? offsetData.left.x : 0;
      var rightDistance = basePlacement === 'left' ? offsetData.right.x : 0;
      var exceedsTop = popperRect.top - clientY + topDistance > interactiveBorder;
      var exceedsBottom = clientY - popperRect.bottom - bottomDistance > interactiveBorder;
      var exceedsLeft = popperRect.left - clientX + leftDistance > interactiveBorder;
      var exceedsRight = clientX - popperRect.right - rightDistance > interactiveBorder;
      return exceedsTop || exceedsBottom || exceedsLeft || exceedsRight;
    });
  }
  function updateTransitionEndListener(box, action, listener) {
    var method = action + "EventListener"; // some browsers apparently support `transition` (unprefixed) but only fire
    // `webkitTransitionEnd`...

    ['transitionend', 'webkitTransitionEnd'].forEach(function (event) {
      box[method](event, listener);
    });
  }
  /**
   * Compared to xxx.contains, this function works for dom structures with shadow
   * dom
   */

  function actualContains(parent, child) {
    var target = child;
    while (target) {
      var _target$getRootNode;
      if (parent.contains(target)) {
        return true;
      }
      target = target.getRootNode == null ? void 0 : (_target$getRootNode = target.getRootNode()) == null ? void 0 : _target$getRootNode.host;
    }
    return false;
  }
  var currentInput = {
    isTouch: false
  };
  var lastMouseMoveTime = 0;
  /**
   * When a `touchstart` event is fired, it's assumed the user is using touch
   * input. We'll bind a `mousemove` event listener to listen for mouse input in
   * the future. This way, the `isTouch` property is fully dynamic and will handle
   * hybrid devices that use a mix of touch + mouse input.
   */

  function onDocumentTouchStart() {
    if (currentInput.isTouch) {
      return;
    }
    currentInput.isTouch = true;
    if (window.performance) {
      document.addEventListener('mousemove', onDocumentMouseMove);
    }
  }
  /**
   * When two `mousemove` event are fired consecutively within 20ms, it's assumed
   * the user is using mouse input again. `mousemove` can fire on touch devices as
   * well, but very rarely that quickly.
   */

  function onDocumentMouseMove() {
    var now = performance.now();
    if (now - lastMouseMoveTime < 20) {
      currentInput.isTouch = false;
      document.removeEventListener('mousemove', onDocumentMouseMove);
    }
    lastMouseMoveTime = now;
  }
  /**
   * When an element is in focus and has a tippy, leaving the tab/window and
   * returning causes it to show again. For mouse users this is unexpected, but
   * for keyboard use it makes sense.
   * TODO: find a better technique to solve this problem
   */

  function onWindowBlur() {
    var activeElement = document.activeElement;
    if (isReferenceElement(activeElement)) {
      var instance = activeElement._tippy;
      if (activeElement.blur && !instance.state.isVisible) {
        activeElement.blur();
      }
    }
  }
  function bindGlobalEventListeners() {
    document.addEventListener('touchstart', onDocumentTouchStart, TOUCH_OPTIONS);
    window.addEventListener('blur', onWindowBlur);
  }
  var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined';
  var isIE11 = isBrowser ?
  // @ts-ignore
  !!window.msCrypto : false;
  var pluginProps = {
    animateFill: false,
    followCursor: false,
    inlinePositioning: false,
    sticky: false
  };
  var renderProps = {
    allowHTML: false,
    animation: 'fade',
    arrow: true,
    content: '',
    inertia: false,
    maxWidth: 350,
    role: 'tooltip',
    theme: '',
    zIndex: 9999
  };
  var defaultProps = Object.assign({
    appendTo: TIPPY_DEFAULT_APPEND_TO,
    aria: {
      content: 'auto',
      expanded: 'auto'
    },
    delay: 0,
    duration: [300, 250],
    getReferenceClientRect: null,
    hideOnClick: true,
    ignoreAttributes: false,
    interactive: false,
    interactiveBorder: 2,
    interactiveDebounce: 0,
    moveTransition: '',
    offset: [0, 10],
    onAfterUpdate: function onAfterUpdate() {},
    onBeforeUpdate: function onBeforeUpdate() {},
    onCreate: function onCreate() {},
    onDestroy: function onDestroy() {},
    onHidden: function onHidden() {},
    onHide: function onHide() {},
    onMount: function onMount() {},
    onShow: function onShow() {},
    onShown: function onShown() {},
    onTrigger: function onTrigger() {},
    onUntrigger: function onUntrigger() {},
    onClickOutside: function onClickOutside() {},
    placement: 'top',
    plugins: [],
    popperOptions: {},
    render: null,
    showOnCreate: false,
    touch: true,
    trigger: 'mouseenter focus',
    triggerTarget: null
  }, pluginProps, renderProps);
  var defaultKeys = Object.keys(defaultProps);
  var setDefaultProps = function setDefaultProps(partialProps) {
    var keys = Object.keys(partialProps);
    keys.forEach(function (key) {
      defaultProps[key] = partialProps[key];
    });
  };
  function getExtendedPassedProps(passedProps) {
    var plugins = passedProps.plugins || [];
    var pluginProps = plugins.reduce(function (acc, plugin) {
      var name = plugin.name,
        defaultValue = plugin.defaultValue;
      if (name) {
        var _name;
        acc[name] = passedProps[name] !== undefined ? passedProps[name] : (_name = defaultProps[name]) != null ? _name : defaultValue;
      }
      return acc;
    }, {});
    return Object.assign({}, passedProps, pluginProps);
  }
  function getDataAttributeProps(reference, plugins) {
    var propKeys = plugins ? Object.keys(getExtendedPassedProps(Object.assign({}, defaultProps, {
      plugins: plugins
    }))) : defaultKeys;
    var props = propKeys.reduce(function (acc, key) {
      var valueAsString = (reference.getAttribute("data-tippy-" + key) || '').trim();
      if (!valueAsString) {
        return acc;
      }
      if (key === 'content') {
        acc[key] = valueAsString;
      } else {
        try {
          acc[key] = JSON.parse(valueAsString);
        } catch (e) {
          acc[key] = valueAsString;
        }
      }
      return acc;
    }, {});
    return props;
  }
  function evaluateProps(reference, props) {
    var out = Object.assign({}, props, {
      content: invokeWithArgsOrReturn(props.content, [reference])
    }, props.ignoreAttributes ? {} : getDataAttributeProps(reference, props.plugins));
    out.aria = Object.assign({}, defaultProps.aria, out.aria);
    out.aria = {
      expanded: out.aria.expanded === 'auto' ? props.interactive : out.aria.expanded,
      content: out.aria.content === 'auto' ? props.interactive ? null : 'describedby' : out.aria.content
    };
    return out;
  }
  var innerHTML = function innerHTML() {
    return 'innerHTML';
  };
  function dangerouslySetInnerHTML(element, html) {
    element[innerHTML()] = html;
  }
  function createArrowElement(value) {
    var arrow = div();
    if (value === true) {
      arrow.className = ARROW_CLASS;
    } else {
      arrow.className = SVG_ARROW_CLASS;
      if (isElement(value)) {
        arrow.appendChild(value);
      } else {
        dangerouslySetInnerHTML(arrow, value);
      }
    }
    return arrow;
  }
  function setContent(content, props) {
    if (isElement(props.content)) {
      dangerouslySetInnerHTML(content, '');
      content.appendChild(props.content);
    } else if (typeof props.content !== 'function') {
      if (props.allowHTML) {
        dangerouslySetInnerHTML(content, props.content);
      } else {
        content.textContent = props.content;
      }
    }
  }
  function getChildren(popper) {
    var box = popper.firstElementChild;
    var boxChildren = arrayFrom(box.children);
    return {
      box: box,
      content: boxChildren.find(function (node) {
        return node.classList.contains(CONTENT_CLASS);
      }),
      arrow: boxChildren.find(function (node) {
        return node.classList.contains(ARROW_CLASS) || node.classList.contains(SVG_ARROW_CLASS);
      }),
      backdrop: boxChildren.find(function (node) {
        return node.classList.contains(BACKDROP_CLASS);
      })
    };
  }
  function render(instance) {
    var popper = div();
    var box = div();
    box.className = BOX_CLASS;
    box.setAttribute('data-state', 'hidden');
    box.setAttribute('tabindex', '-1');
    var content = div();
    content.className = CONTENT_CLASS;
    content.setAttribute('data-state', 'hidden');
    setContent(content, instance.props);
    popper.appendChild(box);
    box.appendChild(content);
    onUpdate(instance.props, instance.props);
    function onUpdate(prevProps, nextProps) {
      var _getChildren = getChildren(popper),
        box = _getChildren.box,
        content = _getChildren.content,
        arrow = _getChildren.arrow;
      if (nextProps.theme) {
        box.setAttribute('data-theme', nextProps.theme);
      } else {
        box.removeAttribute('data-theme');
      }
      if (typeof nextProps.animation === 'string') {
        box.setAttribute('data-animation', nextProps.animation);
      } else {
        box.removeAttribute('data-animation');
      }
      if (nextProps.inertia) {
        box.setAttribute('data-inertia', '');
      } else {
        box.removeAttribute('data-inertia');
      }
      box.style.maxWidth = typeof nextProps.maxWidth === 'number' ? nextProps.maxWidth + "px" : nextProps.maxWidth;
      if (nextProps.role) {
        box.setAttribute('role', nextProps.role);
      } else {
        box.removeAttribute('role');
      }
      if (prevProps.content !== nextProps.content || prevProps.allowHTML !== nextProps.allowHTML) {
        setContent(content, instance.props);
      }
      if (nextProps.arrow) {
        if (!arrow) {
          box.appendChild(createArrowElement(nextProps.arrow));
        } else if (prevProps.arrow !== nextProps.arrow) {
          box.removeChild(arrow);
          box.appendChild(createArrowElement(nextProps.arrow));
        }
      } else if (arrow) {
        box.removeChild(arrow);
      }
    }
    return {
      popper: popper,
      onUpdate: onUpdate
    };
  } // Runtime check to identify if the render function is the default one; this
  // way we can apply default CSS transitions logic and it can be tree-shaken away

  render.$$tippy = true;
  var idCounter = 1;
  var mouseMoveListeners = []; // Used by `hideAll()`

  var mountedInstances = [];
  function createTippy(reference, passedProps) {
    var props = evaluateProps(reference, Object.assign({}, defaultProps, getExtendedPassedProps(removeUndefinedProps(passedProps)))); // ===========================================================================
    //  Private members
    // ===========================================================================

    var showTimeout;
    var hideTimeout;
    var scheduleHideAnimationFrame;
    var isVisibleFromClick = false;
    var didHideDueToDocumentMouseDown = false;
    var didTouchMove = false;
    var ignoreOnFirstUpdate = false;
    var lastTriggerEvent;
    var currentTransitionEndListener;
    var onFirstUpdate;
    var listeners = [];
    var debouncedOnMouseMove = debounce(onMouseMove, props.interactiveDebounce);
    var currentTarget; // ===========================================================================
    //  Public members
    // ===========================================================================

    var id = idCounter++;
    var popperInstance = null;
    var plugins = unique(props.plugins);
    var state = {
      // Is the instance currently enabled?
      isEnabled: true,
      // Is the tippy currently showing and not transitioning out?
      isVisible: false,
      // Has the instance been destroyed?
      isDestroyed: false,
      // Is the tippy currently mounted to the DOM?
      isMounted: false,
      // Has the tippy finished transitioning in?
      isShown: false
    };
    var instance = {
      // properties
      id: id,
      reference: reference,
      popper: div(),
      popperInstance: popperInstance,
      props: props,
      state: state,
      plugins: plugins,
      // methods
      clearDelayTimeouts: clearDelayTimeouts,
      setProps: setProps,
      setContent: setContent,
      show: show,
      hide: hide,
      hideWithInteractivity: hideWithInteractivity,
      enable: enable,
      disable: disable,
      unmount: unmount,
      destroy: destroy
    }; // TODO: Investigate why this early return causes a TDZ error in the tests 
    // it doesn't seem to happen in the browser

    /* istanbul ignore if */

    if (!props.render) {
      return instance;
    } // ===========================================================================
    // Initial mutations
    // ===========================================================================

    var _props$render = props.render(instance),
      popper = _props$render.popper,
      onUpdate = _props$render.onUpdate;
    popper.setAttribute('data-tippy-root', '');
    popper.id = "tippy-" + instance.id;
    instance.popper = popper;
    reference._tippy = instance;
    popper._tippy = instance;
    var pluginsHooks = plugins.map(function (plugin) {
      return plugin.fn(instance);
    });
    var hasAriaExpanded = reference.hasAttribute('aria-expanded');
    addListeners();
    handleAriaExpandedAttribute();
    handleStyles();
    invokeHook('onCreate', [instance]);
    if (props.showOnCreate) {
      scheduleShow();
    } // Prevent a tippy with a delay from hiding if the cursor left then returned
    // before it started hiding

    popper.addEventListener('mouseenter', function () {
      if (instance.props.interactive && instance.state.isVisible) {
        instance.clearDelayTimeouts();
      }
    });
    popper.addEventListener('mouseleave', function () {
      if (instance.props.interactive && instance.props.trigger.indexOf('mouseenter') >= 0) {
        getDocument().addEventListener('mousemove', debouncedOnMouseMove);
      }
    });
    return instance; // ===========================================================================
    //  Private methods
    // ===========================================================================

    function getNormalizedTouchSettings() {
      var touch = instance.props.touch;
      return Array.isArray(touch) ? touch : [touch, 0];
    }
    function getIsCustomTouchBehavior() {
      return getNormalizedTouchSettings()[0] === 'hold';
    }
    function getIsDefaultRenderFn() {
      var _instance$props$rende;

      // @ts-ignore
      return !!((_instance$props$rende = instance.props.render) != null && _instance$props$rende.$$tippy);
    }
    function getCurrentTarget() {
      return currentTarget || reference;
    }
    function getDocument() {
      var parent = getCurrentTarget().parentNode;
      return parent ? getOwnerDocument(parent) : document;
    }
    function getDefaultTemplateChildren() {
      return getChildren(popper);
    }
    function getDelay(isShow) {
      // For touch or keyboard input, force `0` delay for UX reasons
      // Also if the instance is mounted but not visible (transitioning out),
      // ignore delay
      if (instance.state.isMounted && !instance.state.isVisible || currentInput.isTouch || lastTriggerEvent && lastTriggerEvent.type === 'focus') {
        return 0;
      }
      return getValueAtIndexOrReturn(instance.props.delay, isShow ? 0 : 1, defaultProps.delay);
    }
    function handleStyles(fromHide) {
      if (fromHide === void 0) {
        fromHide = false;
      }
      popper.style.pointerEvents = instance.props.interactive && !fromHide ? '' : 'none';
      popper.style.zIndex = "" + instance.props.zIndex;
    }
    function invokeHook(hook, args, shouldInvokePropsHook) {
      if (shouldInvokePropsHook === void 0) {
        shouldInvokePropsHook = true;
      }
      pluginsHooks.forEach(function (pluginHooks) {
        if (pluginHooks[hook]) {
          pluginHooks[hook].apply(pluginHooks, args);
        }
      });
      if (shouldInvokePropsHook) {
        var _instance$props;
        (_instance$props = instance.props)[hook].apply(_instance$props, args);
      }
    }
    function handleAriaContentAttribute() {
      var aria = instance.props.aria;
      if (!aria.content) {
        return;
      }
      var attr = "aria-" + aria.content;
      var id = popper.id;
      var nodes = normalizeToArray(instance.props.triggerTarget || reference);
      nodes.forEach(function (node) {
        var currentValue = node.getAttribute(attr);
        if (instance.state.isVisible) {
          node.setAttribute(attr, currentValue ? currentValue + " " + id : id);
        } else {
          var nextValue = currentValue && currentValue.replace(id, '').trim();
          if (nextValue) {
            node.setAttribute(attr, nextValue);
          } else {
            node.removeAttribute(attr);
          }
        }
      });
    }
    function handleAriaExpandedAttribute() {
      if (hasAriaExpanded || !instance.props.aria.expanded) {
        return;
      }
      var nodes = normalizeToArray(instance.props.triggerTarget || reference);
      nodes.forEach(function (node) {
        if (instance.props.interactive) {
          node.setAttribute('aria-expanded', instance.state.isVisible && node === getCurrentTarget() ? 'true' : 'false');
        } else {
          node.removeAttribute('aria-expanded');
        }
      });
    }
    function cleanupInteractiveMouseListeners() {
      getDocument().removeEventListener('mousemove', debouncedOnMouseMove);
      mouseMoveListeners = mouseMoveListeners.filter(function (listener) {
        return listener !== debouncedOnMouseMove;
      });
    }
    function onDocumentPress(event) {
      // Moved finger to scroll instead of an intentional tap outside
      if (currentInput.isTouch) {
        if (didTouchMove || event.type === 'mousedown') {
          return;
        }
      }
      var actualTarget = event.composedPath && event.composedPath()[0] || event.target; // Clicked on interactive popper

      if (instance.props.interactive && actualContains(popper, actualTarget)) {
        return;
      } // Clicked on the event listeners target

      if (normalizeToArray(instance.props.triggerTarget || reference).some(function (el) {
        return actualContains(el, actualTarget);
      })) {
        if (currentInput.isTouch) {
          return;
        }
        if (instance.state.isVisible && instance.props.trigger.indexOf('click') >= 0) {
          return;
        }
      } else {
        invokeHook('onClickOutside', [instance, event]);
      }
      if (instance.props.hideOnClick === true) {
        instance.clearDelayTimeouts();
        instance.hide(); // `mousedown` event is fired right before `focus` if pressing the
        // currentTarget. This lets a tippy with `focus` trigger know that it
        // should not show

        didHideDueToDocumentMouseDown = true;
        setTimeout(function () {
          didHideDueToDocumentMouseDown = false;
        }); // The listener gets added in `scheduleShow()`, but this may be hiding it
        // before it shows, and hide()'s early bail-out behavior can prevent it
        // from being cleaned up

        if (!instance.state.isMounted) {
          removeDocumentPress();
        }
      }
    }
    function onTouchMove() {
      didTouchMove = true;
    }
    function onTouchStart() {
      didTouchMove = false;
    }
    function addDocumentPress() {
      var doc = getDocument();
      doc.addEventListener('mousedown', onDocumentPress, true);
      doc.addEventListener('touchend', onDocumentPress, TOUCH_OPTIONS);
      doc.addEventListener('touchstart', onTouchStart, TOUCH_OPTIONS);
      doc.addEventListener('touchmove', onTouchMove, TOUCH_OPTIONS);
    }
    function removeDocumentPress() {
      var doc = getDocument();
      doc.removeEventListener('mousedown', onDocumentPress, true);
      doc.removeEventListener('touchend', onDocumentPress, TOUCH_OPTIONS);
      doc.removeEventListener('touchstart', onTouchStart, TOUCH_OPTIONS);
      doc.removeEventListener('touchmove', onTouchMove, TOUCH_OPTIONS);
    }
    function onTransitionedOut(duration, callback) {
      onTransitionEnd(duration, function () {
        if (!instance.state.isVisible && popper.parentNode && popper.parentNode.contains(popper)) {
          callback();
        }
      });
    }
    function onTransitionedIn(duration, callback) {
      onTransitionEnd(duration, callback);
    }
    function onTransitionEnd(duration, callback) {
      var box = getDefaultTemplateChildren().box;
      function listener(event) {
        if (event.target === box) {
          updateTransitionEndListener(box, 'remove', listener);
          callback();
        }
      } // Make callback synchronous if duration is 0
      // `transitionend` won't fire otherwise

      if (duration === 0) {
        return callback();
      }
      updateTransitionEndListener(box, 'remove', currentTransitionEndListener);
      updateTransitionEndListener(box, 'add', listener);
      currentTransitionEndListener = listener;
    }
    function on(eventType, handler, options) {
      if (options === void 0) {
        options = false;
      }
      var nodes = normalizeToArray(instance.props.triggerTarget || reference);
      nodes.forEach(function (node) {
        node.addEventListener(eventType, handler, options);
        listeners.push({
          node: node,
          eventType: eventType,
          handler: handler,
          options: options
        });
      });
    }
    function addListeners() {
      if (getIsCustomTouchBehavior()) {
        on('touchstart', onTrigger, {
          passive: true
        });
        on('touchend', onMouseLeave, {
          passive: true
        });
      }
      splitBySpaces(instance.props.trigger).forEach(function (eventType) {
        if (eventType === 'manual') {
          return;
        }
        on(eventType, onTrigger);
        switch (eventType) {
          case 'mouseenter':
            on('mouseleave', onMouseLeave);
            break;
          case 'focus':
            on(isIE11 ? 'focusout' : 'blur', onBlurOrFocusOut);
            break;
          case 'focusin':
            on('focusout', onBlurOrFocusOut);
            break;
        }
      });
    }
    function removeListeners() {
      listeners.forEach(function (_ref) {
        var node = _ref.node,
          eventType = _ref.eventType,
          handler = _ref.handler,
          options = _ref.options;
        node.removeEventListener(eventType, handler, options);
      });
      listeners = [];
    }
    function onTrigger(event) {
      var _lastTriggerEvent;
      var shouldScheduleClickHide = false;
      if (!instance.state.isEnabled || isEventListenerStopped(event) || didHideDueToDocumentMouseDown) {
        return;
      }
      var wasFocused = ((_lastTriggerEvent = lastTriggerEvent) == null ? void 0 : _lastTriggerEvent.type) === 'focus';
      lastTriggerEvent = event;
      currentTarget = event.currentTarget;
      handleAriaExpandedAttribute();
      if (!instance.state.isVisible && isMouseEvent(event)) {
        // If scrolling, `mouseenter` events can be fired if the cursor lands
        // over a new target, but `mousemove` events don't get fired. This
        // causes interactive tooltips to get stuck open until the cursor is
        // moved
        mouseMoveListeners.forEach(function (listener) {
          return listener(event);
        });
      } // Toggle show/hide when clicking click-triggered tooltips

      if (event.type === 'click' && (instance.props.trigger.indexOf('mouseenter') < 0 || isVisibleFromClick) && instance.props.hideOnClick !== false && instance.state.isVisible) {
        shouldScheduleClickHide = true;
      } else {
        scheduleShow(event);
      }
      if (event.type === 'click') {
        isVisibleFromClick = !shouldScheduleClickHide;
      }
      if (shouldScheduleClickHide && !wasFocused) {
        scheduleHide(event);
      }
    }
    function onMouseMove(event) {
      var target = event.target;
      var isCursorOverReferenceOrPopper = getCurrentTarget().contains(target) || popper.contains(target);
      if (event.type === 'mousemove' && isCursorOverReferenceOrPopper) {
        return;
      }
      var popperTreeData = getNestedPopperTree().concat(popper).map(function (popper) {
        var _instance$popperInsta;
        var instance = popper._tippy;
        var state = (_instance$popperInsta = instance.popperInstance) == null ? void 0 : _instance$popperInsta.state;
        if (state) {
          return {
            popperRect: popper.getBoundingClientRect(),
            popperState: state,
            props: props
          };
        }
        return null;
      }).filter(Boolean);
      if (isCursorOutsideInteractiveBorder(popperTreeData, event)) {
        cleanupInteractiveMouseListeners();
        scheduleHide(event);
      }
    }
    function onMouseLeave(event) {
      var shouldBail = isEventListenerStopped(event) || instance.props.trigger.indexOf('click') >= 0 && isVisibleFromClick;
      if (shouldBail) {
        return;
      }
      if (instance.props.interactive) {
        instance.hideWithInteractivity(event);
        return;
      }
      scheduleHide(event);
    }
    function onBlurOrFocusOut(event) {
      if (instance.props.trigger.indexOf('focusin') < 0 && event.target !== getCurrentTarget()) {
        return;
      } // If focus was moved to within the popper

      if (instance.props.interactive && event.relatedTarget && popper.contains(event.relatedTarget)) {
        return;
      }
      scheduleHide(event);
    }
    function isEventListenerStopped(event) {
      return currentInput.isTouch ? getIsCustomTouchBehavior() !== event.type.indexOf('touch') >= 0 : false;
    }
    function createPopperInstance() {
      destroyPopperInstance();
      var _instance$props2 = instance.props,
        popperOptions = _instance$props2.popperOptions,
        placement = _instance$props2.placement,
        offset = _instance$props2.offset,
        getReferenceClientRect = _instance$props2.getReferenceClientRect,
        moveTransition = _instance$props2.moveTransition;
      var arrow = getIsDefaultRenderFn() ? getChildren(popper).arrow : null;
      var computedReference = getReferenceClientRect ? {
        getBoundingClientRect: getReferenceClientRect,
        contextElement: getReferenceClientRect.contextElement || getCurrentTarget()
      } : reference;
      var tippyModifier = {
        name: '$$tippy',
        enabled: true,
        phase: 'beforeWrite',
        requires: ['computeStyles'],
        fn: function fn(_ref2) {
          var state = _ref2.state;
          if (getIsDefaultRenderFn()) {
            var _getDefaultTemplateCh = getDefaultTemplateChildren(),
              box = _getDefaultTemplateCh.box;
            ['placement', 'reference-hidden', 'escaped'].forEach(function (attr) {
              if (attr === 'placement') {
                box.setAttribute('data-placement', state.placement);
              } else {
                if (state.attributes.popper["data-popper-" + attr]) {
                  box.setAttribute("data-" + attr, '');
                } else {
                  box.removeAttribute("data-" + attr);
                }
              }
            });
            state.attributes.popper = {};
          }
        }
      };
      var modifiers = [{
        name: 'offset',
        options: {
          offset: offset
        }
      }, {
        name: 'preventOverflow',
        options: {
          padding: {
            top: 2,
            bottom: 2,
            left: 5,
            right: 5
          }
        }
      }, {
        name: 'flip',
        options: {
          padding: 5
        }
      }, {
        name: 'computeStyles',
        options: {
          adaptive: !moveTransition
        }
      }, tippyModifier];
      if (getIsDefaultRenderFn() && arrow) {
        modifiers.push({
          name: 'arrow',
          options: {
            element: arrow,
            padding: 3
          }
        });
      }
      modifiers.push.apply(modifiers, (popperOptions == null ? void 0 : popperOptions.modifiers) || []);
      instance.popperInstance = createPopper(computedReference, popper, Object.assign({}, popperOptions, {
        placement: placement,
        onFirstUpdate: onFirstUpdate,
        modifiers: modifiers
      }));
    }
    function destroyPopperInstance() {
      if (instance.popperInstance) {
        instance.popperInstance.destroy();
        instance.popperInstance = null;
      }
    }
    function mount() {
      var appendTo = instance.props.appendTo;
      var parentNode; // By default, we'll append the popper to the triggerTargets's parentNode so
      // it's directly after the reference element so the elements inside the
      // tippy can be tabbed to
      // If there are clipping issues, the user can specify a different appendTo
      // and ensure focus management is handled correctly manually

      var node = getCurrentTarget();
      if (instance.props.interactive && appendTo === TIPPY_DEFAULT_APPEND_TO || appendTo === 'parent') {
        parentNode = node.parentNode;
      } else {
        parentNode = invokeWithArgsOrReturn(appendTo, [node]);
      } // The popper element needs to exist on the DOM before its position can be
      // updated as Popper needs to read its dimensions

      if (!parentNode.contains(popper)) {
        parentNode.appendChild(popper);
      }
      instance.state.isMounted = true;
      createPopperInstance();
    }
    function getNestedPopperTree() {
      return arrayFrom(popper.querySelectorAll('[data-tippy-root]'));
    }
    function scheduleShow(event) {
      instance.clearDelayTimeouts();
      if (event) {
        invokeHook('onTrigger', [instance, event]);
      }
      addDocumentPress();
      var delay = getDelay(true);
      var _getNormalizedTouchSe = getNormalizedTouchSettings(),
        touchValue = _getNormalizedTouchSe[0],
        touchDelay = _getNormalizedTouchSe[1];
      if (currentInput.isTouch && touchValue === 'hold' && touchDelay) {
        delay = touchDelay;
      }
      if (delay) {
        showTimeout = setTimeout(function () {
          instance.show();
        }, delay);
      } else {
        instance.show();
      }
    }
    function scheduleHide(event) {
      instance.clearDelayTimeouts();
      invokeHook('onUntrigger', [instance, event]);
      if (!instance.state.isVisible) {
        removeDocumentPress();
        return;
      } // For interactive tippies, scheduleHide is added to a document.body handler
      // from onMouseLeave so must intercept scheduled hides from mousemove/leave
      // events when trigger contains mouseenter and click, and the tip is
      // currently shown as a result of a click.

      if (instance.props.trigger.indexOf('mouseenter') >= 0 && instance.props.trigger.indexOf('click') >= 0 && ['mouseleave', 'mousemove'].indexOf(event.type) >= 0 && isVisibleFromClick) {
        return;
      }
      var delay = getDelay(false);
      if (delay) {
        hideTimeout = setTimeout(function () {
          if (instance.state.isVisible) {
            instance.hide();
          }
        }, delay);
      } else {
        // Fixes a `transitionend` problem when it fires 1 frame too
        // late sometimes, we don't want hide() to be called.
        scheduleHideAnimationFrame = requestAnimationFrame(function () {
          instance.hide();
        });
      }
    } // ===========================================================================
    //  Public methods
    // ===========================================================================

    function enable() {
      instance.state.isEnabled = true;
    }
    function disable() {
      // Disabling the instance should also hide it
      // https://github.com/atomiks/tippy.js-react/issues/106
      instance.hide();
      instance.state.isEnabled = false;
    }
    function clearDelayTimeouts() {
      clearTimeout(showTimeout);
      clearTimeout(hideTimeout);
      cancelAnimationFrame(scheduleHideAnimationFrame);
    }
    function setProps(partialProps) {
      if (instance.state.isDestroyed) {
        return;
      }
      invokeHook('onBeforeUpdate', [instance, partialProps]);
      removeListeners();
      var prevProps = instance.props;
      var nextProps = evaluateProps(reference, Object.assign({}, prevProps, removeUndefinedProps(partialProps), {
        ignoreAttributes: true
      }));
      instance.props = nextProps;
      addListeners();
      if (prevProps.interactiveDebounce !== nextProps.interactiveDebounce) {
        cleanupInteractiveMouseListeners();
        debouncedOnMouseMove = debounce(onMouseMove, nextProps.interactiveDebounce);
      } // Ensure stale aria-expanded attributes are removed

      if (prevProps.triggerTarget && !nextProps.triggerTarget) {
        normalizeToArray(prevProps.triggerTarget).forEach(function (node) {
          node.removeAttribute('aria-expanded');
        });
      } else if (nextProps.triggerTarget) {
        reference.removeAttribute('aria-expanded');
      }
      handleAriaExpandedAttribute();
      handleStyles();
      if (onUpdate) {
        onUpdate(prevProps, nextProps);
      }
      if (instance.popperInstance) {
        createPopperInstance(); // Fixes an issue with nested tippies if they are all getting re-rendered,
        // and the nested ones get re-rendered first.
        // https://github.com/atomiks/tippyjs-react/issues/177
        // TODO: find a cleaner / more efficient solution(!)

        getNestedPopperTree().forEach(function (nestedPopper) {
          // React (and other UI libs likely) requires a rAF wrapper as it flushes
          // its work in one
          requestAnimationFrame(nestedPopper._tippy.popperInstance.forceUpdate);
        });
      }
      invokeHook('onAfterUpdate', [instance, partialProps]);
    }
    function setContent(content) {
      instance.setProps({
        content: content
      });
    }
    function show() {

      var isAlreadyVisible = instance.state.isVisible;
      var isDestroyed = instance.state.isDestroyed;
      var isDisabled = !instance.state.isEnabled;
      var isTouchAndTouchDisabled = currentInput.isTouch && !instance.props.touch;
      var duration = getValueAtIndexOrReturn(instance.props.duration, 0, defaultProps.duration);
      if (isAlreadyVisible || isDestroyed || isDisabled || isTouchAndTouchDisabled) {
        return;
      } // Normalize `disabled` behavior across browsers.
      // Firefox allows events on disabled elements, but Chrome doesn't.
      // Using a wrapper element (i.e. <span>) is recommended.

      if (getCurrentTarget().hasAttribute('disabled')) {
        return;
      }
      invokeHook('onShow', [instance], false);
      if (instance.props.onShow(instance) === false) {
        return;
      }
      instance.state.isVisible = true;
      if (getIsDefaultRenderFn()) {
        popper.style.visibility = 'visible';
      }
      handleStyles();
      addDocumentPress();
      if (!instance.state.isMounted) {
        popper.style.transition = 'none';
      } // If flipping to the opposite side after hiding at least once, the
      // animation will use the wrong placement without resetting the duration

      if (getIsDefaultRenderFn()) {
        var _getDefaultTemplateCh2 = getDefaultTemplateChildren(),
          box = _getDefaultTemplateCh2.box,
          content = _getDefaultTemplateCh2.content;
        setTransitionDuration([box, content], 0);
      }
      onFirstUpdate = function onFirstUpdate() {
        var _instance$popperInsta2;
        if (!instance.state.isVisible || ignoreOnFirstUpdate) {
          return;
        }
        ignoreOnFirstUpdate = true; // reflow

        void popper.offsetHeight;
        popper.style.transition = instance.props.moveTransition;
        if (getIsDefaultRenderFn() && instance.props.animation) {
          var _getDefaultTemplateCh3 = getDefaultTemplateChildren(),
            _box = _getDefaultTemplateCh3.box,
            _content = _getDefaultTemplateCh3.content;
          setTransitionDuration([_box, _content], duration);
          setVisibilityState([_box, _content], 'visible');
        }
        handleAriaContentAttribute();
        handleAriaExpandedAttribute();
        pushIfUnique(mountedInstances, instance); // certain modifiers (e.g. `maxSize`) require a second update after the
        // popper has been positioned for the first time

        (_instance$popperInsta2 = instance.popperInstance) == null ? void 0 : _instance$popperInsta2.forceUpdate();
        invokeHook('onMount', [instance]);
        if (instance.props.animation && getIsDefaultRenderFn()) {
          onTransitionedIn(duration, function () {
            instance.state.isShown = true;
            invokeHook('onShown', [instance]);
          });
        }
      };
      mount();
    }
    function hide() {

      var isAlreadyHidden = !instance.state.isVisible;
      var isDestroyed = instance.state.isDestroyed;
      var isDisabled = !instance.state.isEnabled;
      var duration = getValueAtIndexOrReturn(instance.props.duration, 1, defaultProps.duration);
      if (isAlreadyHidden || isDestroyed || isDisabled) {
        return;
      }
      invokeHook('onHide', [instance], false);
      if (instance.props.onHide(instance) === false) {
        return;
      }
      instance.state.isVisible = false;
      instance.state.isShown = false;
      ignoreOnFirstUpdate = false;
      isVisibleFromClick = false;
      if (getIsDefaultRenderFn()) {
        popper.style.visibility = 'hidden';
      }
      cleanupInteractiveMouseListeners();
      removeDocumentPress();
      handleStyles(true);
      if (getIsDefaultRenderFn()) {
        var _getDefaultTemplateCh4 = getDefaultTemplateChildren(),
          box = _getDefaultTemplateCh4.box,
          content = _getDefaultTemplateCh4.content;
        if (instance.props.animation) {
          setTransitionDuration([box, content], duration);
          setVisibilityState([box, content], 'hidden');
        }
      }
      handleAriaContentAttribute();
      handleAriaExpandedAttribute();
      if (instance.props.animation) {
        if (getIsDefaultRenderFn()) {
          onTransitionedOut(duration, instance.unmount);
        }
      } else {
        instance.unmount();
      }
    }
    function hideWithInteractivity(event) {
      getDocument().addEventListener('mousemove', debouncedOnMouseMove);
      pushIfUnique(mouseMoveListeners, debouncedOnMouseMove);
      debouncedOnMouseMove(event);
    }
    function unmount() {
      if (instance.state.isVisible) {
        instance.hide();
      }
      if (!instance.state.isMounted) {
        return;
      }
      destroyPopperInstance(); // If a popper is not interactive, it will be appended outside the popper
      // tree by default. This seems mainly for interactive tippies, but we should
      // find a workaround if possible

      getNestedPopperTree().forEach(function (nestedPopper) {
        nestedPopper._tippy.unmount();
      });
      if (popper.parentNode) {
        popper.parentNode.removeChild(popper);
      }
      mountedInstances = mountedInstances.filter(function (i) {
        return i !== instance;
      });
      instance.state.isMounted = false;
      invokeHook('onHidden', [instance]);
    }
    function destroy() {
      if (instance.state.isDestroyed) {
        return;
      }
      instance.clearDelayTimeouts();
      instance.unmount();
      removeListeners();
      delete reference._tippy;
      instance.state.isDestroyed = true;
      invokeHook('onDestroy', [instance]);
    }
  }
  function tippy(targets, optionalProps) {
    if (optionalProps === void 0) {
      optionalProps = {};
    }
    var plugins = defaultProps.plugins.concat(optionalProps.plugins || []);
    bindGlobalEventListeners();
    var passedProps = Object.assign({}, optionalProps, {
      plugins: plugins
    });
    var elements = getArrayOfElements(targets);
    var instances = elements.reduce(function (acc, reference) {
      var instance = reference && createTippy(reference, passedProps);
      if (instance) {
        acc.push(instance);
      }
      return acc;
    }, []);
    return isElement(targets) ? instances[0] : instances;
  }
  tippy.defaultProps = defaultProps;
  tippy.setDefaultProps = setDefaultProps;
  tippy.currentInput = currentInput;

  // every time the popper is destroyed (i.e. a new target), removing the styles
  // and causing transitions to break for singletons when the console is open, but
  // most notably for non-transform styles being used, `gpuAcceleration: false`.

  Object.assign({}, applyStyles$1, {
    effect: function effect(_ref) {
      var state = _ref.state;
      var initialStyles = {
        popper: {
          position: state.options.strategy,
          left: '0',
          top: '0',
          margin: '0'
        },
        arrow: {
          position: 'absolute'
        },
        reference: {}
      };
      Object.assign(state.elements.popper.style, initialStyles.popper);
      state.styles = initialStyles;
      if (state.elements.arrow) {
        Object.assign(state.elements.arrow.style, initialStyles.arrow);
      } // intentionally return no cleanup function
      // return () => { ... }
    }
  });
  tippy.setDefaultProps({
    render: render
  });

  /**
   * @constructor Target
   * @example
   * Example of a Target model is
   *
   * retry: {
   *  interval : 0,
   *  max_retries : 0
   * }
   */
  var Target$1 = /*#__PURE__*/_createClass$1(function Target() {
    var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    _classCallCheck$1(this, Target);
    this.interval = getNumberOrDefault(data.interval, 0);
    this.max_retries = getNumberOrDefault(data.max_retries, 0);
  });

  /**
   * @constructor Target
   * @example
   * Example of a Target model is
   *
   * target: {
   *  id : "menuOverlay",
   *  frame_id : "",
   *  enable_retry : false,
   *  retry_interval : 0,
   *  max_retries : 0
   * }
   */
  var Target = /*#__PURE__*/_createClass$1(function Target() {
    var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    _classCallCheck$1(this, Target);
    this.id = getStringOrDefault(data.id, "");
    this.frame_id = getStringOrDefault(data === null || data === void 0 ? void 0 : data.frame_id, "");
    this.enable_retry = Boolean(data === null || data === void 0 ? void 0 : data.enable_retry);
    this.retry = new Target$1(data === null || data === void 0 ? void 0 : data.retry);
  });

  /**
   * @constructor Animation
   * @example
   * Example of a Animation model is
   *
   * animation: {
   *  type : "cycle",
   *  duration : 10,
   *  anim_function : "ease-in-out",
   *  iteration_count : 2,
   * }
   */
  var Animation = /*#__PURE__*/function () {
    function Animation() {
      var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck$1(this, Animation);
      this.type = getStringOrDefault(data.type, "cycle");
      this.duration = getNumberOrDefault(data.duration, 1);
      this.duration_millis = getNumberOrDefault(data.duration_millis, 1000) / 1000;
      this.anim_function = getStringOrDefault(data.anim_function, "ease-in-out");
      this.iteration_count = getNumberOrDefault(data.iteration_count, "infinite");
      this.ripplearea = getNumberOrDefault(data.ripple_area, 8);
      this.ripplecolor = getColorOrDefault(data.ripple_color, "#FFFFFF");
      this.direction = getStringOrDefault(data.direction, "horizontal");
      this.fade_opacity = getNumberOrDefault(data.fade_opacity, 50);
      this.shinecolor = getColorOrDefault(data.shine_color, "#FFFFFF");
    }
    _createClass$1(Animation, null, [{
      key: "isEnabled",
      value: function isEnabled(data) {
        if (isUndefined$1(data) || isNull(data) || isEmptyObject(data)) {
          return false;
        } else {
          return true;
        }
      }
    }]);
    return Animation;
  }();

  /**
   * @constructor Arrow
   * @example
   * Example of a Arrow model is
   *
   * arrow: {
   *  type : "progress-bar",
   *  color : "#FFFFFF",
   *  enable_border : true,
   *  border: {
   *   radius : 50,
   *   color : "#FFFFFF",
   *   width : 2,
   *   style : "dotted"
   *  }
   * }
   */
  var Arrow = /*#__PURE__*/function () {
    function Arrow() {
      var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var arrowDefaultColor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "#FFFFFF";
      _classCallCheck$1(this, Arrow);
      this.type = getStringOrDefault(data.type, "normal");
      this.color = getColorOrDefault(data.color, arrowDefaultColor);
      this.enable_border = data.enable_border;
      this.border = new Border(data.border);
    }
    _createClass$1(Arrow, null, [{
      key: "isEnabled",
      value: function isEnabled(data) {
        if (isUndefined$1(data) || isNull(data) || isEmptyObject(data)) {
          return false;
        } else {
          return true;
        }
      }
    }]);
    return Arrow;
  }();

  var Logger$2 = window.ApxorLogger;
  var InLineTooltip = /*#__PURE__*/function () {
    /**
     * @class InLineTooltip
     * @param {JSON} config
     * @param {string} configId
     * @param {string} name
     * @param {function} showCallback
     * @param {function} closeCallback
     */
    function InLineTooltip(config, uis, walkthroughConfigs, terminationConfig, messageConfig, rtmInstance, showCallback, hideCallback, stepperCallBack) {
      var _this = this;
      var isWalkthrough = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : false;
      var index = arguments.length > 10 && arguments[10] !== undefined ? arguments[10] : 0;
      _classCallCheck$1(this, InLineTooltip);
      /**
       * @function _getMarketingStyles
       * @private
       * @description Creates the styles for Marketing message.
       * @returns {string} css styles
       */
      _defineProperty$1(this, "_getMarketingStyles", function () {
        if (!_this.enable_marketing) {
          return "";
        }
        var message = _this.marketing.message;
        var alignment = message.alignment;
        if (message.alignment === "left") {
          alignment = "flex-start";
        } else if (message.alignment === "right") {
          alignment = "flex-end";
        }
        var marketingStyles = "\n      .apx-inline-marketing".concat(_this.cssPostFix, " {\n        align-self:").concat(alignment, ";\n        text-align:").concat(message.alignment, ";\n      }\n    ");
        return marketingStyles;
      });
      /**
       * @function _setMarketingMessage
       * @private
       * @description Sets the marketing content at the end of the Inline
       */
      _defineProperty$1(this, "_setMarketingMessage", function () {
        if (_this.enable_marketing) {
          var marketingContainer = document.createElement("div");
          marketingContainer.classList.add("apx-inline-marketing".concat(_this.cssPostFix));
          var marketingTextElement = createNewTextElement(_this.marketing.message, _this.currentId, "marketing");
          marketingContainer.appendChild(marketingTextElement);
          _this.inLineContainer.appendChild(marketingContainer);
        }
      });
      this.uiConfig = config;
      this.uis = uis;
      this.isWalkthrough = isWalkthrough;
      this.index = index;
      this.walkthroughConfigs = walkthroughConfigs;
      this.messageConfig = messageConfig;
      this.rtmInstance = rtmInstance;
      this.currentId = makeid(10);

      // Read name and id of the config
      this.configId = messageConfig.configId;
      this.name = messageConfig.configName;
      this.cssPostFix = "-".concat(this.configId, "-").concat(this.name).replaceAll(" ", "").replace(/[^\w\s]/gi, "");
      this.showCallback = showCallback;
      this.closeCallback = hideCallback;
      this.stepperCallBack = stepperCallBack;
      this.targetDeletionObserver = null;
      this.viewPortObservor = null;
      this.tooltipShown = false;
      this.terminationConfig = terminationConfig;
      this.terminationTimeoutId = null;
      /*****************************Configs********************************/
      this.delay = config.delay;
      this.scrollToView = config.scrollToView || true;
      this.background_color = config.bg_color || COLORS.WHITE;
      this.width = config.width || 50; // Scale of the screen
      this.height = config.height || 50; // Mostly auto. But for scrollable templates, should be the pixels.
      this.append_to = config.append_to || "parent"; // Can be set to 'body' 'parent'
      this.follow_cursor = config.followCursor || false; // Can be set to 'horizontal' 'vertical' 'initial'
      this.interactive_border = config.interactive_border || 10; // Determines the invisible border around the tippy that will prevent it from hiding if the cursorleft it

      this.target = new Target(config.target);
      this.direction = new Direction(config.direction);
      this.position = new Position(config.position);
      this.enable_dismiss_actions = config.enable_dismiss_actions;
      if (this.enable_dismiss_actions) this.dismiss_actions = new DismissActions(config.dismiss_actions);
      this.enable_dimbackground = config.enable_dimbackground;
      if (this.enable_dimbackground) this.dimbackground = new DimBackground(config.dimbackground);
      this.enable_padding = config.enable_padding;
      if (this.enable_padding) this.padding = new Padding(config.padding);
      this.enable_margin = config.enable_margin;
      if (this.enable_margin) this.margin = new Margin(config.margin);
      this.enable_border = config.enable_border;
      if (this.enable_border) this.border = new Border(config.border);
      this.enable_close_button = config.enable_close_button;
      if (this.enable_close_button) this.close_button = new CloseButton(config.close_button);
      this.enable_scroll = config.enable_scroll;
      if (this.enable_scroll) this.scroll = new Scroll(config.scroll);
      this.enable_icon = config.enable_icon;
      if (this.enable_icon) this.icon = new Icon(config.icon);
      this.enable_image = config.enable_image;
      if (this.enable_image) this.image = new Image(config.image);
      this.enable_video = config.enable_video;
      if (this.enable_video) this.video = new Video(config.video);
      this.enable_title = config.enable_title;
      if (this.enable_title) this.title = new Title(config.title);
      this.enable_description = config.enable_description;
      if (this.enable_description) this.description = new Description(config.description);
      this.enable_stepper = config.enable_stepper;
      if (this.enable_stepper) this.stepper = new Stepper(config.stepper);
      this.enable_buttons = config.enable_buttons;
      if (this.enable_buttons) this.buttons = new Buttons(config.buttons);
      this.enable_shadow = config.enable_shadow;
      if (this.enable_shadow) this.shadow = new Shadow(config.shadow);
      this.enable_animation = config.enable_animation;
      if (this.enable_animation) this.animation = new Animation(config.animation);
      this.enable_gradient = config.enable_gradient;
      if (this.enable_gradient) this.gradient = new Gradient(config.gradient);
      this.enable_arrow = config.enable_arrow;
      if (this.enable_arrow) this.arrow = new Arrow(config.arrow, this.background_color);
      this.enable_marketing = config.enable_marketing;
      if (this.enable_marketing) this.marketing = new Marketing(config.marketing);
      this.min_width = "";
      this.inline_width = "auto";
      this.inline_height = "auto";
      this.media_width = "auto";
      this.media_height = "auto";
      this.media_container_height = 0;
      this.targetElement = null;
      // svg mask is preventing the click event from being registered. Hence placing an invisible overlay on top of the SVG mask area where target element is present and attaching the click event listener to this overlay.
      this.targetOverlayElement = null;
      this.inLineContainer = null;
      this.textContainer = null;
      this.tooltip = null;
      this.dimBackgroundElement = null;
      this.maskingElement = null;
      this.max_width = 350;

      //badge related config
      this.flag = true;
      this.flutterClickCallbackWrapper = null;
    }
    _createClass$1(InLineTooltip, [{
      key: "createNewTooltip",
      value: function createNewTooltip() {
        var _this2 = this;
        try {
          // Check if a tooltip can be created.
          var canCreate = this._canCreateTooltip();
          //If a tooltip can be created
          if (canCreate) {
            // Called when the target element comes into the viewport to show the tooltip
            var targetReachedCallback = function targetReachedCallback() {
              _this2.rtmInstance.currentAction = _this2._destroyTooltip;
              //Set the tooltip dimensions.
              _this2._setInLineDimensions();
              //Set the InLine styles
              _this2._setInlineStyles();
              //Set the offset to properly align arrow w.r.t view element
              _this2._offsetAdjustment();
              //Set the content
              _this2._setInLineContent();
              // Set the obervors.
              _this2._setObservors();
              setTimeout(function () {
                // Create a tippy instance
                _this2._createTippyInstance();
              }, _this2.delay);
            };

            // Called when the valid target is found to show the tooltip
            var targetValidCallback = function targetValidCallback() {
              //Once the target is found then scroll into it.
              _this2._scrollIntoTargetIfNeeded(targetReachedCallback);
            };

            // Set the target for InLine tooltip
            this._setTheTarget(targetValidCallback);
          }
        } catch (e) {
          this._resetRTMAction();
        }
      }

      /**
       * @function _canCreateTooltip
       * @private
       * @description Checks if an action is already being performed.
       * A new tooltip can be created only if no other step/campaign is being shown.
       * @returns {boolean} true  - If a new tooltip can be created
       *                    false - A new tooltip can not be created.
       */
    }, {
      key: "_canCreateTooltip",
      value: function _canCreateTooltip() {
        if (this.rtmInstance.currentAction !== null && this.rtmInstance.currentAction !== undefined || this.rtmInstance.isShowingAction) {
          Logger$2.info("An nudge is being shown. Can not show a tooltip now");
          return false;
        }
        return true;
      }

      /**
       * @function _setTheTarget
       * @private
       * @description Sets the target for the tooltip. This is the target element that is given to tippy
       * @param {function} targetValidCallback
       */
    }, {
      key: "_setTheTarget",
      value: function _setTheTarget(targetValidCallback) {
        var _this3 = this;
        var targetFoundCallback = function targetFoundCallback() {
          var isElementVisible = _this3._isElementVisible();
          var isTargetElementCovered = isElementCovered(_this3.targetElement);
          if (isTargetElementCovered) {
            Logger$2.info("The tooltip is not visible because another element is overlapping the target element.");
            _this3._resetRTMAction();
          } else {
            if (isElementVisible) {
              // Attch a click callback to the target. If the target dismiss config is true, it will dismiss the tooltip
              _this3._targetClickCallback = _this3._targetClickCallback.bind(_this3);
              _this3.targetElement.addEventListener("click", _this3._targetClickCallback);
              targetValidCallback();
            } else {
              Logger$2.info("Invalid target element. Width and height are 0 for element: ".concat(_this3.target.id, ". Can't show tooltip"));
              _this3._resetRTMAction();
            }
          }
        };
        this._findTargetElement(targetFoundCallback);
      }

      /**
       * @function _isElementVisible
       * @private
       * @description Checks if the element has a visible height and width
       * @returns {boolean} true  - If element is visible
       *                    false - If the element is not visible
       */
    }, {
      key: "_isElementVisible",
      value: function _isElementVisible() {
        try {
          var rect = this.targetElement.getBoundingClientRect();
          if (rect.width === 0 || rect.height === 0) {
            return false;
          }
        } catch (e) {
          return false;
        }
        return true;
      }

      /**
       * @function _findTargetElement
       * @private
       * @description Finds the target element in the DOM.
       * @param {function} targetFoundCallback
       */
    }, {
      key: "_findTargetElement",
      value: function _findTargetElement(targetFoundCallback) {
        var _this4 = this;
        if (Apxor.isFlutter()) {
          var _this$messageConfig = this.messageConfig;
            _this$messageConfig.configId;
            _this$messageConfig.configName;
          this.uiConfig.dismiss_target_touch;
          this.targetElement = createTargetView(getElementPositionFromFlutter(this.target.id));
          if (this.targetElement) {
            this.flutterClickCallbackWrapper = addClickListenerForFlutterElement(this.targetElement, function () {
              /*attach a click listener for target view*/
              _this4._targetClickCallback();
            });
          }
        } else {
          this.targetElement = getElementFromSelector(this.target.id, this.target.frame_id);
        }
        if (!this.targetElement) {
          if (this.target.enable_retry) {
            Logger$2.info("Not found yet. Rechecking the DOM.");
            this._retryFindingTargetElement(targetFoundCallback);
          } else {
            Logger$2.info("Element with selector:".concat(this.target.id, " not found."));
            this._resetRTMAction();
          }
        } else {
          targetFoundCallback();
        }
      }

      /**
       * @function _retryFindingTargetElement
       * @private
       * @description Continuously rechecks the DOM for the target element after every retry_interval.
       * Maximum times it checks is configured through max_retries
       * @param {function} targetFoundCallback
       */
    }, {
      key: "_retryFindingTargetElement",
      value: function _retryFindingTargetElement(targetFoundCallback) {
        var _this5 = this;
        //After every find_interval check the DOM for target element.
        var rtmInstance = window.ApxorRTM;
        var elementRecheckIntervalId = setInterval(function () {
          if (rtmInstance.currentAction !== null && rtmInstance.currentAction !== undefined) {
            clearInterval(elementRecheckIntervalId);
            return;
          }
          if (Apxor.isFlutter()) {
            var _this5$messageConfig = _this5.messageConfig;
              _this5$messageConfig.configId;
              _this5$messageConfig.configName;
            _this5.uiConfig.dismiss_target_touch;
            _this5.targetElement = createTargetView(getElementPositionFromFlutter(_this5.target.id));
            if (_this5.targetElement) {
              _this5.flutterClickCallbackWrapper = addClickListenerForFlutterElement(_this5.targetElement, function () {
                _this5._targetClickCallback();
              });
            }
          } else {
            _this5.targetElement = getElementFromSelector(_this5.target.id, _this5.target.frame_id);
          }
          //If the element is found, stop checking the DOM.
          if (_this5.targetElement) {
            clearInterval(elementRecheckIntervalId);
            targetFoundCallback(_this5.targetElement);
          } else {
            _this5.target.retry.max_retries = _this5.target.retry.max_retries - 1;
            // If the element is not found even after max interval, stop checking
            if (_this5.target.retry.max_retries <= 0) {
              clearInterval(elementRecheckIntervalId);
              console.warn("Element with selector:".concat(_this5.target.id, " not found."));
              _this5._resetRTMAction();
            }
          }
        }, this.target.retry.interval);
      }

      /**
       * @function _resetRTMAction
       * @private
       * @description Resets the current action on the RTM.
       */
    }, {
      key: "_resetRTMAction",
      value: function _resetRTMAction() {
        this.rtmInstance.currentAction = null;
        this.rtmInstance.isShowingAction = false;
        Logger$2.info("RTM tooltip action stopped.");
      }

      /**
       * @function _scrollIntoTargetIfNeeded
       * @private
       * @description Scrolls into the target element if needed.
       * @param {function} targetReachedCallback
       */
    }, {
      key: "_scrollIntoTargetIfNeeded",
      value: function _scrollIntoTargetIfNeeded(targetReachedCallback) {
        var scrolled = false;
        var isTargetInViewPort = isElementInViewport(this.targetElement);
        // If the element is not in the viewport. scroll into the target element only if the config says so.
        if (!isTargetInViewPort) {
          if (this.scrollToView) {
            // We only use one scroll behaviour for tooltips.
            var scrollIntoViewOptions = {
              behavior: SCROLL_BEHAVIOUR.SMOOTH,
              block: CENTER,
              inline: CENTER
            };
            this.targetElement.scrollIntoView(scrollIntoViewOptions);
            scrolled = true;
          } else {
            Logger$2.info("If needed change the config to scroll to the target element.");
          }
        } else {
          scrolled = true;
        }

        // If the target is in viewport
        if (scrolled) {
          targetReachedCallback();
        }
      }

      /**
       * @function _setInLineDimensions
       * @private
       * @description Sets the width and height of the tooltip based on the type of the InLine.
       */
    }, {
      key: "_setInLineDimensions",
      value: function _setInLineDimensions() {
        var scale = this.direction.nudge === DIRECTION.VERTICAL ? this.width / 100 : this.height / 100;
        var calculateFromHeight = this.direction.nudge === DIRECTION.VERTICAL ? false : true;
        if (this.enable_image) {
          this._setDimenstionFromResolution(this.image.width, this.image.height, scale, calculateFromHeight);
        } else if (this.enable_video) {
          if (this.video.enable_embed) {
            if (this.direction.nudge === DIRECTION.VERTICAL) {
              this.inline_width = "".concat(this.video.width + (this.enable_border ? this.border.width * 2 : 0), "px");
              this.media_width = "".concat(this.video.width, "px");
              this.media_height = "".concat(this.video.height, "px");
            } else {
              this.inline_height = "".concat(this.video.height, "px");
              this.media_height = "".concat(this.video.height, "px");
              this.media_container_height = this.video.height;
              this.min_width = "".concat(this.getPixelsFromPercentage(this.width, false), "px");
            }
          } else {
            this._setDimenstionFromResolution(this.video.width, this.video.height, scale, calculateFromHeight);
          }
        } else if (this.enable_icon) {
          if (this.direction.nudge === DIRECTION.VERTICAL) {
            this.inline_width = "".concat(this.getPixelsFromPercentage(this.width, false), "px");
          } else {
            //this.inline_height = `${this.height}%`;
            this.min_width = "".concat(this.getPixelsFromPercentage(this.width, false), "px");
          }
        } else {
          if (this.direction.nudge === DIRECTION.VERTICAL) {
            this.inline_width = "".concat(this.getPixelsFromPercentage(this.width, false), "px");
          }
        }
      }

      /**
       * @function _setDimenstionFromResolution
       * @private
       * @description For image and video type of InLines, tooltip width and height must be calculated along the lines of resolution.
       * @param {number} width
       * @param {number} height
       * @param {number} scale
       */
    }, {
      key: "_setDimenstionFromResolution",
      value: function _setDimenstionFromResolution(width, height) {
        var scale = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.5;
        var calculateFromHeight = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
        var dimensions = getHeightWidthFromResolution({
          width: width,
          height: height
        }, scale, calculateFromHeight);
        this.media_width = "".concat(dimensions.width, "px");
        this.media_height = "".concat(dimensions.height, "px");
        this.media_container_height = dimensions.height;
        if (this.direction.nudge === DIRECTION.VERTICAL) {
          this.inline_width = "".concat(dimensions.width + (this.enable_border ? this.border.width * 2 : 0) + (this.enable_padding ? this.padding.left + this.padding.right : 0), "px");
        } else {
          this.inline_height = "".concat(dimensions.height + (this.enable_border ? this.border.width * 2 : 0) + (this.enable_padding ? this.padding.top + this.padding.bottom : 0), "px");
          this.min_width = "".concat(this.getPixelsFromPercentage(this.width, false), "px");
        }
      }

      /**
       * @function _highlightInlineTarget
       * @private
       * @description Creates the overlay and dim background elements and adds them to the document body.
       */
    }, {
      key: "_highlightInlineTarget",
      value: function _highlightInlineTarget() {
        var _this6 = this;
        if (this.enable_dimbackground) {
          this.dimBackgroundElement = createMask(this.targetElement);
          if (Apxor.isFlutter()) {
            this.maskingElement = createSVGDivMask(this.targetElement);
            document.body.appendChild(this.maskingElement);
          }
          document.body.appendChild(this.dimBackgroundElement);
          this.targetOverlayElement = document.createElement("div");
          if (this.targetElement.getBoundingClientRect) {
            var _targetElement$getBou = this.targetElement.getBoundingClientRect(),
              x = _targetElement$getBou.x,
              y = _targetElement$getBou.y,
              width = _targetElement$getBou.width,
              height = _targetElement$getBou.height,
              left = _targetElement$getBou.left,
              top = _targetElement$getBou.top; // getBoundingClientRect is not consistent. Some browsers use x and y, while others use left and top

            setAttributes(this.targetOverlayElement, {
              id: "targetOverlayElement",
              style: "position: absolute; z-index: 999999; top: ".concat(y || top, "px; left: ").concat(x || left, "px; height: ").concat(height, "px; width: ").concat(width, "px;\n          ").concat(Apxor.isFlutter() ? "pointer-events:none;" : "")
            });
            document.body.appendChild(this.targetOverlayElement);
          }
          var maskOpening = this.dimBackgroundElement.querySelector("#tippyModalMaskOpening");
          maskOpening.addEventListener("click", this._targetClickCallback);
          if (this.enable_dismiss_actions && this.dismiss_actions.outside_touch) {
            this.dimBackgroundElement.addEventListener("click", function () {
              _this6._destroyTooltip();
            });
            if (Apxor.isFlutter()) {
              this.maskingElement.addEventListener("click", function () {
                _this6._destroyTooltip();
              });
            }
          }

          // let targetClickCallback = this._targetClickCallback.bind(this);

          this.targetOverlayElement.addEventListener("click", function () {
            _this6.targetElement.click();
          });
          //this.targetElement.setAttribute("apx-inline-dimbackground", "");
        } else {
          this.tooltip.setProps({
            onClickOutside: function onClickOutside() {
              if (_this6.enable_dismiss_actions && _this6.dismiss_actions.outside_touch) {
                _this6._destroyTooltip();
              }
            }
          });
        }
      }

      /**
       * @function _setInlineStyles
       * @private
       * @description Creates all the styles needed by the InLine Tooltip.
       */
    }, {
      key: "_setInlineStyles",
      value: function _setInlineStyles() {
        var apxor_tooltip_styles = document.querySelector("style[apx-tooltip-styles]");
        if (apxor_tooltip_styles) {
          return;
        }
        var styles = " \n      ".concat(this._getBackgroundContainerStyles(), " \n      ").concat(this._getInLineContainerStyles(), " \n      ").concat(this._getScrollStyles(), " \n      ").concat(this._getControlsStyles(), " \n      ").concat(this._getInLineMediaContainerStyles(), "\n      ").concat(this._getInLineNonMediaContainerStyles(), "\n      ").concat(this._getTextConatinerStyles(), "\n      ").concat(this._getTitleStyles(), " \n      ").concat(this._getDescriptionStyles(), " \n      ").concat(this._getInLineButtonContainerStyles(), " \n      ").concat(this._getIconStyles(), " \n      ").concat(this._getImageStyles(), " \n      ").concat(this._getVideoStyles(), " \n      ").concat(this._getMarketingStyles(), "\n      ").concat(this._getTippyStyles(), "\n      ").concat(this._getFooterStyles(), "\n      ").concat(this._getProgressBarStyles(), "\n      ").concat(this._getBootstrapiconsStyles(), " \n    ").replaceAll("\n", "").replace(/[\s]{2,999}/g, "");
        var styleNode = document.createElement("style");
        styleNode.setAttribute("apx-tooltip-styles", "");
        styleNode.innerHTML = styles;
        document.head.appendChild(styleNode);
      }
    }, {
      key: "_getFooterStyles",
      value: function _getFooterStyles() {
        var footerStyles = "\n    .apx-inline-footer-wrap".concat(this.cssPostFix, "{\n      flex-wrap:wrap;\n      gap:4px;\n    }\n    ");
        return footerStyles;
      }

      /**
       * @function _getBackgroundContainerStyles
       * @private
       * @description Creates the styles for the inline overlay and dimbackground overlay
       * @returns {string} css styles
       */
    }, {
      key: "_getBackgroundContainerStyles",
      value: function _getBackgroundContainerStyles() {
        /*
        ,inset 10px 0px 0px 0px ${hexToRGB(
            this.dimbackground.color,
            this.dimbackground.opacity
          )},inset -10px 0px 0px 0px ${hexToRGB(
            this.dimbackground.color,
            this.dimbackground.opacity
          )}
          */
        // Set the dim background color and opacity only if dim background is enabled.
        var backgroundContainerStyle = "";
        if (this.enable_dimbackground) {
          var _this$dimbackground$o, _this$dimbackground$c;
          // :where is used to reduce the specificity of this style.
          // If at all the target element has a position that should not get disturbed.
          backgroundContainerStyle = "\n      #tippyModalOverlayContainer {\n        -ms-filter: \"progid:dximagetransform.microsoft.gradient.alpha(Opacity=50)\";\n        filter: alpha(opacity=50);height: 100vh;left: 0;opacity: ".concat((_this$dimbackground$o = this.dimbackground.opacity) !== null && _this$dimbackground$o !== void 0 ? _this$dimbackground$o : 0.5, ";position: fixed;\n        top: 0;transition: all .3s ease-out;width: 100vw;z-index: 9999;fill: ").concat((_this$dimbackground$c = this.dimbackground.color) !== null && _this$dimbackground$c !== void 0 ? _this$dimbackground$c : "transparent", "\n      }\n      #tippyModalOverlayContainer #tippyModalMask, #tippyModalOverlayContainer #tippyModalMaskRect {\n        height: 100vh;width: 100vw\n      }\n      \n    ");
          /*
          :where([apx-inline-dimbackground]) {
            box-shadow: 0 0 0 max(100vh, 100vw) ${hexToRGB(
              this.dimbackground.color,
              this.dimbackground.opacity
            )};
            z-index:9999;
            overflow: visible;
            position:relative;
          }*/
        }

        return backgroundContainerStyle;
      }

      /**
       * @function _getInLineContainerStyles
       * @private
       * @description Creates the styles for the inline container
       * @returns {string} css styles
       */
    }, {
      key: "_getInLineContainerStyles",
      value: function _getInLineContainerStyles() {
        var minWidthStyle = "";
        if (this.min_width) {
          minWidthStyle = "min-width:".concat(this.min_width, ";");
        }
        var borderStylesForContainer = "";
        if (this.enable_border) {
          borderStylesForContainer = "\n        border-radius: ".concat(this.border.radius, "px;\n        border: ").concat(this.border.width, "px ").concat(this.border.style, " ").concat(this.border.color, ";\n      ");
        }
        var gradientStylesForContainer = "";
        if (this.enable_gradient) {
          gradientStylesForContainer = "\n        background-image:linear-gradient(".concat(this.gradient.direction, ", ").concat(this.gradient.colors[0], ", ").concat(this.gradient.colors[1], ");\n      ");
        }
        var shadowStylesForContainer = "";
        if (this.enable_shadow) {
          shadowStylesForContainer = "\n      box-shadow: ".concat(this.shadow.offset_x, "px ").concat(this.shadow.offset_y, "px ").concat(this.shadow.blur_radius, "px ").concat(this.shadow.spread_radius, "px ").concat(this.shadow.color, ";\n      ");
        }
        var paddingStylesForContainer = "";
        if (this.enable_padding) {
          paddingStylesForContainer = "\n        padding:".concat(this.padding.top, "px ").concat(this.padding.right, "px ").concat(this.padding.bottom, "px ").concat(this.padding.left, "px;\n      ");
        }
        var flexStylesForContainer = this.direction.nudge !== DIRECTION.VERTICAL ? "flex-direction:row;" : "flex-direction:column;";
        flexStylesForContainer = " ".concat(flexStylesForContainer, "\n      justify-content:space-evenly;\n      align-items:center;\n      display:flex;\n    ");
        var maxWidth = "",
          maxHeight = "";
        if (this.enable_video && this.video.enable_embed) {
          maxWidth = "max-width:100%;";
          maxHeight = "max-height:100%;";
        }

        //justify-content: space-evenly;
        //align-items:stretch
        var inlineContainerStyles = "\n      .apx-inline-container".concat(this.cssPostFix, " {\n        height:").concat(this.inline_height, ";\n        width:").concat(this.inline_width, ";\n        margin: auto;\n        background-color:").concat(this.background_color, ";\n        z-index:9997;\n        opacity:0;\n        transition:all .5s cubic-bezier(.96,.23,.07,.8);\n        position:fixed;\n        visibility:hidden;\n\n        ").concat(minWidthStyle, "\n        ").concat(flexStylesForContainer, "\n        ").concat(paddingStylesForContainer, "\n        ").concat(borderStylesForContainer, "\n        ").concat(gradientStylesForContainer, "\n        ").concat(shadowStylesForContainer, "\n        ").concat(maxWidth, "\n        ").concat(maxHeight, "\n      }\n\n      .apx-inline-container").concat(this.cssPostFix, ".open{\n        opacity:1;\n        visibility:visible;\n      }\n    ");
        return inlineContainerStyles;
      }

      /**
       * @function _getScrollStyles
       * @private
       * @description Creates the styles for the scrollbar
       * @returns {string} css styles
       */
    }, {
      key: "_getScrollStyles",
      value: function _getScrollStyles() {
        var scrollStyles = "";
        var borderStyles = this.enable_scroll && this.scroll.enable_border ? "\n border-top: ".concat(this.scroll.border.width, "px ").concat(this.scroll.border.style, " ").concat(this.scroll.border.color, ";\n border-bottom : ").concat(this.scroll.border.width, "px ").concat(this.scroll.border.style, " ").concat(this.scroll.border.color, ";\n") : "";
        if (this.enable_scroll) {
          scrollStyles = "\n      .apx-inline-scroll".concat(this.cssPostFix, " {\n        overflow:scroll; \n        overflow-x: hidden;\n        height:").concat(this.scroll.height, "px;\n        ").concat(borderStyles, "\n      }\n    ");
        } else {
          scrollStyles = "\n      .apx-inline-scroll".concat(this.cssPostFix, " {\n        overflow : hidden;\n      }\n    ");
        }
        return scrollStyles;
      }

      /**
       * @function _getControlsStyles
       * @private
       * @description Creates the styles for any controls on the tooltip like the close control.
       * @returns {string} css styles
       */
    }, {
      key: "_getControlsStyles",
      value: function _getControlsStyles() {
        if (!this.enable_close_button) {
          return "";
        }
        var controlsStyles = "";
        if (this.direction.non_media === DIRECTION.VERTICAL || this.direction.nudge === DIRECTION.VERTICAL) {
          controlsStyles = "\n        .apx-inline-close".concat(this.cssPostFix, " {\n          position: absolute;\n          z-index:9999;\n          top: ").concat(this.close_button.offset_top, "px;\n          right: ").concat(this.close_button.offset_right, "px;\n          width: ").concat(this.close_button.width, "px;\n          height:  ").concat(this.close_button.height, "px;\n          cursor: pointer;\n        }\n      ");
        } else {
          controlsStyles = "\n      .apx-inline-close".concat(this.cssPostFix, " {\n        display:flex;\n        flex-direction:row;\n        justify-content:center;\n        align-items:center;\n        width: ").concat(this.close_button.width, "px;\n        height:  ").concat(this.close_button.height, "px;\n        cursor: pointer;\n        z-index:9999;\n      }\n      ");
        }
        return controlsStyles;
      }

      /**
       * @function _getInLineMediaContainerStyles
       * @private
       * @description Creates the styles for the inline Media container
       * @returns {string} css styles
       */
    }, {
      key: "_getInLineMediaContainerStyles",
      value: function _getInLineMediaContainerStyles() {
        var inlineMediaContainerStyles = "\n    .apx-inline-media-container".concat(this.cssPostFix, "{\n      ").concat(this.enable_icon ? "align-self:".concat(this.icon.alignment, ";") : "", "\n      ").concat(this.enable_image || this.enable_video ? "display:flex;" : "", "\n    }");
        return inlineMediaContainerStyles;
      }

      /**
       * @function _getInLineNonMediaContainerStyles
       * @private
       * @description Creates the styles for the inline Non-Media container
       * @returns {string} css styles
       */
    }, {
      key: "_getInLineNonMediaContainerStyles",
      value: function _getInLineNonMediaContainerStyles() {
        var maxHeight = "";
        if (this.direction.nudge === DIRECTION.VERTICAL) {
          maxHeight = "max-height:".concat(window.innerHeight - this.media_container_height, "px;");
        } else {
          if (!this.enable_icon) {
            maxHeight = "max-height:".concat(this.media_container_height, "px;");
          }
        }
        var inlineNonMediaContainerStyles = "";
        if (this.direction.non_media === DIRECTION.VERTICAL) {
          inlineNonMediaContainerStyles = "\n        .apx-inline-nonmedia-container".concat(this.cssPostFix, "{\n          width:100%;\n          max-width:").concat(this.inline_width, ";\n          display:flex;\n          flex-direction:column;\n          justify-content:center;\n          align-items:stretch;\n          ").concat(maxHeight, "\n        }\n      ");
        } else {
          inlineNonMediaContainerStyles = "\n        .apx-inline-nonmedia-container".concat(this.cssPostFix, "{\n          width:100%;\n          flex-grow:2;\n          display:flex;\n          flex-direction:row;\n          justify-content:space-between;\n          align-items:center;\n          ").concat(maxHeight, "\n        }\n      ");
        }
        return inlineNonMediaContainerStyles;
      }

      /**
       * @function _getTextContainerStyles
       * @private
       * @description Creates the styles for the text container
       * @returns {string} css styles
       */
    }, {
      key: "_getTextConatinerStyles",
      value: function _getTextConatinerStyles() {
        var contentStyling = "\n      .apx-inline-text-container".concat(this.cssPostFix, "{\n        width:100%;\n        display:flex;\n        flex-direction:column;\n        justify-content: center;\n        overflow: hidden;\n        align-items:center;\n        cursor:text;\n      }\n    ");
        return contentStyling;
      }

      /**
       * @function _getScrollStyles
       * @private
       * @description Creates the styles for the title
       * @returns {string} css styles
       */
    }, {
      key: "_getTitleStyles",
      value: function _getTitleStyles() {
        if (!this.enable_title) {
          return "";
        }
        var titleIconStyles = "";
        if (this.title.enable_icon) {
          var iconBorderStyles = "";
          if (this.title.icon.enable_border) {
            iconBorderStyles = "border-radius:".concat(this.title.icon.border.radius, "%;\n        border:").concat(this.title.icon.border.width, "px ").concat(this.title.icon.border.style, " ").concat(this.title.icon.border.color, ";");
          }
          titleIconStyles = "\n          height: ".concat(this.title.icon.height, "px;\n          width: ").concat(this.title.icon.width, "px;\n          margin-right: 15px;\n          ").concat(iconBorderStyles, "\n     ");
        }
        var titleMarginStyles = "";
        if (this.title.enable_margin) {
          titleMarginStyles = " \n        margin-top:".concat(this.title.margin.top, "px;\n        margin-bottom:").concat(this.title.margin.bottom, "px;\n        margin-left:").concat(this.title.margin.left, "px;\n        margin-right:").concat(this.title.margin.right, "px;\n      ");
        }
        var titlePaddingStyles = "";
        if (this.title.enable_padding) {
          titlePaddingStyles = " \n        padding-top:".concat(this.title.padding.top, "px;\n        padding-bottom:").concat(this.title.padding.bottom, "px;\n        padding-left:").concat(this.title.padding.left, "px;\n        padding-right:").concat(this.title.padding.right, "px;\n      ");
        }
        var titeStyles = "\n      .apx-inline-title-div".concat(this.cssPostFix, " {\n        width:100%;\n        display:flex;\n        justify-content:").concat(this.title.alignment, ";\n        text-align:").concat(this.title.alignment, ";\n        pointer-events:none;\n        ").concat(titleMarginStyles, "\n        ").concat(titlePaddingStyles, "\n      }\n      .apx-inline-title-icon").concat(this.cssPostFix, " {\n        ").concat(titleIconStyles, "\n      }\n    ");
        return titeStyles;
      }

      /**
       * @function _getDescriptionStyles
       * @private
       * @description Creates the styles for text description
       * @returns {string} css styles
       */
    }, {
      key: "_getDescriptionStyles",
      value: function _getDescriptionStyles() {
        if (!this.enable_description) {
          return "";
        }
        var descriptionMarginStyles = "";
        if (this.description.enable_margin) {
          descriptionMarginStyles = " \n        margin-top:".concat(this.description.margin.top, "px;\n        margin-bottom:").concat(this.description.margin.bottom, "px;\n        margin-left:").concat(this.description.margin.left, "px;\n        margin-right:").concat(this.description.margin.right, "px;\n      ");
        }
        var descriptionPaddingStyles = "";
        if (this.description.enable_padding) {
          descriptionPaddingStyles = " \n        padding-top:".concat(this.description.padding.top, "px;\n        padding-bottom:").concat(this.description.padding.bottom, "px;\n        padding-left:").concat(this.description.padding.left, "px;\n        padding-right:").concat(this.description.padding.right, "px;\n      ");
        }
        var descriptionStyles = "\n      .apx-inline-description".concat(this.cssPostFix, " {\n        width:100%;\n        justify-content:").concat(this.description.alignment, ";\n        text-align:").concat(this.description.alignment, ";\n        ").concat(descriptionMarginStyles, "\n        ").concat(descriptionPaddingStyles, "\n      }\n    ");
        return descriptionStyles;
      }

      /**
       * @function _getInLineButtonContainerStyles
       * @private
       * @description Creates the styles for the inline button container
       * @returns {string} css styles
       */
    }, {
      key: "_getInLineButtonContainerStyles",
      value: function _getInLineButtonContainerStyles() {
        var inlineButtonContainerStyles = "\n    .apx-inline-button-container".concat(this.cssPostFix, "{\n      display:flex;\n      flex-direction:row;\n      align-items:center;\n      justify-content:center;\n      margin:0 10px 0 10px;\n    }\n    .apx-inline-top-button-container").concat(this.cssPostFix, "{\n      width:100%;\n      height:auto;\n    }\n    .apx-inline-center-button-container").concat(this.cssPostFix, "{\n      width:100%;\n      height:auto;\n    }\n    .apx-inline-bottom-button-container").concat(this.cssPostFix, "{\n      width:100%;\n      height:auto;\n    }");
        return inlineButtonContainerStyles;
      }

      /**
       * @function _getIconStyles
       * @private
       * @description Creates the styles for icon, which is displayed above the title.
       * @returns {string} css styles
       */
    }, {
      key: "_getIconStyles",
      value: function _getIconStyles() {
        var iconStyles = "";
        if (this.enable_icon) {
          var iconBorderStyles = "";
          if (this.icon.enable_border) {
            iconBorderStyles = "\n          border-radius:".concat(this.icon.border.radius, "%;\n          border:").concat(this.icon.border.width, "px ").concat(this.icon.border.style, " ").concat(this.icon.border.color, ";\n      ");
          }
          var iconMarginStyles = "";
          if (this.icon.enable_margin) {
            iconMarginStyles = "\n          margin-top:".concat(this.icon.margin.top, "px;\n          margin-bottom:").concat(this.icon.margin.bottom, "px;\n          margin-left:").concat(this.icon.margin.left, "px;\n          margin-right:").concat(this.icon.margin.right, "px;\n        ");
          }
          var iconPaddingStyles = "";
          if (this.icon.enable_padding) {
            iconPaddingStyles = "\n          padding-top:".concat(this.icon.padding.top, "px;\n          padding-bottom:").concat(this.icon.padding.bottom, "px;\n          padding-left:").concat(this.icon.padding.left, "px;\n          padding-right:").concat(this.icon.padding.right, "px;\n        ");
          }
          iconStyles = "\n        .apx-inline-icon-container".concat(this.cssPostFix, " {\n          text-align:").concat(this.icon.alignment, ";\n        }\n        .apx-inline-icon-content").concat(this.cssPostFix, " {\n          height: ").concat(this.icon.height, "px;\n          width: ").concat(this.icon.width, "px;\n          ").concat(iconBorderStyles, "\n          ").concat(iconMarginStyles, "\n          ").concat(iconPaddingStyles, "\n        }\n      ");
        }
        return iconStyles;
      }

      /**
       * @function _getImageStyles
       * @private
       * @description Creates the styles for images, for both image only tooltip and tooltip with both image and text
       * @returns {string} css styles
       */
    }, {
      key: "_getImageStyles",
      value: function _getImageStyles() {
        var imageStyles = "";

        //Create the css for images only if image_config is sent.
        if (this.enable_image) {
          //Image can be used as a background image. Styles are different in that case.
          if (this.image.enable_background_image) {
            imageStyles = "\n            .apx-inline-image".concat(this.cssPostFix, "{\n              background-image: url('").concat(this.image.path, "');\n              background-repeat: no-repeat;\n              background-attachment: fixed; \n              background-size: 100% 100%;\n              height: ").concat(this.media_height, ";\n              width: ").concat(this.media_width, ";\n              box-shadow: inset ").concat(this.media_width, " ").concat(this.media_height, " 0px 0px ").concat(hexToRGB(this.image.background_image.mask_color, this.image.background_image.mask_opacity), ",inset -").concat(this.media_width, " -").concat(this.media_height, " 0px 0px ").concat(hexToRGB(this.image.background_image.mask_color, this.image.background_image.mask_opacity), "\n            }\n        ");
          } else {
            var imageBorderStyles = "";
            if (this.image.enable_border) {
              imageBorderStyles = "\n          border-radius:".concat(this.image.border.radius, "%;\n          border:").concat(this.image.border.width, "px ").concat(this.image.border.style, " ").concat(this.image.border.color, ";\n          ");
            }
            imageStyles = "\n        .apx-inline-image".concat(this.cssPostFix, "{\n          height: ").concat(this.media_height, ";\n          width: ").concat(this.media_width, ";\n          ").concat(imageBorderStyles, "\n        }\n      ");
          }
        }
        return imageStyles;
      }

      /**
       * @function _getVideoStyles
       * @private
       * @description Creates the styles for videos tooltips.
       * @returns {string} css styles
       */
    }, {
      key: "_getVideoStyles",
      value: function _getVideoStyles() {
        var videoStyles = "";
        if (this.enable_video) {
          var videoBorderStyles = "";
          if (this.video.enable_border) {
            videoBorderStyles = "\n        border-radius:".concat(this.video.border.radius, "%;\n        border:").concat(this.video.border.width, "px ").concat(this.video.border.style, " ").concat(this.video.border.color, ";\n        ");
          }
          videoStyles = "\n        .apx-inline-video".concat(this.cssPostFix, " {\n          width:").concat(this.media_width, ";\n          height:").concat(this.media_height, ";\n          ").concat(videoBorderStyles, "\n        }\n      ");
        }
        return videoStyles;
      }
    }, {
      key: "_getProgressBarStyles",
      value:
      /**
       * @function _getProgressBarStyles
       * @private
       * @description Creates the styles for ProgressBar.
       * @returns {string} css styles
       */
      function _getProgressBarStyles() {
        var progressBarStyles = "";
        if (this.has_progress_bar) {
          progressBarStyles = "\n      .apx-inline-progress-bar".concat(this.cssPostFix, "{\n        position: absolute;\n        width:100%;\n        height:").concat(this.progressbar.width, ";\n        ").concat(this.progressbar.position === "top" ? "top:0px;" : "bottom:0px;", "\n        left:0px;\n        z-index:9998;\n        overflow:hidden;\n        cursor: pointer;\n        background:").concat(this.progressbar.reamining_color, ";\n      }\n      .apx-inline-bar").concat(this.cssPostFix, "{\n        width:100%;\n        height:100%;\n        background:").concat(this.progressbar.progress_color, ";\n      }");
        }
        return progressBarStyles;
      }
      /**
       * @function _getTippyStyles
       * @private
       * @description Creates the theme for tippy.
       * @returns {string} css styles
       */
    }, {
      key: "_getTippyStyles",
      value: function _getTippyStyles() {
        var tippyTopArrowStyle = "";
        var tippyRightArrowStyle = "";
        var tippyBottomArrowStyle = "";
        var tippyLeftArrowStyle = "";
        if (this.enable_arrow) {
          switch (this.arrow.type) {
            case "round":
              {
                var tippyTop = -7;
                tippyTop = this.enable_padding ? tippyTop + this.padding.top + this.padding.bottom : tippyTop;
                tippyTop = this.enable_border ? tippyTop + this.border.width : tippyTop;
                if (!this.enable_close_button) {
                  tippyTop = tippyTop + 20;
                }
                var tippyLeft = this.enable_border ? 14 - this.border.width : 14;
                var tippyBottom = this.enable_border ? -7 + this.border.width : -7;
                var tippyRight = this.enable_border ? -3 + this.border.width : -3;
                tippyTopArrowStyle = "\n          bottom:-7px;\n          width:18px;\n          height:18px;\n          border-radius:5px;\n          transform: rotate(45deg);\n          background-color:".concat(this.arrow.color, ";\n          top:").concat(tippyTop, "px;\n          ");
                tippyRightArrowStyle = "\n          left:".concat(tippyRight, "px;\n          bottom:-7px;\n          width:18px;\n          height:18px;\n          border-radius:5px;\n          transform: rotate(45deg);\n          background-color:").concat(this.arrow.color, ";\n          ");
                tippyBottomArrowStyle = "\n          top:".concat(tippyBottom, "px;\n          width:18px;\n          height:18px;\n          border-radius:5px;\n          transform: rotate(45deg);\n          background-color:").concat(this.arrow.color, ";\n          ");
                tippyLeftArrowStyle = "\n          right:-7px;\n          bottom:-7px;\n          width:18px;\n          height:18px;\n          border-radius:5px;\n          transform: rotate(45deg);\n          background-color:".concat(this.arrow.color, ";\n          left:").concat(tippyLeft, "px;\n          ");
                break;
              }
            case "narrow":
              {
                var _tippyTop = -2;
                _tippyTop = this.enable_padding ? _tippyTop + this.padding.top + this.padding.bottom : _tippyTop;
                _tippyTop = this.enable_border ? _tippyTop + this.border.width : _tippyTop;
                if (!this.enable_close_button) {
                  _tippyTop = _tippyTop + 20;
                }
                var _tippyLeft = this.enable_border ? 25 - this.border.width : 25;
                var _tippyBottom = this.enable_border ? -12 + this.border.width : -12;
                var _tippyRight = this.enable_border ? -7 + this.border.width : -7;
                tippyTopArrowStyle = "\n          bottom:-10px;\n          border-width:18px 5px 0;\n          top:".concat(_tippyTop, "px;\n          ");
                tippyRightArrowStyle = "\n          left:".concat(_tippyRight, "px;\n          border-width:5px 18px 5px 0;\n          ");
                tippyBottomArrowStyle = "\n          top:".concat(_tippyBottom, "px;\n          border-width:0 5px 18px;\n          ");
                tippyLeftArrowStyle = "\n          right:-10px;\n          border-width:5px 0 5px 18px;\n          left:".concat(_tippyLeft, "px;\n          ");
                break;
              }
            case "wide":
              {
                var _tippyTop2 = -2;
                _tippyTop2 = this.enable_padding ? _tippyTop2 + this.padding.top + this.padding.bottom : _tippyTop2;
                _tippyTop2 = this.enable_border ? _tippyTop2 + this.border.width : _tippyTop2;
                if (!this.enable_close_button) {
                  _tippyTop2 = _tippyTop2 + 20;
                }
                var _tippyLeft2 = this.enable_border ? 25 - this.border.width : 25;
                var _tippyBottom2 = this.enable_border ? 12 - this.border.width : 12;
                var _tippyRight2 = this.enable_border ? 1 + this.border.width : 1;
                tippyTopArrowStyle = "\n          left:-50%;\n          bottom:-3px;\n          border-width:9px 18px 0;\n          top:".concat(_tippyTop2, "px;\n          ");
                tippyRightArrowStyle = "\n          top:-50%;\n          left:".concat(_tippyRight2, "px;\n          border-width:18px 9px 18px 0;\n          ");
                tippyBottomArrowStyle = "\n          left:-50%;\n          top:-8px;\n          border-width:0 18px 9px;\n          bottom:".concat(_tippyBottom2, "px;\n          ");
                tippyLeftArrowStyle = "\n          top:-50%;\n          right:-8px;\n          border-width:18px 0 18px 8px;\n          left:".concat(_tippyLeft2, "px;\n          ");
                break;
              }
            case "large":
              {
                var _tippyTop3 = -2;
                _tippyTop3 = this.enable_padding ? _tippyTop3 + this.padding.top + this.padding.bottom : _tippyTop3;
                _tippyTop3 = this.enable_border ? _tippyTop3 + this.border.width : _tippyTop3;
                if (!this.enable_close_button) {
                  _tippyTop3 = _tippyTop3 + 20;
                }
                var _tippyLeft3 = this.enable_border ? 25 - this.border.width : 25;
                var _tippyBottom3 = this.enable_border ? -10 + this.border.width : -10;
                var _tippyRight3 = this.enable_border ? -6 + this.border.width : -6;
                tippyTopArrowStyle = "\n          left:-50%;\n          bottom:-10px;\n          border-width:16px 16px 0;\n          top:".concat(_tippyTop3, "px;\n          ");
                tippyRightArrowStyle = "\n          top:-50%;\n          left:".concat(_tippyRight3, "px;\n          border-width:16px 16px 16px 0;\n          ");
                tippyBottomArrowStyle = "\n          left:-50%;\n          top:".concat(_tippyBottom3, "px;\n          border-width:0 16px 16px;\n          ");
                tippyLeftArrowStyle = "\n          top:-50%;\n          right:-10px;\n          border-width:16px 0 16px 16px;\n          left:".concat(_tippyLeft3, "px;\n          ");
                break;
              }
            case "small":
              {
                var _tippyTop4 = -4;
                _tippyTop4 = this.enable_padding ? _tippyTop4 + this.padding.top + this.padding.bottom : _tippyTop4;
                _tippyTop4 = this.enable_border ? _tippyTop4 + this.border.width : _tippyTop4;
                if (!this.enable_close_button) {
                  _tippyTop4 = _tippyTop4 + 20;
                }
                var _tippyRight4 = this.enable_border ? -2 + this.border.width : 0;
                var _tippyBottom4 = this.enable_border ? -6 + this.border.width : -5;
                var _tippyLeft4 = this.enable_border && this.border.width < 6 ? 16 + this.border.width : 18;
                tippyTopArrowStyle = "\n          left:-50%;\n          bottom:-5px;\n          border-width:16px 16px 0;\n          top:".concat(_tippyTop4, "px;\n          ");
                tippyRightArrowStyle = "\n          top:-50%;\n          left:".concat(_tippyRight4, "px;\n          border-width:16px 16px 16px 0;\n          ");
                tippyBottomArrowStyle = "\n          left:-50%;\n          top:".concat(_tippyBottom4, "px;\n          border-width:0 16px 16px;\n          ");
                tippyLeftArrowStyle = "\n          top:-50%;\n          right:-5px;\n          border-width:16px 0 16px 16px;\n          left:".concat(_tippyLeft4, "px;\n          ");
                break;
              }
            default:
              {
                var _tippyTop5 = -2;
                _tippyTop5 = this.enable_padding ? _tippyTop5 + this.padding.top + this.padding.bottom : _tippyTop5;
                _tippyTop5 = this.enable_border ? _tippyTop5 + this.border.width : _tippyTop5;
                if (!this.enable_close_button) {
                  _tippyTop5 = _tippyTop5 + 20;
                }
                var _tippyRight5 = this.enable_border ? 8 - this.border.width : 6;
                var _tippyLeft5 = this.enable_border && this.border.width < 6 ? 25 + this.border.width : 25;
                var _tippyBottom5 = this.enable_border ? -10 + this.border.width : -7;
                tippyTopArrowStyle = "\n          left:-50%;\n          bottom:-7px;\n          border-width:16px 16px 0;\n          top:".concat(_tippyTop5, "px;\n          ");
                tippyRightArrowStyle = "\n          top:-50%;\n          left:-7px;\n          border-width:16px 16px 16px 0;\n          right:".concat(_tippyRight5, "px;\n          ");
                tippyBottomArrowStyle = "\n          left:-50%;\n          top:".concat(_tippyBottom5, "px;\n          border-width:0 16px 16px;\n          ");
                tippyLeftArrowStyle = "\n          top:-50%;\n          right:-7px;\n          border-width:16px 0 16px 16px;\n          left:".concat(_tippyLeft5, "px;\n          ");
                break;
              }
          }
        }
        var tippy_styles = document.querySelector("style[data-tippy-stylesheet]");
        if (tippy_styles) {
          tippy_styles.remove();
        }

        /*
        .tippy-box[data-animation=fade][data-state=hidden]{opacity:0;} 
           [data-tippy-root] {max-width:calc(100vw - 10px);} 
           .tippy-box {position:relative;background-color:#333;color:#fff;border-radius:4px;font-size:14px;line-height:1.4;white-space:normal;outline:0;transition-property:transform,visibility,opacity;} 
           .tippy-box[data-placement^=top] > .tippy-arrow {bottom:0;} 
           .tippy-box[data-placement^=top] > .tippy-arrow:before {bottom:-7px;left:0;border-width:8px 8px 0;border-top-color:initial;transform-origin:center top;} 
           .tippy-box[data-placement^=bottom] > .tippy-arrow {top:0;} 
           .tippy-box[data-placement^=bottom] > .tippy-arrow:before {top:-7px;left:0;border-width:0 8px 8px;border-bottom-color:initial;transform-origin:center bottom;} 
           .tippy-box[data-placement^=left] > .tippy-arrow {right:0;} 
           .tippy-box[data-placement^=left] > .tippy-arrow:before {border-width:8px 0 8px 8px;border-left-color:initial;right:-7px;transform-origin:center left;} 
           .tippy-box[data-placement^=right] > .tippy-arrow {left:0;} 
           .tippy-box[data-placement^=right] > .tippy-arrow:before {left:-7px;border-width:8px 8px 8px 0;border-right-color:initial;transform-origin:center right;} 
           .tippy-box[data-inertia][data-state=visible] {transition-timing-function:cubic-bezier(.54,1.5,.38,1.11)} 
           .tippy-arrow {width:16px;height:16px;color:#333;} 
           .tippy-arrow:before{ content:"";position:absolute;border-color:transparent;border-style:solid;} 
           .tippy-content {position:relative;padding:5px 9px;z-index:1;} 
        */

        var animationStyles = "";
        if (this.enable_animation) {
          animationStyles = "\n        @-webkit-keyframes ".concat(this.animation.type, " {\n          0% { transform: ").concat(translateDir(this.position.position, 0), "; }\n          50% { transform: ").concat(translateDir(this.position.position, 50), "; }\n          100% { transform: ").concat(translateDir(this.position.position, 100), "; }\n         }\n  \n         @keyframes ").concat(this.animation.type, " {\n          0% { transform: ").concat(translateDir(this.position.position, 0), "; }\n          50% { transform: ").concat(translateDir(this.position.position, 50), "; }\n          100% { transform: ").concat(translateDir(this.position.position, 100), "; }\n         }\n  \n         .tippy-box {\n           animation-name: ").concat(this.animation.type, ";\n           animation-duration: ").concat(this.animation.duration, "ms;\n           animation-timing-function: ").concat(this.animation.anim_function, ";\n           animation-iteration-count: ").concat(this.animation.iteration_count, ";\n         }\n        ");
        }
        // Do not modify these. These tippy styles.
        var tippyStyles = "\n        .tippy-box[data-animation=\"fade\"][data-state=hidden]{\n          opacity:0;\n        } \n       [data-tippy-root] {\n          width:".concat(this.inline_width, ";\n          max-width:calc(100vw - ").concat(this.enable_arrow && this.arrow.enable_border ? this.arrow.border.width : 0, "px);\n        } \n       .tippy-box { \n          width:").concat(this.inline_width, ";\n          position:relative;\n          line-height:1.4;\n          white-space:normal;\n          outline:0;\n          transition-property:transform,visibility,opacity;\n        } \n       .tippy-box[data-placement^=top] > .tippy-arrow {\n          bottom:0;\n        } \n       .tippy-box[data-placement^=top] > .tippy-arrow:before {\n          ").concat(tippyTopArrowStyle, "\n          border-top-color:initial;\n          transform-origin:center top;\n        } \n       .tippy-box[data-placement^=bottom] > .tippy-arrow {\n          top:0;\n        } \n       .tippy-box[data-placement^=bottom] > .tippy-arrow:before {\n          ").concat(tippyBottomArrowStyle, "\n          border-bottom-color:initial;\n          transform-origin:center bottom;\n        } \n       .tippy-box[data-placement^=left] > .tippy-arrow {\n          right:0;\n        } \n       .tippy-box[data-placement^=left] > .tippy-arrow:before {\n          ").concat(tippyLeftArrowStyle, "\n          border-left-color:initial;\n          transform-origin:center left;\n        } \n       .tippy-box[data-placement^=right] > .tippy-arrow {\n          left:0;\n        } \n       .tippy-box[data-placement^=right] > .tippy-arrow:before {\n          ").concat(tippyRightArrowStyle, "\n          border-right-color:initial;\n          transform-origin:center right;\n        } \n       .tippy-box[data-inertia][data-state=visible] {\n          transition-timing-function:cubic-bezier(.54,1.5,.38,1.11)\n        } \n       .tippy-arrow {\n          z-index:9999;\n          width:18px;\n          height:18px;\n          color:").concat(this.enable_arrow ? this.arrow.color : "transparent", ";\n          opacity:0;\n          visibility:hidden;\n          transition:all .5s cubic-bezier(.96,.23,.07,.8);\n       } \n       .tippy-arrow.open {\n          opacity:1;\n          visibility:visible;\n       }\n       .tippy-arrow:before{ \n          content:\"\";\n          position:absolute;\n          border-color:transparent;\n          border-style:").concat(this.enable_arrow && this.arrow.enable_border ? this.arrow.border.style : "solid", ";\n       } \n       .tippy-content {\n        width:").concat(this.inline_width, ";\n        padding: 0.3125rem 0.5625rem;\n          position:relative;\n          z-index:9998;\n       } \n      ").concat(animationStyles, "\n    ");
        var tippyTheme = "\n       ".concat(tippyStyles, "\n    ");
        return tippyTheme;
      }

      /**
       * @function _getBootstrapiconsStyles
       * @private
       * @description Creates the styles for bootstrap icons.
       * @returns {string} css styles
       */
    }, {
      key: "_getBootstrapiconsStyles",
      value: function _getBootstrapiconsStyles() {
        var bootstrapiconStyles = "\n      .bi::before, [class^=\"bi-\"]::before, [class*=\" bi-\"]::before {\n        display: inline-block;\n        font-style: normal;\n        font-weight: normal !important;\n        font-variant: normal;\n        text-transform: none;\n        line-height: 1;\n        vertical-align: -.125em;\n        -webkit-font-smoothing: antialiased;\n        -moz-osx-font-smoothing: grayscale;\n      }\n      .bi-x::before { \n        content: \"62a\"; \n      }\n      .bi-x-circle-fill::before { \n        content: \"622\"; \n      }\n    ";
        return bootstrapiconStyles;
      }

      /**
       * @function _removeStyles
       * @private
       * @description Removes the tooltip styles tag
       */
    }, {
      key: "_removeStyles",
      value: function _removeStyles() {
        try {
          var apxor_tooltip_styles = document.querySelector("style[apx-tooltip-styles]");
          if (apxor_tooltip_styles) {
            apxor_tooltip_styles.remove();
          }
          var tippy_styles = document.querySelector("style[data-tippy-stylesheet]");
          if (tippy_styles) {
            tippy_styles.remove();
          }
        } catch (e) {
          Logger$2.error("Could not remove the tooltip styles:" + e);
        }
      }

      /**
       * @function _setInLineContent
       * @private
       * @description Sets the content of the InLine.
       */
    }, {
      key: "_setInLineContent",
      value: function _setInLineContent() {
        // Create the Tooltip container
        this._createInLineContainer();
        if (this.direction.nudge === DIRECTION.VERTICAL) {
          // Create Top Button container
          this._createTopButtonContainer();
          // Set the Top buttons
          this._setButtons(BUTTON_CONTAINER_POSITION.TOP);
        }

        // Create the Media container
        this._createMediaContainer();
        if (this.direction.nudge === DIRECTION.VERTICAL) {
          // Create Center button container
          this._createCenterButtonContainer();
          // Set the Center buttons
          this._setButtons(BUTTON_CONTAINER_POSITION.CENTER);
        }

        // For image-only InLine, set its properties
        this._setImageOptions();
        // For video-text InLine, set its properties
        this._setVideoOptions();
        // For icon-text InLine, set its properties
        this._setIconOptions();
        // Create Non-Media container
        this._createNonMediaContainer();
        // Set the text container
        this._setTextContainer();
        // Set the title content
        this._setTitleContent();
        // Set the description content in the text conatiner
        this._setDescriptionContent();
        // Create Buttom container
        this._createButtonContainer();

        // Create Bottom Button container
        this._createBottomButtonContainer();
        //set the Bottom buttons
        this._setButtons(BUTTON_CONTAINER_POSITION.BOTTOM);
        this._setProgressBar();
        // Set the close button
        this._setCloseButton();

        //Set the Marketing content
        this._setMarketingMessage();
      }

      /**
       * @function _createInLineContainer
       * @private
       * @description Creates the container for the InLine
       */
    }, {
      key: "_createInLineContainer",
      value: function _createInLineContainer() {
        // InLine tooltip container.
        this.inLineContainer = document.createElement("div");
        this.inLineContainer.classList.add("apx-inline-container".concat(this.cssPostFix));
      }

      /**
       * @function _createMediaContainer
       * @private
       * @description Creates the container for the image/icon/vedio
       */
    }, {
      key: "_createMediaContainer",
      value: function _createMediaContainer() {
        this.mediaContainer = document.createElement("div");
        this.mediaContainer.classList.add("apx-inline-media-container".concat(this.cssPostFix));
        this.inLineContainer.appendChild(this.mediaContainer);
      }

      /**
       * @function _setImageOptions
       * @private
       * @description Sets the image-only styles on the container. This is a specific config not applicable for all tooltips.
       */
    }, {
      key: "_setImageOptions",
      value: function _setImageOptions() {
        if (this.enable_image) {
          if (this.image.enable_background_image) {
            this.inLineContainer.classList.add("apx-inline-image".concat(this.cssPostFix));
          } else {
            //const imgDiv = document.createElement("div");
            var imgElement = document.createElement("img");
            imgElement.src = this.image.path;
            imgElement.classList.add("apx-inline-image".concat(this.cssPostFix));
            //imgDiv.appendChild(imgElement);
            this.mediaContainer.appendChild(imgElement);
          }
        }
      }

      /**
       * @function _setVideoOptions
       * @private
       * @description Sets the video-text styles on the container. This is a specific config not applicable for all tooltips.
       */
    }, {
      key: "_setVideoOptions",
      value: function _setVideoOptions() {
        if (this.enable_video) {
          if (this.video.enable_embed) {
            var videoDiv = document.createElement("div");
            videoDiv.classList.add("apx-inline-video".concat(this.cssPostFix));
            videoDiv.innerHTML = "".concat(this.video.embed.html);
            this.mediaContainer.appendChild(videoDiv);
          } else {
            var videoElement = document.createElement("video");
            videoElement.classList.add("apx-inline-video".concat(this.cssPostFix));
            videoElement.controlsList = "noplaybackrate nodownload";
            videoElement.disablePictureInPicture = true;
            videoElement.controls = true;
            videoElement.muted = !this.video.enable_audio;
            var sourceElement = document.createElement("source");
            //Set the video tag attributes
            sourceElement.setAttribute("src", this.video.path);
            sourceElement.setAttribute("type", "video/mp4");
            videoElement.appendChild(sourceElement);
            this.mediaContainer.appendChild(videoElement);
          }
        }
      }

      /**
       * @function _setIconOptions
       * @private
       * @description Sets the icon-text styles on the container. This is a specific config not applicable for all tooltips.
       */
    }, {
      key: "_setIconOptions",
      value: function _setIconOptions() {
        if (this.enable_icon) {
          var iconDiv = document.createElement("div");
          iconDiv.classList.add("apx-inline-icon-container".concat(this.cssPostFix));
          var iconElement = document.createElement("img");
          iconElement.src = this.icon.path;
          iconElement.classList.add("apx-inline-icon-content".concat(this.cssPostFix));
          iconDiv.appendChild(iconElement);
          this.mediaContainer.appendChild(iconDiv);
        }
      }

      /**
       * @function _createNonMediaContainer
       * @private
       * @description Creates the container for the text and buttom
       */
    }, {
      key: "_createNonMediaContainer",
      value: function _createNonMediaContainer() {
        this.nonMediaContainer = document.createElement("div");
        this.nonMediaContainer.classList.add("apx-inline-nonmedia-container".concat(this.cssPostFix));
        this.inLineContainer.appendChild(this.nonMediaContainer);
      }

      /**
       * @funciton _setTextContainer
       * @private
       * @description Sets the container for the title and the description
       */
    }, {
      key: "_setTextContainer",
      value: function _setTextContainer() {
        this.textContainer = document.createElement("div");
        this.textContainer.classList.add("apx-inline-text-container".concat(this.cssPostFix));
        this.nonMediaContainer.appendChild(this.textContainer);
      }

      /**
       * @funciton _setTitleContent
       * @private
       * @description Sets the title content in the InLine tooltip. This is a common config for all tooltips.
       */
    }, {
      key: "_setTitleContent",
      value: function _setTitleContent() {
        // Create an element for the title and append it to the container.
        if (this.enable_title) {
          // Before creating the text element, evaluate the dynamic text if any
          resolveDynamicText(this.title);
          var titleElement = document.createElement("div");
          titleElement.classList.add("apx-inline-title-div".concat(this.cssPostFix));
          if (this.title.enable_icon != "") {
            var titleIconElement = document.createElement("img");
            titleIconElement.src = this.title.icon.path;
            titleIconElement.classList.add("apx-inline-title-icon".concat(this.cssPostFix));
            titleElement.appendChild(titleIconElement);
          }
          titleElement.appendChild(createNewTextElement(this.title, this.currentId, "title"));
          this.textContainer.appendChild(titleElement);
        }
      }

      /**
       * @funciton _setDescriptionContent
       * @private
       * @description Sets the description content in the InLine tooltip. This is a common config for all tooltips.
       */
    }, {
      key: "_setDescriptionContent",
      value: function _setDescriptionContent() {
        // Create an element for the description and append it to the container.
        if (this.enable_description) {
          // Before creating the text element, evaluate the dynamic text if any
          resolveDynamicText(this.description);
          var textElement = document.createElement("div");
          textElement.classList.add("apx-inline-description".concat(this.cssPostFix));
          textElement.appendChild(createNewTextElement(this.description, this.currentId, "description"));
          textElement.classList.add("apx-inline-scroll".concat(this.cssPostFix));

          // this.inLineContainer.appendChild(textElement);
          this.textContainer.appendChild(textElement);
        }
      }
      /**
       * @function _setProgressBar
       * @private
       * @description Set the ProgressBar
       */
    }, {
      key: "_setProgressBar",
      value: function _setProgressBar() {
        if (this.enable_stepper && this.stepper.enable_progressbar) {
          this.progressbar = this.stepper.progressbar;
          var progressBar = document.createElement("div");
          progressBar.classList.add("apx-inline-progress-bar".concat(this.cssPostFix));
          var bar = document.createElement("div");
          bar.classList.add("apx-inline-bar".concat(this.cssPostFix));
          if (this.stepper.index <= this.stepper.length) {
            bar.style.transform = "translateX(".concat(-(100 - 100 / this.stepper.length * this.stepper.index), "%)");
          } else {
            progressBar.style.visibility = "hidden";
          }
          progressBar.appendChild(bar);
          this.inLineContainer.appendChild(progressBar);
        }
      }
      /**
       * @function _createButtomContainer
       * @private
       * @description Creates the container for the buttons
       */
    }, {
      key: "_createButtonContainer",
      value: function _createButtonContainer() {
        if (this.direction.non_media === DIRECTION.VERTICAL) {
          return;
        }
        this.buttonContainer = document.createElement("div");
        this.buttonContainer.classList.add("apx-inline-button-container".concat(this.cssPostFix));
        this.nonMediaContainer.appendChild(this.buttonContainer);
      }

      /**
       * @function _createTopButtomContainer
       * @private
       * @description Creates the container for the top buttons
       */
    }, {
      key: "_createTopButtonContainer",
      value: function _createTopButtonContainer() {
        var _this$buttons;
        if (this.enable_buttons && (_this$buttons = this.buttons) !== null && _this$buttons !== void 0 && _this$buttons.enable_top) {
          this.topButtonContainer = document.createElement("div");
          this.topButtonContainer.classList.add("apx-inline-top-button-container".concat(this.cssPostFix));
          this.inLineContainer.appendChild(this.topButtonContainer);
        }
      }
      /**
       * @function _createCenterButtomContainer
       * @private
       * @description Creates the container for the center buttons
       */
    }, {
      key: "_createCenterButtonContainer",
      value: function _createCenterButtonContainer() {
        var _this$buttons2;
        if (this.enable_buttons && (_this$buttons2 = this.buttons) !== null && _this$buttons2 !== void 0 && _this$buttons2.enable_center) {
          this.centerButtonContainer = document.createElement("div");
          this.centerButtonContainer.classList.add("apx-inline-center-button-container".concat(this.cssPostFix));
          this.inLineContainer.appendChild(this.centerButtonContainer);
        }
      }
      /**
       * @function _createBottomButtomContainer
       * @private
       * @description Creates the container for the bottom buttons
       */
    }, {
      key: "_createBottomButtonContainer",
      value: function _createBottomButtonContainer() {
        var _this$buttons3;
        if (this.enable_buttons && (_this$buttons3 = this.buttons) !== null && _this$buttons3 !== void 0 && _this$buttons3.enable_bottom) {
          this.bottomButtonContainer = document.createElement("div");
          this.bottomButtonContainer.classList.add("apx-inline-bottom-button-container".concat(this.cssPostFix));
          this.nonMediaContainer.appendChild(this.bottomButtonContainer);
        }
      }
      /**
       * @function _setButtons
       * @private
       * @description Generate the Button's and append them to the specified button container.
       *
       */
    }, {
      key: "_setButtons",
      value: function _setButtons(position) {
        var _this7 = this;
        if (!this.enable_buttons) {
          return;
        }
        if (position === BUTTON_CONTAINER_POSITION.TOP && this.buttons.enable_top || position === BUTTON_CONTAINER_POSITION.CENTER && this.buttons.enable_center || position === BUTTON_CONTAINER_POSITION.BOTTOM && this.buttons.enable_bottom) {
          var actionCallback = function actionCallback(isCancelled) {
            _this7._destroyTooltip(isCancelled);
            // this.closeCallback(overlay, action, ".apx-inline-container");
          };

          var next_Callback = function next_Callback(id, action) {
            actionCallback(false, "next");
            _this7.stepperCallBack(id, action);
          };
          var prev_Callback = function prev_Callback(id, action) {
            actionCallback(false, "prev");
            _this7.stepperCallBack(id, action);
          };
          var actionHandler = {
            next: next_Callback,
            prev: prev_Callback,
            complete: actionCallback,
            cancel: actionCallback,
            _isCancelled: false,
            action: ""
          };
          var buttons_config = {};
          if (position === BUTTON_CONTAINER_POSITION.TOP) {
            buttons_config = this.buttons.top;
          } else if (position === BUTTON_CONTAINER_POSITION.CENTER) {
            buttons_config = this.buttons.center;
          } else {
            buttons_config = this.buttons.bottom;
          }
          var _Buttons = generateButtonsBlock(this.configId, this.name, this.stepper, EVENT_PREFIX.INLINE, buttons_config, this.direction.buttons, "", position, actionHandler, this.isWalkthrough, this.uis, this.index);
          if (position === BUTTON_CONTAINER_POSITION.TOP) {
            this.topButtonContainer.appendChild(_Buttons);
          } else if (position === BUTTON_CONTAINER_POSITION.CENTER) {
            this.centerButtonContainer.appendChild(_Buttons);
          } else {
            this.bottomButtonContainer.appendChild(_Buttons);
          }
        }
      }

      /**
       * @function _setCloseButton
       * @private
       * @description If close is enabled set the close button on the tooltip. This is a common config for all tooltips.
       */
    }, {
      key: "_setCloseButton",
      value: function _setCloseButton() {
        var _this8 = this;
        if (this.enable_close_button) {
          var closeButton = document.createElement("span");
          // Close button SVG is decided based on the type of the button in the config.
          if (this.close_button.type === CLOSE_BUTTON_STYLE.NORMAL) {
            closeButton.innerHTML = getCloseSVG(this.close_button.width, this.close_button.height, this.close_button.color);
          } else if (this.close_button.type === CLOSE_BUTTON_STYLE.FILL) {
            if (this.close_button.shape === "circle") {
              closeButton.innerHTML = getCloseWithCircleSVG(this.close_button.width, this.close_button.height, this.close_button.fill_color, this.close_button.color);
            } else {
              closeButton.innerHTML = getCloseWithRectangleSVG(this.close_button.width, this.close_button.height, this.close_button.fill_color, this.close_button.color);
            }
          } else {
            closeButton.innerHTML = "<img src=\"".concat(this.close_button.path, "\" width=\"").concat(this.close_button.width, "px\" height=\"").concat(this.close_button.height, "px\"></img>");
          }
          closeButton.classList.add("apx-inline-close".concat(this.cssPostFix));
          closeButton.addEventListener("click", function () {
            var isCancelled = _this8.close_button.action === "cancel";
            _this8.rtmInstance.logActionEvent("InlineXIconClicked", _this8.configId, _this8.name);
            _this8._destroyTooltip(isCancelled);
          });
          this.direction.non_media === DIRECTION.VERTICAL || this.direction.nudge === DIRECTION.VERTICAL ? this.inLineContainer.appendChild(closeButton) : this.buttonContainer.appendChild(closeButton);
        }
      }
    }, {
      key: "_setObservors",
      value:
      /**
       * @function _setObservors
       * @private
       * @description Sets the obervors for identifying target deletion and target going out of view port.
       * In both these cases, tooltip needs to be destroyed.
       */
      function _setObservors() {
        var _this9 = this;
        // Add MutationObserver to the target element
        this.targetDeletionObserver = new MutationObserver(function () {
          if (!_this9.tooltipShown) {
            return;
          }
          if (!document.body.contains(_this9.targetElement)) {
            _this9._destroyTooltip();
          }
        });
        this.viewPortObservor = new IntersectionObserver(function () {
          if (!_this9.tooltipShown) {
            return;
          }
          var elementInViewPort = isElementInViewport(_this9.targetElement);
          if (!elementInViewPort) {
            _this9._destroyTooltip();
          }
        });
      }

      /**
       * @function _offsetAdjustment
       * @private
       * @description adjusts offset so that arrow points correctly on the view element
       */
    }, {
      key: "_offsetAdjustment",
      value: function _offsetAdjustment() {
        var _this$arrow;
        if ((_this$arrow = this.arrow) !== null && _this$arrow !== void 0 && _this$arrow.type) {
          switch (this.arrow.type) {
            case "round":
              {
                switch (this.position.position) {
                  case "top":
                    {
                      this.position.offset.distance = this.position.offset.distance + (this.enable_padding ? this.padding.top + this.padding.bottom : 0) + (this.enable_border ? this.border.width : 0);
                      break;
                    }
                  case "bottom":
                    this.position.offset.distance = this.position.offset.distance + 4;
                    break;
                  case "left":
                    this.position.offset.distance = this.position.offset.distance + 17;
                    break;
                  case "right":
                    this.position.offset.distance = this.position.offset.distance + -3;
                }
                break;
              }
            case "narrow":
              {
                switch (this.position.position) {
                  case "top":
                    {
                      this.position.offset.distance = this.position.offset.distance + (this.enable_padding ? this.padding.top + this.padding.bottom : 0) + (this.enable_border ? this.border.width : 0);
                      break;
                    }
                  case "bottom":
                    {
                      this.position.offset.distance = this.position.offset.distance + 10 - (this.enable_border ? this.border.width : 0);
                      break;
                    }
                  case "left":
                    {
                      this.position.offset.distance = this.position.offset.distance + 24 - (this.enable_border ? this.border.width : 0);
                      break;
                    }
                  case "right":
                    {
                      this.position.offset.distance = this.position.offset.distance + 8 - (this.enable_border ? this.border.width : 0);
                      break;
                    }
                }
                break;
              }
            case "wide":
              {
                switch (this.position.position) {
                  case "top":
                    {
                      this.position.offset.distance = this.position.offset.distance + -4 + (this.enable_padding ? this.padding.top + this.padding.bottom : 0) + (this.enable_border ? this.border.width : 0);
                      break;
                    }
                  case "bottom":
                    {
                      this.position.offset.distance = this.position.offset.distance + 3 - (this.enable_border ? this.border.width : 0);
                      break;
                    }
                  case "left":
                    {
                      this.position.offset.distance = this.position.offset.distance + 16 - (this.enable_border ? this.border.width : 0);
                      break;
                    }
                  case "right":
                    {
                      this.position.offset.distance = this.position.offset.distance - (this.enable_border ? this.border.width : 0);
                      break;
                    }
                }
                break;
              }
            case "large":
              {
                switch (this.position.position) {
                  case "top":
                    {
                      this.position.offset.distance = this.position.offset.distance + (this.enable_padding ? this.padding.top + this.padding.bottom : 0) + (this.enable_border ? this.border.width : 0);
                      break;
                    }
                  case "bottom":
                    {
                      this.position.offset.distance = this.position.offset.distance + 10 - (this.enable_border ? this.border.width : 0);
                      break;
                    }
                  case "left":
                    {
                      this.position.offset.distance = this.position.offset.distance + 24 - (this.enable_border ? this.border.width : 0);
                      break;
                    }
                  case "right":
                    {
                      this.position.offset.distance = this.position.offset.distance + 7 - (this.enable_border ? this.border.width : 0);
                      break;
                    }
                }
                break;
              }
            case "small":
              {
                switch (this.position.position) {
                  case "top":
                    {
                      this.position.offset.distance = this.position.offset.distance + -3 + (this.enable_padding ? this.padding.top + this.padding.bottom : 0) + (this.enable_border ? this.border.width : 0);
                      break;
                    }
                  case "bottom":
                    {
                      this.position.offset.distance = this.position.offset.distance + 7 - (this.enable_border ? this.border.width : 0);
                      break;
                    }
                  case "left":
                    {
                      this.position.offset.distance = this.position.offset.distance + 16 - (this.enable_border ? this.border.width : 0);
                      break;
                    }
                  case "right":
                    {
                      this.position.offset.distance = this.position.offset.distance + 1 - (this.enable_border ? this.border.width : 0);
                      break;
                    }
                }
                break;
              }
            default:
              {
                switch (this.position.position) {
                  case "top":
                    {
                      this.position.offset.distance = this.position.offset.distance + (this.enable_padding ? this.padding.top + this.padding.bottom : 0) + (this.enable_border ? this.border.width : 0);
                      break;
                    }
                  case "bottom":
                    {
                      this.position.offset.distance = this.position.offset.distance + 8 - (this.enable_border ? this.border.width : 0);
                      break;
                    }
                  case "left":
                    {
                      this.position.offset.distance = this.position.offset.distance + 16 - (this.enable_border ? this.border.width : 0);
                      break;
                    }
                  case "right":
                    {
                      this.position.offset.distance = this.position.offset.distance + 7 - (this.enable_border ? this.border.width : 0);
                      break;
                    }
                }
              }
          }
        }
      }

      /**
       * @function _createTippyInstance
       * @private
       * @description Creates a tippy instance.
       */
    }, {
      key: "_createTippyInstance",
      value: function _createTippyInstance() {
        var _this10 = this;
        this.tooltip = tippy(this.targetElement, {
          allowHTML: false,
          aria: {
            content: "describedby"
          },
          arrow: this.enable_arrow,
          appendTo: function appendTo() {
            return document.body;
          },
          content: this.inLineContainer,
          duration: 100,
          followCursor: this.follow_cursor,
          flip: true,
          flipOnUpdate: true,
          inlinePositioning: true,
          hideOnClick: false,
          interactive: true,
          interactiveBorder: this.interactive_border,
          interactiveDebounce: 999999,
          moveTransition: "transform 0s linear",
          maxWidth: "100%",
          maxHeight: "100%",
          offset: [this.position.offset.skid, this.position.offset.distance],
          // onClickOutside: () => {
          //   if (this.enable_dismiss_actions && this.dismiss_actions.outside_touch) {
          //     this._destroyTooltip();
          //   }
          // },
          onShow: function onShow() {
            var _this10$targetDeletio, _this10$viewPortObser;
            // Attach the observer upon show
            (_this10$targetDeletio = _this10.targetDeletionObserver) === null || _this10$targetDeletio === void 0 || _this10$targetDeletio.observe(document.body, {
              childList: true,
              subtree: true
            });
            (_this10$viewPortObser = _this10.viewPortObservor) === null || _this10$viewPortObser === void 0 || _this10$viewPortObser.observe(_this10.targetElement);
            setTimeout(function () {
              //Highlight the target by dimming other elements.
              _this10._highlightInlineTarget();
              //Set the auto termination
              _this10._setAutoTerminate();
              _this10.tooltipShown = true;
            }, 10);
          },
          onMount: function onMount(instance) {
            _this10.recalculateTheTippyHeight();
            instance.popperInstance.update();
          },
          onShown: function onShown() {
            _this10._showTippy();
          },
          placement: this.position.position,
          popperOptions: {
            modifiers: [{
              name: "flip",
              options: {
                fallbackPlacements: ["bottom", "right", "top", "left"],
                allowedAutoPlacements: ["top", "bottom", "right", "left"]
              }
            }]
          },
          role: "tooltip",
          showOnCreate: true,
          sticky: false,
          touch: true,
          zIndex: 99999999
        });
      }

      /**
       * @function _showTippy
       * @private
       * @description Triggers the show function on the tippy instance and calls the showCallback given by RTM
       */
    }, {
      key: "_showTippy",
      value: function _showTippy() {
        var _this11 = this;
        this.inLineContainer.classList.add("open");
        setTimeout(function () {
          var _tippyArrow$classList;
          var tippyArrow = document.querySelector(".tippy-arrow");
          tippyArrow === null || tippyArrow === void 0 || (_tippyArrow$classList = tippyArrow.classList) === null || _tippyArrow$classList === void 0 || _tippyArrow$classList.add("open");
          _this11.showCallback();
        }, 200);
      }

      /**
       * @function _setAutoTerminate
       * @private
       * @description If the auto dismiss is enabled, sets the timeout to call the tooltip destroy.
       */
    }, {
      key: "_setAutoTerminate",
      value: function _setAutoTerminate() {
        var _this12 = this;
        if (this.terminationConfig.auto_dismiss === true) {
          this.terminationTimeoutId = setTimeout(function () {
            _this12._destroyTooltip();
          }, this.terminationConfig.duration);
        }
      }

      /**
       * @function _targetClickCallback
       * @private
       * @description If the dismiss of tooltip on target click is enabled,
       * logs an event and destroys the tooltip.
       */
    }, {
      key: "_targetClickCallback",
      value: function _targetClickCallback() {
        if (this.enable_dismiss_actions && this.dismiss_actions.target_touch) {
          this.rtmInstance.logActionEvent("InlineTargetViewClicked", this.configId, this.name);
          this._destroyTooltip();
        }
      }

      /**
       * @function _destroyTooltip
       * @private
       * @description Destroys the tooltip and notifies the close callback.
       * @param {boolean} isCancelled - true if the cancel action is called else false
       */
    }, {
      key: "_destroyTooltip",
      value: function _destroyTooltip() {
        var isCancelled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
        try {
          var _this$targetDeletionO, _this$viewPortObservo, _this$tooltip, _this$maskingElement, _this$dimBackgroundEl, _this$targetOverlayEl;
          document.body.removeEventListener("click", this.flutterClickCallbackWrapper);
          if (Apxor.isFlutter()) {
            var _this$targetElement;
            (_this$targetElement = this.targetElement) === null || _this$targetElement === void 0 || _this$targetElement.remove();
          }
          //Disconnect both the observors
          (_this$targetDeletionO = this.targetDeletionObserver) === null || _this$targetDeletionO === void 0 || _this$targetDeletionO.disconnect();
          this.targetDeletionObserver = null;
          (_this$viewPortObservo = this.viewPortObservor) === null || _this$viewPortObservo === void 0 || _this$viewPortObservo.disconnect();
          this.viewPortObservor = null;
          //Destroy the tooltip
          (_this$tooltip = this.tooltip) === null || _this$tooltip === void 0 || _this$tooltip.destroy();
          if (Apxor.isFlutter()) (_this$maskingElement = this.maskingElement) === null || _this$maskingElement === void 0 || _this$maskingElement.remove();
          //If the dim background is set, remove that as well.
          (_this$dimBackgroundEl = this.dimBackgroundElement) === null || _this$dimBackgroundEl === void 0 || _this$dimBackgroundEl.remove();
          //If the overlay element is set on target, remove that as well.
          (_this$targetOverlayEl = this.targetOverlayElement) === null || _this$targetOverlayEl === void 0 || _this$targetOverlayEl.remove();
          //Delete all the styles created for tooltips
          this._removeStyles();
          //Remove the highlight styles on the target
          this.targetElement.removeAttribute("apx-inline-dimbackground");
          //this.targetElement.classList.remove("apx-dimbackground");
          clearTimeout(this.terminationTimeoutId);
          this.targetElement.removeEventListener("click", this._targetClickCallback);
        } catch (e) {
          Logger$2.info("Destroying the tooltip:" + e);
        }
        this.closeCallback(isCancelled);
      }

      /**
       * @function _isWalkthroughCampaign
       * @private
       * @description Finds if the campaign is a walkthrough campaign or a normal campaign
       * @returns {boolean} true  - If it is a walkthrough campaign
       *                    false - If it is a walkthrough campaign
       */
    }, {
      key: "_isWalkthroughCampaign",
      value: function _isWalkthroughCampaign() {
        var isAWalkthrough = Array.isArray(this.walkthroughConfigs) && this.walkthroughConfigs.length > 0;
        return isAWalkthrough;
      }
    }, {
      key: "getPixelsFromPercentage",
      value: function getPixelsFromPercentage(percentage) {
        var isHeight = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        var w = window.innerWidth;
        var h = window.innerHeight;
        if (isHeight) {
          return h * percentage / 100;
        }
        return w * percentage / 100;
      }
    }, {
      key: "recalculateTheTippyHeight",
      value: function recalculateTheTippyHeight() {
        try {
          var tippyHeight = 0;
          //let tippyWidth = 0;
          this.inLineContainer.childNodes.forEach(function (n) {
            tippyHeight = tippyHeight + ((n === null || n === void 0 ? void 0 : n.offsetHeight) || 0);
            // if (n?.offsetWidth > tippyWidth) {
            //   tippyWidth = n.offsetWidth;
            // }
          });

          var tippyWidth = this.inLineContainer.offsetWidth;
          var tippyRoot = document.querySelector("[data-tippy-root]");
          tippyRoot.style.height = "".concat(tippyHeight, "px");
          tippyRoot.style.width = "".concat(tippyWidth, "px");
          var tippyBox = document.querySelector(".tippy-box");
          tippyBox.style.height = "".concat(tippyHeight, "px");
          tippyBox.style.width = "".concat(tippyWidth, "px");
          var tippyContent = document.querySelector(".tippy-content");
          tippyContent.style.height = "".concat(tippyHeight, "px");
          tippyContent.style.width = "".concat(tippyWidth, "px");
        } catch (e) {
          this._destroyTooltip();
          Logger$2.error("Can't update the tippy dimensions");
        }
      }
    }]);
    return InLineTooltip;
  }();

  /*
    "border": {
      "color": "#FF0000",
      "corners": {
        "top_left": 5,
        "top_right": 5,
        "bottom_right": 5,
        "bottom_left": 5
      },
      "width": {
        "top": 4,
        "left": 2,
        "right": 3,
        "bottom": 0
      }
    }
  */
  var Badgeborder = /*#__PURE__*/_createClass$1(function Badgeborder() {
    var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    _classCallCheck$1(this, Badgeborder);
    this.color = data.color;
    this.corners = data.corners;
    this.width = data.width;
  });

  /*
  "shape": {
    "height": 10,
    "width": 10,
    "type": "circle/rectangle",
    "enable_border": true,
    "border": {
      "color": "#FF0000",
      "corners": {
        "top_left": 5,
        "top_right": 5,
        "bottom_right": 5,
        "bottom_left": 5
      },
      "width": {
        "top": 4,
        "left": 2,
        "right": 3,
        "bottom": 0
      }
    }
  }
  */
  var Shape = /*#__PURE__*/_createClass$1(function Shape() {
    var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    _classCallCheck$1(this, Shape);
    this.type = data.type;
    this.color = getColorOrDefault(data.color, "transparent");
    this.enable_gradient = data.enable_gradient;
    if (this.enable_gradient) this.gradient = new Gradient(data.gradient);
    this.enable_border = data.enable_border;
    if (this.enable_border) this.border = new Badgeborder(data.border);
  });

  /*
  "background": {
        "enable_image": true,
        "image": {
          "type": "assets/url",
          "path": "",
          "width": 50,
          "height": 50
        },
        "color": "#00FF0000",
        "enable_gradient": "false",
        "gradient": {
          "colors": ["FF0000", "FF0000"],
          "direction": "to_right/to_left/to_top/to_bottom"
        },
        "shape": {
          "height": 10,
          "width": 10,
          "type": "circle/rectangle",
          "enable_border": true,
          "border": {
            "color": "#FF0000",
            "corners": {
              "top_left": 5,
              "top_right": 5,
              "bottom_right": 5,
              "bottom_left": 5
            },
            "width": {
              "top": 4,
              "left": 2,
              "right": 3,
              "bottom": 0
            }
          }
        }
      },
  */
  var Badgebackground = /*#__PURE__*/_createClass$1(function Badgebackground() {
    var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    _classCallCheck$1(this, Badgebackground);
    this.width = data.width;
    this.height = data.height;
    this.enable_image = data.enable_image;
    if (this.enable_image) this.image = new Image(data.image);
    this.shape = new Shape(data.shape);
  });

  /*
  "content": [
        {
          "enable_label": true,
          "label": {
            "enable_margin": true,
            "margin": {
              "top": 5,
              "left": 5,
              "bottom": 5,
              "right": 5
            },
            "color": "#FF0000",
            "text": "123",
            "font": {
              "size": 20,
              "weight": "bold/normal",
              "style": "italic/normal",
              "family": "sans-serif"
            },
            "alignment": "left",
            "script": {
              "cmds": "e A;jz 1;e A;r \"Winner is: {}\",1;jmp L1;1:e A;r \"{} is not winner\",1;jmp L1;L1:",
              "vmap": {
                "A": {
                  "t": "u",
                  "n": "name",
                  "def": "Tesla"
                }
              }
            },
            "is_dyn": true
          },
          "enable_icon": true,
          "icon": {
            "type": "Assets/URl",
            "path": "",
            "position": "left/right",
            "width": 50,
            "height": 50,
            "enable_margin": true,
            "margin": {
              "top": 5,
              "left": 5,
              "bottom": 5,
              "right": 5
            }
          }
        }
      ],
  */
  var Badgecontent = /*#__PURE__*/_createClass$1(function Badgecontent() {
    var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    _classCallCheck$1(this, Badgecontent);
    this.enable_label = data.enable_label;
    if (this.enable_label) this.label = new Text(data.label);
    this.enable_icon = data.enable_icon;
    if (this.enable_icon) this.icon = new Icon(data.icon);
  });

  var Autoscroll = /*#__PURE__*/_createClass$1(function Autoscroll() {
    var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    _classCallCheck$1(this, Autoscroll);
    this.duration_millis = getNumberOrDefault(data.duration_millis, 2);
    this.direction = getStringOrDefault(data.direction, "to_top");
  });

  /*
  "badge": {
      "position": {
        "position": "TL/T/TR/L/C/R/BL/B/BR",
        "offset": {
          "x": 5,
          "y": 5
        }
      },
      "enable_background": true,
      "background": {
        "enable_image": true,
        "image": {
          "type": "assets/url",
          "path": "",
          "width": 50,
          "height": 50
        },
        "color": "#00FF0000",
        "enable_gradient": "false",
        "gradient": {
          "colors": ["FF0000", "FF0000"],
          "direction": "to_right/to_left/to_top/to_bottom"
        },
        "shape": {
          "height": 10,
          "width": 10,
          "type": "circle/rectangle",
          "enable_border": true,
          "border": {
            "color": "#FF0000",
            "corners": {
              "top_left": 5,
              "top_right": 5,
              "bottom_right": 5,
              "bottom_left": 5
            },
            "width": {
              "top": 4,
              "left": 2,
              "right": 3,
              "bottom": 0
            }
          }
        }
      },
      "content": [
        {
          "enable_label": true,
          "label": {
            "enable_margin": true,
            "margin": {
              "top": 5,
              "left": 5,
              "bottom": 5,
              "right": 5
            },
            "color": "#FF0000",
            "text": "123",
            "font": {
              "size": 20,
              "weight": "bold/normal",
              "style": "italic/normal",
              "family": "sans-serif"
            },
            "alignment": "left",
            "script": {
              "cmds": "e A;jz 1;e A;r \"Winner is: {}\",1;jmp L1;1:e A;r \"{} is not winner\",1;jmp L1;L1:",
              "vmap": {
                "A": {
                  "t": "u",
                  "n": "name",
                  "def": "Tesla"
                }
              }
            },
            "is_dyn": true
          },
          "enable_icon": true,
          "icon": {
            "type": "Assets/URl",
            "path": "",
            "position": "left/right",
            "width": 50,
            "height": 50,
            "enable_margin": true,
            "margin": {
              "top": 5,
              "left": 5,
              "bottom": 5,
              "right": 5
            }
          }
        }
      ],
      "enable_shadow": true,
      "shadow": {
        "color": "#FFFFFF",
        "offset_x": 2,
        "offset_y": 2,
        "spread_radius": 2
      },
      "enable_animation": true,
      "animation": {
        "type": "shine/ripple/fading/shake",
        "time": 5,
        "ripple_area": 8,
        "ripple_color": "#FFFFFF",
        "direction": "top_to_bottom/bottom_to_top",
        "fade_opacity": 50
      },
      "enable_textscroll": true,
      "textscroll": {
        "speed": 10,
        "direction": "left_to_right/right_to_left/bottom_to_top"
      }
    }
  */
  var Badge = /*#__PURE__*/_createClass$1(function Badge(data) {
    var _this = this;
    _classCallCheck$1(this, Badge);
    this.position = new Position(data.position);
    this.enable_background = data.enable_background;
    if (this.enable_background) this.background = new Badgebackground(data.background);
    this.content = [];
    if (data !== null && data !== void 0 && data.content && data.content.length !== 0) data.content.forEach(function (contentelement) {
      _this.content.push(new Badgecontent(contentelement));
    });
    this.enable_shadow = data.enable_shadow;
    if (this.enable_shadow) this.shadow = new Shadow(data.shadow);
    this.enable_animation = data.enable_animation;
    if (this.enable_animation) this.animation = new Animation(data.animation);
    this.enable_auto_scroll = data.enable_auto_scroll;
    if (this.enable_auto_scroll) this.auto_scroll = new Autoscroll(data.auto_scroll);
    this.tooltipShown = data.tooltipShown;
  });

  var ApxorBadge = /*#__PURE__*/function () {
    /**
     * @class ApxorBadge
     * @param {JSON} config
     */
    function ApxorBadge(config, terminationConfig, messageConfig, rtmInstance) {
      var _this = this;
      _classCallCheck$1(this, ApxorBadge);
      _defineProperty$1(this, "_controller", Apxor.getController());
      _defineProperty$1(this, "_setIntervalForTerminatingBadge", function () {
        var _this$terminationConf2, _this$terminationConf3;
        var checkToTerminateBadge = setInterval(function () {
          var _this$terminationConf;
          //for checking termination attributes are satisfied or not
          if ((_this$terminationConf = _this.terminationConfig) !== null && _this$terminationConf !== void 0 && _this$terminationConf.enable_attributes && _this.rtmInstance.validateForTerminationAttributes(_this.configId)) {
            _this._controller.persistTerminationInfoLocally(_this.configId);
          }
          //getting the stored data.
          var terminationCheck = JSON.parse(_this._controller.getFromStorage(APX_TERMINATION_ID));
          if (terminationCheck !== null && terminationCheck[_this.configId] !== undefined && terminationCheck[_this.configId].goalAcheived) {
            var badge = document.getElementsByClassName("apxor-badge-container-styles-".concat(_this.cssPostFix));
            while (badge.length > 0) badge[0].remove();
            clearTimeout(checkToTerminateBadge);
          }
        }, 1000);
        if ((_this$terminationConf2 = _this.terminationConfig) !== null && _this$terminationConf2 !== void 0 && _this$terminationConf2.enable_goal_events || (_this$terminationConf3 = _this.terminationConfig) !== null && _this$terminationConf3 !== void 0 && _this$terminationConf3.enable_attributes) ;
      });
      /**
       * @function cssPath
       * @param {object} node
       * @param {boolean} optimized
       * @returns viewId
       */
      _defineProperty$1(this, "cssPath", function (node, optimized) {
        if (node.nodeType !== Node.ELEMENT_NODE) return "";
        var steps = [];
        var contextNode = node;
        while (contextNode) {
          var step = _this._cssPathStep(contextNode, !!optimized, contextNode === node);
          if (!step) break; // Error - bail out early.
          steps.push(step);
          if (step.optimized) break;
          contextNode = contextNode.parentNode;
        }
        steps.reverse();
        return steps.join(" > ");
      });
      /**
       * @function _cssPathStep
       * @param {object} node
       * @param {boolean} optimized
       * @param {object} isTargetNode
       */
      _defineProperty$1(this, "_cssPathStep", function (node, optimized, isTargetNode) {
        if (node.nodeType !== Node.ELEMENT_NODE) return null;
        var id = node.getAttribute("id");
        if (optimized) {
          if (id) return new DOMNodePathStep(idSelector(id), true);
          var nodeNameLower = node.nodeName.toLowerCase();
          if (nodeNameLower === "body" || nodeNameLower === "head" || nodeNameLower === "html") return new DOMNodePathStep(node.nodeName.toLowerCase(), true);
        }
        var nodeName = node.nodeName.toLowerCase();
        if (id) return new DOMNodePathStep(nodeName.toLowerCase() + idSelector(id), true);
        var parent = node.parentNode;
        if (!parent || parent.nodeType === Node.DOCUMENT_NODE) return new DOMNodePathStep(nodeName.toLowerCase(), true);
        function prefixedElementClassNames(node) {
          var classAttribute = node.getAttribute("class");
          if (!classAttribute) return [];
          return classAttribute.split(/\s+/g).filter(Boolean).map(function (name) {
            // The prefix is required to store "__proto__" in a object-based map.
            return "$" + name;
          });
        }
        function idSelector(id) {
          return "#" + escapeIdentifierIfNeeded(id);
        }
        function escapeIdentifierIfNeeded(ident) {
          if (isCSSIdentifier(ident)) return ident;
          var shouldEscapeFirst = /^(?:[0-9]|-[0-9-]?)/.test(ident);
          var lastIndex = ident.length - 1;
          return ident.replace(/./g, function (c, i) {
            return shouldEscapeFirst && i === 0 || !isCSSIdentChar(c) ? escapeAsciiChar(c, i === lastIndex) : c;
          });
        }
        function escapeAsciiChar(c, isLast) {
          return "\\" + toHexByte(c) + (isLast ? "" : " ");
        }
        function toHexByte(c) {
          var hexByte = c.charCodeAt(0).toString(16);
          if (hexByte.length === 1) hexByte = "0" + hexByte;
          return hexByte;
        }
        function isCSSIdentChar(c) {
          if (/[a-zA-Z0-9_-]/.test(c)) return true;
          return c.charCodeAt(0) >= 0xa0;
        }
        function isCSSIdentifier(value) {
          return /^-?[a-zA-Z_][a-zA-Z0-9_-]*$/.test(value);
        }
        var prefixedOwnClassNamesArray = prefixedElementClassNames(node);
        var needsClassNames = false;
        var needsNthChild = false;
        var ownIndex = -1;
        var elementIndex = -1;
        var siblings = parent.children;
        for (var i = 0; (ownIndex === -1 || !needsNthChild) && i < siblings.length; ++i) {
          var sibling = siblings[i];
          if (sibling.nodeType !== Node.ELEMENT_NODE) continue;
          elementIndex += 1;
          if (sibling === node) {
            ownIndex = elementIndex;
            continue;
          }
          if (needsNthChild) continue;
          if (sibling.nodeName.toLowerCase() !== nodeName.toLowerCase()) continue;
          needsClassNames = true;
          var ownClassNames = new Set(prefixedOwnClassNamesArray);
          if (!ownClassNames.size) {
            needsNthChild = true;
            continue;
          }
          var siblingClassNamesArray = prefixedElementClassNames(sibling);
          for (var j = 0; j < siblingClassNamesArray.length; ++j) {
            var siblingClass = siblingClassNamesArray[j];
            if (!ownClassNames.has(siblingClass)) continue;
            ownClassNames["delete"](siblingClass);
            if (!ownClassNames.size) {
              needsNthChild = true;
              break;
            }
          }
        }
        var result = nodeName.toLowerCase();
        if (isTargetNode && nodeName.toLowerCase() === "input" && node.getAttribute("type") && !node.getAttribute("id") && !node.getAttribute("class")) result += '[type="' + node.getAttribute("type") + '"]';
        if (needsNthChild) {
          result += ":nth-child(" + (ownIndex + 1) + ")";
        } else if (needsClassNames) {
          for (var prefixedName in prefixedOwnClassNamesArray) result += "." + escapeIdentifierIfNeeded(prefixedOwnClassNamesArray[prefixedName].substr(1));
        }
        return new DOMNodePathStep(result, false);
      });
      this.uiConfig = config;
      this.rtmInstance = rtmInstance;
      this.configId = messageConfig.configId;
      this.name = messageConfig.configName;
      this.terminationConfig = terminationConfig;
      this.cssPostFix = "-".concat(this.configId, "-").concat(this.name).replaceAll(" ", "").replace(/[^\w\s]/gi, "");
      this.target = new Target(config.target);
      this.badge = new Badge(config.badge);
      this.enable_marketing = config.enable_marketing;
      if (this.enable_marketing) this.marketing = new Marketing(config.marketing);
      this.delay = config.delay || 0;
    }
    _createClass$1(ApxorBadge, [{
      key: "createBadge",
      value: function createBadge() {
        var _this2 = this;
        setTimeout(function () {
          _this2._setTargetElement();
          _this2._setBadgeStyles();
          _this2._setBadgeContent();
          _this2._setIntervalForTerminatingBadge();
          _this2._setAutoTerminateForBadges();
          _this2._setOnClickTerminationForBadges();
        }, this.delay);
      }
    }, {
      key: "_setTargetElement",
      value: function _setTargetElement() {
        var _this$targetElement;
        this.targetElement = getElementFromSelector(this.target.id, this.target.iframe_id);
        (_this$targetElement = this.targetElement) === null || _this$targetElement === void 0 || _this$targetElement.classList.add("apx-badge-target-style".concat(this.cssPostFix));
      }
    }, {
      key: "_setBadgeStyles",
      value: function _setBadgeStyles() {
        var _this$targetElement2;
        var styles = "\n      ".concat(this._gettargetStyles(), "\n      ").concat(this._getBadgeContainerStyles(), "\n      ").concat(this._getBadgeContentStyles(), "\n      ").concat(this._getBadgeContentElementStyles(), "\n      ").concat(this._getBadgeAnimationStyles(), "\n      ").concat(this._getBadgeScrollStyles(), "\n      ").replaceAll("\n", "").replace(/[\s]{2,999}/g, "");
        var styleNode = document.createElement("style");
        styleNode.innerHTML = styles;
        (_this$targetElement2 = this.targetElement) === null || _this$targetElement2 === void 0 || _this$targetElement2.appendChild(styleNode);
      }
    }, {
      key: "_gettargetStyles",
      value: function _gettargetStyles() {
        var targetcontainerstyles = "\n    .apx-badge-target-style".concat(this.cssPostFix, "{\n      position:relative;\n      overflow:initial;\n    }");
        return targetcontainerstyles;
      }
    }, {
      key: "_getBadgeContainerStyles",
      value: function _getBadgeContainerStyles() {
        var _this$badge$backgroun;
        var dimensionsForBadgeContainer = "";
        var strokeXlength = this.badge.enable_background && this.badge.background.shape.enable_border ? this.badge.background.shape.border.width.left + this.badge.background.shape.border.width.right : 0;
        var strokeYlength = this.badge.enable_background && this.badge.background.shape.enable_border ? this.badge.background.shape.border.width.top + this.badge.background.shape.border.width.bottom : 0;
        dimensionsForBadgeContainer = this.badge.enable_background ? "\n      width:".concat(this.badge.background.width + strokeXlength, "px;\n      height:").concat(this.badge.background.height + strokeYlength, "px;") : "\n      width:auto;\n      height:auto;";
        var positionForBadgeContainer = "";
        switch (this.badge.position.position) {
          case "top-left":
            positionForBadgeContainer = "\n           top:0px;\n           left:0px;\n           -webkit-transform:translate(".concat(this.badge.position.offset.x, "px,").concat(this.badge.position.offset.y, "px);\n         ");
            break;
          case "top-center":
          case "top":
            positionForBadgeContainer = "\n           top:0px;\n           left:50%;\n           -webkit-transform:translate(".concat(this.badge.position.offset.x, "px,").concat(this.badge.position.offset.y, "px);\n         ");
            break;
          case "top-right":
            positionForBadgeContainer = "\n             top:0px;\n             right:0px;\n             -webkit-transform:translate(".concat(this.badge.position.offset.x, "px,").concat(this.badge.position.offset.y, "px);\n           ");
            break;
          case "bottom-left":
            positionForBadgeContainer = "\n        bottom:0px;\n        left:0px;\n        -webkit-transform:translate(".concat(this.badge.position.offset.x, "px,").concat(this.badge.position.offset.y, "px);\n         ");
            break;
          case "bottom-center":
          case "bottom":
            positionForBadgeContainer = "\n           left:50%;\n           bottom:0px;\n           -webkit-transform:translate(".concat(this.badge.position.offset.x, "px,").concat(this.badge.position.offset.y, "px);\n         ");
            break;
          case "bottom-right":
            positionForBadgeContainer = "\n           bottom:0px;\n           right:0px;\n           -webkit-transform:translate(".concat(this.badge.position.offset.x, "px,").concat(this.badge.position.offset.y, "px);\n         ");
            break;
          case "center-left":
          case "left":
            positionForBadgeContainer = "\n           top:50%;\n           left:0px;\n           -webkit-transform:translate(".concat(this.badge.position.offset.x, "px,").concat(this.badge.position.offset.y, "px);\n         ");
            break;
          case "center-right":
          case "right":
            positionForBadgeContainer = "\n        top:50%;\n        right:0px;\n        -webkit-transform:translate(".concat(this.badge.position.offset.x, "px,").concat(this.badge.position.offset.y, "px);\n      ");
            break;
          default:
            positionForBadgeContainer = "\n        top:50%;\n        left:50%;\n        -webkit-transform:translate(".concat(this.badge.position.offset.x, "px,").concat(this.badge.position.offset.y, "px);\n         ");
            break;
        }
        var backgroundImageForBadgeContainer = "";
        if (this.badge.enable_background && this.badge.background.enable_image) {
          backgroundImageForBadgeContainer = "\n        .apxor-badge-container-background-image".concat(this.cssPostFix, "{\n          background-image: url('").concat(this.badge.background.image.path, "');\n          background-repeat: no-repeat;\n          background-attachment: fixed; \n          background-size: 100% 100%;\n          height: ").concat(this.badge.background.height, "px;\n          width: ").concat(this.badge.background.width, "px;\n        }");
        }
        var gradientForBadgeContainer = "";
        if (this.badge.enable_background && Object.keys(this.badge.background.shape).length !== 0 && this.badge.background.shape.enable_gradient) {
          gradientForBadgeContainer = "\n        background-image:linear-gradient(".concat(this.badge.background.shape.gradient.direction, ", ").concat(this.badge.background.shape.gradient.colors[0], ", ").concat(this.badge.background.shape.gradient.colors[1], ");\n      ");
        }
        var shapeOfBadgeContainer = "";
        if (this.badge.enable_background && (_this$badge$backgroun = this.badge.background) !== null && _this$badge$backgroun !== void 0 && _this$badge$backgroun.shape) {
          var badgeTypeStyles = "";
          if (!this.badge.background.enable_image) {
            if (this.badge.background.shape.type === "circle") {
              badgeTypeStyles = "\n        border:".concat(this.badge.background.shape.border.width.top, "px solid ").concat(this.badge.background.shape.border.color, ";\n        border-radius:50%;\n        background:").concat(this.badge.background.shape.color, ";");
            } else if (this.badge.background.shape.type === "rectangle") {
              badgeTypeStyles = "\n        background:".concat(this.badge.background.shape.color, ";\n        border-top:").concat(this.badge.background.shape.border.width.top, "px solid ").concat(this.badge.background.shape.border.color, ";\n        border-right:").concat(this.badge.background.shape.border.width.right, "px solid ").concat(this.badge.background.shape.border.color, ";\n        border-bottom:").concat(this.badge.background.shape.border.width.bottom, "px solid ").concat(this.badge.background.shape.border.color, ";\n        border-left:").concat(this.badge.background.shape.border.width.left, "px solid ").concat(this.badge.background.shape.border.color, ";\n        border-top-left-radius:").concat(this.badge.background.shape.border.corners.top_left, "px;\n        border-top-right-radius:").concat(this.badge.background.shape.border.corners.top_right, "px;\n        border-bottom-left-radius:").concat(this.badge.background.shape.border.corners.bottom_left, "px;\n        border-bottom-right-radius:").concat(this.badge.background.shape.border.corners.bottom_right, "px;\n        ");
            }
          }
          shapeOfBadgeContainer = "\n      ".concat(badgeTypeStyles, "\n      ");
        }
        var shadowForBadgeContainer = "";
        if (this.badge.enable_shadow) {
          shadowForBadgeContainer = "\n        box-shadow: ".concat(this.badge.shadow.offset_x, "px ").concat(this.badge.shadow.offset_y, "px ").concat(this.badge.shadow.blur_radius, "px ").concat(this.badge.shadow.spread_radius, "px ").concat(this.badge.shadow.color, ";\n      ");
        }
        var badgeStyles = "\n    .apxor-badge-container-styles-".concat(this.cssPostFix, "{\n      position:absolute;\n      display:flex;\n      align-items:center;\n      overflow:hidden;\n      ").concat(gradientForBadgeContainer, "\n      ").concat(dimensionsForBadgeContainer, "\n      ").concat(positionForBadgeContainer, "\n      ").concat(shapeOfBadgeContainer, "\n      ").concat(shadowForBadgeContainer, "\n      z-index:999999;\n      text-transform:none;\n    }\n    ").concat(backgroundImageForBadgeContainer);
        return badgeStyles;
      }
    }, {
      key: "_getBadgeContentStyles",
      value: function _getBadgeContentStyles() {
        var contentScrollStyles = "";
        if (this.badge.enable_auto_scroll) {
          contentScrollStyles = this.badge.auto_scroll.direction === "to_right" || this.badge.auto_scroll.direction === "to_left" ? "display:flex;\n        flex-direction:row;\n        " : "";
        }
        var badgeContentStyles = "\n    .apxor-badge-content-container-".concat(this.cssPostFix, "{\n      position:relative;\n      width:100%;\n      height:100%;\n      overflow:hidden;\n      ").concat(contentScrollStyles, "\n    }");
        return badgeContentStyles;
      }
    }, {
      key: "_getBadgeContentElementStyles",
      value: function _getBadgeContentElementStyles() {
        var _this3 = this;
        var badgeContentElementsstyles = "";
        if (this.badge.content.length !== 0) {
          this.badge.content.forEach(function (content, ind) {
            badgeContentElementsstyles += "\n        .apxor-badge-contentelement-".concat(ind, "-").concat(_this3.cssPostFix, "{\n          width:100%;\n          height:100%;\n          display:flex;\n          justify-content:center;\n          align-items:center;\n        }");
            if (content.enable_icon) {
              var marginForIcon = "";
              if (content.icon.enable_margin) {
                marginForIcon = "margin:".concat(content.icon.margin.top, "px ").concat(content.icon.margin.right, "px ").concat(content.icon.margin.bottom, "px ").concat(content.icon.margin.left, "px;");
              }
              var borderStylesForIcon = "";
              if (content.icon.enable_border) {
                borderStylesForIcon = "\n            border-radius:".concat(content.icon.border.radius, "%;\n            border:").concat(content.icon.border.width, "px ").concat(content.icon.border.style, " ").concat(content.icon.border.color, ";\n          ");
              }
              badgeContentElementsstyles += "\n          .apxor-badge-".concat(ind, "-icon-container").concat(_this3.cssPostFix, "{\n            width:auto;\n            height:auto;\n            display:flex;\n            justify-content:center;\n            align-items:center;\n          }\n          .apxor-badge-").concat(ind, "-icon-content").concat(_this3.cssPostFix, " {\n            position:relative;\n            background:url('").concat(content.icon.path, "') no-repeat center;\n            background-size:cover;\n            display:inline-block;\n            height: ").concat(content.icon.height, "px;\n            width: ").concat(content.icon.width, "px;\n            ").concat(marginForIcon, "\n            ").concat(borderStylesForIcon, "\n          }");
            }
            if (content.enable_label) {
              var marginForLabel = "";
              if (content.label.enable_margin) {
                marginForLabel = "margin:".concat(content.label.margin.top, "px ").concat(content.label.margin.right, "px ").concat(content.label.margin.bottom, "px ").concat(content.label.margin.left, "px;");
              }
              badgeContentElementsstyles += "\n          .apxor-badge-".concat(ind, "-label-content-").concat(_this3.cssPostFix, "{\n            text-align:").concat(content.label.alignment, ";\n            display:flex;\n            align-items:center;\n            ").concat(marginForLabel, "\n          }\n          ");
            }
          });
        }
        return badgeContentElementsstyles;
      }
    }, {
      key: "_getBadgeAnimationStyles",
      value: function _getBadgeAnimationStyles() {
        var animationForBadgeContainer = "";
        var keyframeForAnimation = "";
        if (this.badge.enable_animation) {
          if (this.badge.animation.type === "shake") {
            animationForBadgeContainer = "\n        .apxor-badge-container-styles-".concat(this.cssPostFix, "{\n          animation: badgeAnimation ").concat(this.badge.animation.duration_millis, "s ").concat(this.badge.animation.iteration_count, ";\n        }");
            keyframeForAnimation = this.badge.animation.direction === "horizontal" ? "@keyframes badgeAnimation {\n              0% { transform: translateX(0) }\n              25% { transform: translateX(5px) }\n              50% { transform: translateX(-5px) }\n              75% { transform: translateX(5px) }\n              100% { transform: translateX(0) }\n            }" : "@keyframes badgeAnimation {\n              0% { transform: translateY(0) }\n              25% { transform: translateY(5px) }\n              50% { transform: translateY(-5px) }\n              75% { transform: translateY(5px) }\n              100% { transform: translateY(0) }\n            }";
          }
          if (this.badge.animation.type === "fade") {
            animationForBadgeContainer = "\n        .apxor-badge-container-styles-".concat(this.cssPostFix, "{\n          animation: badgeAnimation ").concat(this.badge.animation.duration_millis, "s ").concat(this.badge.animation.iteration_count, ";\n        }");
            keyframeForAnimation = "\n        @keyframes badgeAnimation {\n          0% { opacity:1;}\n          50% { opacity:".concat(this.badge.animation.fade_opacity / 100, ";}\n          100% { opacity:1}\n        }");
          }
          if (this.badge.animation.type === "ripple") {
            animationForBadgeContainer = "\n        .apxor-badge-container-styles-".concat(this.cssPostFix, "{\n          animation: badgeAnimation ").concat(this.badge.animation.duration_millis, "s ease-in-out;\n          animation-iteration-count: infinite;\n        }");
            keyframeForAnimation = "\n        @keyframes badgeAnimation {\n        0% {\n          box-shadow: 0 0 0 0 ".concat(this.badge.animation.ripplecolor, ", 0 0 0 0 ").concat(this.badge.animation.ripplecolor, ";\n          }\n    \n          80% {\n              box-shadow: 0 0 0 ").concat(this.badge.animation.ripplearea, "px ").concat(this.badge.animation.ripplecolor, ", 0 0 0 ").concat(2 * this.badge.animation.ripplearea, "px ").concat(this.badge.animation.ripplecolor, ";\n        }\n\n        100% {\n          box-shadow: 0 0 0 0 ").concat(this.badge.animation.ripplecolor, ", 0 0 0 0 ").concat(this.badge.animation.ripplecolor, ";\n        } \n      }");
          }
          if (this.badge.animation.type === "shine") {
            var transformForMultipleDirection = "";
            switch (this.badge.animation.direction) {
              case "to_bottom_right":
                transformForMultipleDirection = "\n            left:-8px;\n            transform: skewx(-30deg)\n            ";
                break;
              case "to_top_right":
                transformForMultipleDirection = "\n            left:-8px;\n            transform: skewx(30deg)\n            ";
                break;
              case "to_top_left":
                transformForMultipleDirection = "\n            right:-8px;\n            transform: skewx(-30deg)\n            ";
                break;
              case "to_bottom_left":
                transformForMultipleDirection = "\n            right:-8px;\n            transform: skewx(30deg)\n            ";
                break;
            }
            animationForBadgeContainer = "\n        .apxor-badge-content-container-".concat(this.cssPostFix, "::before{\n          content:'';\n          position:absolute;\n          background:").concat(this.badge.animation.shinecolor, ";\n          width:8px;\n          height:100%;\n          animation: badgeAnimation ").concat(this.badge.animation.duration_millis, "s infinite;\n          ").concat(transformForMultipleDirection, ";\n        }");
            keyframeForAnimation = this.badge.animation.direction === "to_bottom_right" || this.badge.animation.direction === "to_top_right" ? "@keyframes badgeAnimation {\n                0% {\n                  left:-30%;\n                }\n                100% {\n                  left:130%;\n                }\n            }" : "@keyframes badgeAnimation {\n              0% {\n                right:-30%;\n              }\n              100% {\n                right:130%;\n              }\n            }";
          }
        }
        var animationStyles = "\n      ".concat(animationForBadgeContainer, "\n      ").concat(keyframeForAnimation, "\n    ");
        return animationStyles;
      }
    }, {
      key: "_getBadgeScrollStyles",
      value: function _getBadgeScrollStyles() {
        var badgeScrollstyles = "";
        if (this.badge.enable_auto_scroll) {
          badgeScrollstyles = "\n      #apxor-scroll-option{\n        width: inherit;\n        height: inherit;\n        animation: scrollAnimation ".concat(this.badge.auto_scroll.duration_millis, "s linear infinite;\n      }");
        }
        return badgeScrollstyles;
      }
    }, {
      key: "_getBadgeScrollKeyFrameStyles",
      value: function _getBadgeScrollKeyFrameStyles(numberOfElement) {
        var _this$badge$enable_au, _this$badge, _this$targetElement3;
        var keyFrameStyles = "";
        if ((_this$badge$enable_au = !this.badge.enable_auto_scroll) !== null && _this$badge$enable_au !== void 0 ? _this$badge$enable_au : !((_this$badge = this.badge) !== null && _this$badge !== void 0 && _this$badge.enable_animation)) {
          return;
        }
        switch (this.badge.auto_scroll.direction) {
          case "to_right":
            keyFrameStyles = "\n        @keyframes scrollAnimation {\n          0% {\n            transform: translateX(0);\n          }\n          100% {\n            transform: translateX(-".concat((numberOfElement - 1) * 100, "%);\n          }\n        }\n        ");
            break;
          case "to_left":
            keyFrameStyles = "\n          @keyframes scrollAnimation {\n            0% {\n              transform: translateX(-".concat((numberOfElement - 1) * 100, "%);\n            }\n            100% {\n              transform: translateX(0);\n            }\n          }\n          ");
            break;
          case "to_bottom":
            keyFrameStyles = "\n          @keyframes scrollAnimation {\n            0% {\n              transform: translateY(-".concat((numberOfElement - 1) * 100, "%);\n            }\n            100% {\n              transform: translateY(0);\n            }\n          }\n          ");
            break;
          default:
            keyFrameStyles = "\n        @keyframes scrollAnimation {\n          0% {\n            transform: translateY(0);\n          }\n          100% {\n            transform: translateY(-".concat((numberOfElement - 1) * 100, "%);\n          }\n        }\n        ");
            break;
        }
        var keyFrameForScrollAnimation = "\n      ".concat(keyFrameStyles, "\n      ").replaceAll("\n", "").replace(/[\s]{2,999}/g, "");
        var styleNode = document.createElement("style");
        styleNode.innerHTML = keyFrameForScrollAnimation;
        (_this$targetElement3 = this.targetElement) === null || _this$targetElement3 === void 0 || _this$targetElement3.appendChild(styleNode);
      }
    }, {
      key: "_setBadgeContent",
      value: function _setBadgeContent() {
        this.createBadgeContainer();
        this.createBadgeContent();
      }
    }, {
      key: "createBadgeContainer",
      value: function createBadgeContainer() {
        this.badgeContainer = document.createElement("div");
        this.badgeContainer.classList.add("apxor-badge-container");
        this.badgeContainer.classList.add("apxor-badge-container-styles-".concat(this.cssPostFix));
        if (this.badge.enable_background && this.badge.background.enable_image) {
          this.badgeContainer.classList.add("apxor-badge-container-background-image".concat(this.cssPostFix));
        }
        this.targetElement.appendChild(this.badgeContainer);
      }
    }, {
      key: "createBadgeContent",
      value: function createBadgeContent() {
        var _this$badge2,
          _this4 = this;
        this.badgeContent = document.createElement("div");
        this.badgeContent.classList.add("apxor-badge-content-container-".concat(this.cssPostFix));
        if ((_this$badge2 = this.badge) !== null && _this$badge2 !== void 0 && _this$badge2.content && this.badge.content.length !== 0) {
          this.badge.content.forEach(function (content, ind) {
            var _content$icon, _content$icon2;
            _this4.badgeContentElement = document.createElement("div");
            _this4.badgeContentElement.classList.add("apxor-badge-contentelement-".concat(ind, "-").concat(_this4.cssPostFix));
            _this4.badgeContentElement.setAttribute("id", "apxor-scroll-option");
            if (content.enable_icon && (_content$icon = content.icon) !== null && _content$icon !== void 0 && _content$icon.position && content.icon.position === "left") {
              var iconContainer = document.createElement("div");
              iconContainer.classList.add("apxor-badge-".concat(ind, "-icon-container").concat(_this4.cssPostFix));
              var iconElement = document.createElement("div");
              iconElement.classList.add("apxor-badge-".concat(ind, "-icon-content").concat(_this4.cssPostFix));
              iconContainer.appendChild(iconElement);
              _this4.badgeContentElement.appendChild(iconContainer);
            }
            if (content.enable_label) {
              resolveDynamicText(content.label);
              var labelElement = document.createElement("div");
              labelElement.classList.add("apxor-badge-".concat(ind, "-label-content-").concat(_this4.cssPostFix));
              labelElement.appendChild(createNewTextElement(content.label, _this4.configId, "label-content-".concat(ind)));
              _this4.badgeContentElement.appendChild(labelElement);
            }
            if (content.enable_icon && (_content$icon2 = content.icon) !== null && _content$icon2 !== void 0 && _content$icon2.position && content.icon.position === "right") {
              var _iconContainer = document.createElement("div");
              _iconContainer.classList.add("apxor-badge-".concat(ind, "-icon-container").concat(_this4.cssPostFix));
              var _iconElement = document.createElement("div");
              _iconElement.classList.add("apxor-badge-".concat(ind, "-icon-content").concat(_this4.cssPostFix));
              _iconContainer.appendChild(_iconElement);
              _this4.badgeContentElement.appendChild(_iconContainer);
            }
            _this4.badgeContent.appendChild(_this4.badgeContentElement);
          });
          this._getBadgeScrollKeyFrameStyles(this.badge.content.length);
        }
        this.badgeContainer.appendChild(this.badgeContent);
      }
    }, {
      key: "_setOnClickTerminationForBadges",
      value: function _setOnClickTerminationForBadges() {
        var _this$terminationConf4,
          _this$terminationConf5,
          _this5 = this;
        if ((_this$terminationConf4 = this.terminationConfig) !== null && _this$terminationConf4 !== void 0 && _this$terminationConf4.enable_touch && Object(this.terminationConfig.touch).length !== 0 && (_this$terminationConf5 = this.terminationConfig.touch) !== null && _this$terminationConf5 !== void 0 && _this$terminationConf5.target_view) {
          var onclickCallBack = function onclickCallBack() {
            var badge = document.getElementsByClassName("apxor-badge-container-styles-".concat(_this5.cssPostFix));
            while (badge.length > 0) badge[0].remove();
            _this5._controller.persistTerminationInfoLocally(_this5.configId);
            _this5.targetElement.removeEventListener("click", onclickCallBack);
          };
          this.targetElement.addEventListener("click", onclickCallBack);
        }
      }
    }, {
      key: "_setAutoTerminateForBadges",
      value: function _setAutoTerminateForBadges() {
        var _this$terminationConf6,
          _this6 = this;
        if ((_this$terminationConf6 = this.terminationConfig) !== null && _this$terminationConf6 !== void 0 && _this$terminationConf6.enable_time_based && this.terminationConfig.time_based.type === "duration") {
          window.setTimeout(function () {
            var badge = document.getElementsByClassName("apxor-badge-container-styles-".concat(_this6.cssPostFix));
            while (badge.length > 0) badge[0].remove();
            _this6._controller.persistTerminationInfoLocally(_this6.configId);
          }, this.terminationConfig.time_based.duration_seconds);
        }
      }
    }]);
    return ApxorBadge;
  }();
  var DOMNodePathStep = function DOMNodePathStep(value, optimized) {
    this.value = value;
    this.optimized = optimized || false;
  };
  DOMNodePathStep.prototype = {
    toString: function toString() {
      return this.value;
    }
  };

  var CoachmarkButtons = /*#__PURE__*/_createClass$1(function CoachmarkButtons() {
    var _this = this;
    var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    _classCallCheck$1(this, CoachmarkButtons);
    this.direction = convertTheDirectionCode(data.direction);
    this.alignment = convertThePositionCode(data.alignment);
    this.buttonArray = [];
    var buttonsList = getArrayOrDefault(data.list, []);
    buttonsList.forEach(function (button) {
      _this.buttonArray.push(new Button(button));
    });
  });

  /**
   * @constructor Content
   * @example
   * Example of a Content model is
   *
   * "content": {
      // if height and width keys are not given content height and width are calculated by us
      "height": 100,
      "width": 100,
      "position": "T/B/L/R",
      // title
      "enable_title": true,
      "title": {
        "background_color": "transparent",
        "max_characters": 150,
        "text": "Did you like the feature?",
        "alignment": "center",
        "color": "#000000",
        "font": {
          "family": "Helvetica Neue Medium",
          "size": 14,
          "style": "bold",
          "weight": "normal"
        },
        "enable_padding": true,
        "padding": {
          "top": 10,
          "bottom": 10,
          "left": 12,
          "right": 12
        },
        "enable_margin": true,
        "margin": {
          "top": 10,
          "bottom": 10,
          "left": 12,
          "right": 12
        }
      },
      // description
      "enable_description": true,
      "description": {
        "background_color": "transparent",
        "max_characters": 150,
        "text": "Did you like the feature? Please give us a feedback.",
        "alignment": "center",
        "color": "#000000",
        "font": {
          "family": "Helvetica Neue",
          "size": 14,
          "style": "bold",
          "weight": "normal"
        },
        "enable_padding": true,
        "padding": {
          "top": 10,
          "bottom": 10,
          "left": 12,
          "right": 12
        },
        "enable_margin": true,
        "margin": {
          "top": 10,
          "bottom": 10,
          "left": 12,
          "right": 12
        }
      },
      //buttons
      "enable_buttons": true,
      "buttons": {
        "direction": "H", // "V"
        "alignment": "C", //R,L
        "list": [
          {
            "color": "#C3EDC0",
            "text": {
              "text": "yes",
              "alignment": "center",
              "color": "#FFFFFF",
              "font": {
                "family": "Helvetica Neue",
                "size": 14,
                "style": "bold",
                "weight": "normal"
              },
              "enable_padding": true,
              "padding": {
                "top": 10,
                "bottom": 10,
                "left": 12,
                "right": 12
              },
              "enable_margin": true,
              "margin": {
                "top": 10,
                "bottom": 10,
                "left": 12,
                "right": 12
              }
            },
            "enable_action": true,
            "action": {
              "type": "redirect", // dismiss and cancel
              "url": "",
              "is_external": true,
              "is_ir": false,
              "is_within": true
            },
            "position": {
              "position": "L/R/C"
            },
            "enable_border": true,
            "border": {
              "radius": 0,
              "color": "#000000",
              "width": 0,
              "style": "solid"
            }
          },
          {
            "type": "normal",
            "color": "#000000",
            "text": {
              "text": "no",
              "alignment": "center",
              "color": "#017DFD",
              "font": {
                "family": "Helvetica Neue",
                "size": 14,
                "style": "bold",
                "weight": "normal"
              },
              "enable_padding": true,
              "padding": {
                "top": 10,
                "bottom": 10,
                "left": 12,
                "right": 12
              },
              "enable_margin": true,
              "margin": {
                "top": 10,
                "bottom": 10,
                "left": 12,
                "right": 12
              }
            },
            "enable_action": true,
            "action": {
              "type": "no",
              "url": "",
              "is_external": true,
              "is_ir": false,
              "is_within": true
            },
            "position": {
              "position": "L/R/C"
            },
            "enable_border": false,
            "border": {
              "radius": 0,
              "color": "#000000",
              "width": 0,
              "style": "solid"
            }
          }
        ]
      },
      "enable_margin": true,
      "margin": {
        "top": 10,
        "bottom": 10,
        "left": 10,
        "right": 10
      },
      "enable_offset": true,
      "offset": {
        "x": 10,
        "y": 10
      }
    },
   */
  var Content = /*#__PURE__*/function () {
    function Content() {
      var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck$1(this, Content);
      this.height = data.height;
      this.width = data.width;
      this.position = data.position;
      this.enable_title = data.enable_title;
      if (this.enable_title) {
        this.title = new Title(data.title);
      }
      this.enable_description = data.enable_description;
      if (this.enable_description) {
        this.description = new Description(data.description);
      }
      this.enable_buttons = data.enable_buttons;
      if (this.enable_buttons) {
        this.buttons = new CoachmarkButtons(data === null || data === void 0 ? void 0 : data.buttons);
      }
      this.enable_margin = data.enable_margin;
      if (this.enable_margin) {
        this.margin = new Margin(data.margin);
      }
      this.enable_offset = data.enable_offset;
      if (this.enable_offset) {
        this.offset = data.offset;
      }
    }
    _createClass$1(Content, null, [{
      key: "isEnabled",
      value: function isEnabled(data) {
        if (isUndefined$1(data) || isNull(data) || isEmptyObject(data)) {
          return false;
        } else {
          return true;
        }
      }
    }]);
    return Content;
  }();

  var Ripple = /*#__PURE__*/_createClass$1(function Ripple() {
    var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    _classCallCheck$1(this, Ripple);
    this.ripple_type = data.ripple_type;
    this.duration = data === null || data === void 0 ? void 0 : data.duration;
    this.width = data === null || data === void 0 ? void 0 : data.width;
    this.opacity = data === null || data === void 0 ? void 0 : data.opacity;
    this.color = data === null || data === void 0 ? void 0 : data.color;
  });

  var BackgroundOffset = /*#__PURE__*/_createClass$1(function BackgroundOffset() {
    var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    _classCallCheck$1(this, BackgroundOffset);
    this.top = data === null || data === void 0 ? void 0 : data.top;
    this.bottom = data === null || data === void 0 ? void 0 : data.bottom;
    this.left = data === null || data === void 0 ? void 0 : data.left;
    this.right = data === null || data === void 0 ? void 0 : data.right;
  });

  var Highlighter = /*#__PURE__*/_createClass$1(function Highlighter() {
    var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    _classCallCheck$1(this, Highlighter);
    this.enable_border = data === null || data === void 0 ? void 0 : data.enable_border;
    this.border = new Border(data === null || data === void 0 ? void 0 : data.border);
    this.shape = data === null || data === void 0 ? void 0 : data.shape;
    this.delta_circle = data === null || data === void 0 ? void 0 : data.delta_circle;
    this.delta_rect = new BackgroundOffset(data === null || data === void 0 ? void 0 : data.delta_rect);
    this.opacity = data === null || data === void 0 ? void 0 : data.opacity;
  });

  var OffsetXY = /*#__PURE__*/_createClass$1(function OffsetXY() {
    var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    _classCallCheck$1(this, OffsetXY);
    this.x = getNumberOrDefault(data === null || data === void 0 ? void 0 : data.x, 0);
    this.y = getNumberOrDefault(data === null || data === void 0 ? void 0 : data.y, 0);
  });

  var Background = /*#__PURE__*/function () {
    function Background() {
      var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck$1(this, Background);
      this.background_color = getColorOrDefault(data === null || data === void 0 ? void 0 : data.color, "#FFF").toLowerCase();
      this.opacity = data.opacity;
      this.shape = getStringOrDefault(data === null || data === void 0 ? void 0 : data.shape, "rectangle").toLowerCase();
      this.offset = new OffsetXY(data.offset);
      this.delta_circle = data === null || data === void 0 ? void 0 : data.delta_circle;
      this.delta_rect = new BackgroundOffset(data === null || data === void 0 ? void 0 : data.delta_rect);
    }
    _createClass$1(Background, null, [{
      key: "isEnabled",
      value: function isEnabled(data) {
        if (isUndefined$1(data) || isNull(data) || isEmptyObject(data)) {
          return false;
        } else {
          return true;
        }
      }
    }]);
    return Background;
  }();

  var DEFAULT_PADDING = 5;
  var Logger$1 = window.ApxorLogger;
  var InLineCoachMark = /*#__PURE__*/function () {
    function InLineCoachMark(config, uis, walkthroughConfigs, terminationConfig, messageConfig, rtmInstance, showCallback, hideCallback, stepperCallBack) {
      var _config$content, _config$content2;
      var isWalkthrough = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : false;
      var index = arguments.length > 10 && arguments[10] !== undefined ? arguments[10] : 0;
      _classCallCheck$1(this, InLineCoachMark);
      this.uiConfig = config;
      this.uis = uis;
      this.isWalkthrough = isWalkthrough;
      this.index = index;
      this.walkthroughConfigs = walkthroughConfigs;
      this.messageConfig = messageConfig;
      this.rtmInstance = rtmInstance;
      this.currentId = makeid(10);
      this.terminationTimeoutId = null;
      // Read name and id of the config
      this.configId = messageConfig.configId;
      this.name = messageConfig.configName;
      this.cssPostFix = "-".concat(this.configId, "-").concat(this.name).replaceAll(" ", "").replace(/[^\w\s]/gi, "");
      this.showCallback = showCallback;
      this.closeCallback = hideCallback;
      this.stepperCallBack = stepperCallBack;
      this.targetDeletionObserver = null;
      this.viewPortObservor = null;
      this.coachmarkShown = false;
      this.terminationConfig = terminationConfig;
      this.delay = config.delay;
      this.scrollToView = config.scrollToView || true;
      this.dismiss_outside_touch = config.dismiss_outside_touch;
      this.content = new Content(config.content);
      this.target = new Target(config.target);
      this.enable_dimbackground = config.enable_dimbackground;
      this.background = new Background(config.outer_highlighter);
      this.dimbackground = new DimBackground(config.dimbackground);
      this.enable_ripple = config.enable_ripple;
      this.ripple = new Ripple(config.ripple);
      this.highlighter = new Highlighter(config.inner_highlighter);
      this.enable_image = config === null || config === void 0 ? void 0 : config.enable_image;
      if (this.enable_image) {
        this.image = config === null || config === void 0 ? void 0 : config.image;
      }
      this.content_enable_buttons = (_config$content = config.content) === null || _config$content === void 0 ? void 0 : _config$content.enable_buttons;
      if (this.content_enable_buttons) this.buttons = new CoachmarkButtons((_config$content2 = config.content) === null || _config$content2 === void 0 ? void 0 : _config$content2.coachmark_buttons);
      this.targetElement = null;
      this.inline_width = "auto";
      this.inline_height = "auto";
      this.media_width = "auto";
      this.media_height = "auto";
      this.media_container_height = 0;
      this.targetElement = null;
      this.inLineContainer = null;
      this.imageAndContentContainerLeft = null;
      this.imageAndContentContainerRight = null;
      this.textContainer = null;
      this.dimBackgroundElement = null;
      this.max_width = 350;
      this.currentId = makeid(10);
      this.coachmark = null;
      this.svgElement = null;
      this.transparentCircleElement = null;
      this.textElement = null;
      this.rippleElement = null;
      this.imageoffsetX = 0;
      this.imageoffsetY = 0;
    }
    _createClass$1(InLineCoachMark, [{
      key: "createNewCoachMark",
      value: function createNewCoachMark() {
        var _this = this;
        try {
          // Check if a coachmark can be created.
          var canCreate = this._canCreateCoachMark();
          //If a coachmark can be created
          if (canCreate) {
            // Called when the target element comes into the viewport to show the coachmark
            var targetReachedCallback = function targetReachedCallback() {
              //this._highlightInlineTarget();
              _this._setInlineStyles();
              _this._setObservors();
              setTimeout(function () {
                // Create a tippy instance
                _this._createOuterCircle(_this.targetElement);
              }, _this.delay);
            };

            // Called when the valid target is found to show the coachmark
            var targetValidCallback = function targetValidCallback() {
              //Once the target is found then scroll into it.
              _this._scrollIntoTargetIfNeeded(targetReachedCallback);
            };

            // Set the target for InLine coachmark
            this._setTheTarget(targetValidCallback);
          }
        } catch (e) {
          this._resetRTMAction();
          console.log(e);
        }
      }

      /**
       * @function _canCreateCoachMark
       * @private
       * @description Checks if an action is already being performed.
       * A new coachmark can be created only if no other step/campaign is being shown.
       * @returns {boolean} true  - If a new coachmark can be created
       *                    false - A new coachmark can not be created.
       */
    }, {
      key: "_canCreateCoachMark",
      value: function _canCreateCoachMark() {
        if (this.rtmInstance.currentAction !== null && this.rtmInstance.currentAction !== undefined || this.rtmInstance.isShowingAction) {
          Logger$1.info("An nudge is being shown. Can not show a coachmark now");
          return false;
        }
        this.rtmInstance.currentAction = this;
        return true;
      }

      /**
       * @function _setTheTarget
       * @private
       * @description Sets the target for the coachmark.
       * @param {function} targetValidCallback
       */
    }, {
      key: "_setTheTarget",
      value: function _setTheTarget(targetValidCallback) {
        var _this2 = this;
        var targetFoundCallback = function targetFoundCallback() {
          var isElementVisible = _this2._isElementVisible();
          if (isElementVisible) {
            var targetClickedCallback = _this2._targetClickCallback.bind(_this2);
            // Attch a click callback to the target. If the target dismiss config is true, it will dismiss the coachmark
            _this2.targetElement.addEventListener("click", targetClickedCallback);
            targetValidCallback();
          } else {
            var _this2$target;
            Logger$1.info("Invalid target element. Width and height are 0 for element: ".concat((_this2$target = _this2.target) === null || _this2$target === void 0 ? void 0 : _this2$target.id, ". Can't show coachmark"));
            _this2._resetRTMAction();
          }
        };
        this._findTargetElement(targetFoundCallback);
      }

      /**
       * @function _isElementVisible
       * @private
       * @description Checks if the element has a visible height and width
       * @returns {boolean} true  - If element is visible
       *                    false - If the element is not visible
       */
    }, {
      key: "_isElementVisible",
      value: function _isElementVisible() {
        try {
          var rect = this.targetElement.getBoundingClientRect();
          if (rect.width === 0 || rect.height === 0) {
            return false;
          }
        } catch (e) {
          return false;
        }
        return true;
      }

      /**
       * @function _findTargetElement
       * @private
       * @description Finds the target element in the DOM.
       * @param {function} targetFoundCallback
       */
    }, {
      key: "_findTargetElement",
      value: function _findTargetElement(targetFoundCallback) {
        var _this$target, _this$target2;
        this.targetElement = getElementFromSelector((_this$target = this.target) === null || _this$target === void 0 ? void 0 : _this$target.id, (_this$target2 = this.target) === null || _this$target2 === void 0 ? void 0 : _this$target2.frame_id);
        if (!this.targetElement) {
          var _this$target3;
          if ((_this$target3 = this.target) !== null && _this$target3 !== void 0 && _this$target3.enable_retry) {
            Logger$1.info("Not found yet. Rechecking the DOM.");
            this._retryFindingTargetElement(targetFoundCallback);
          } else {
            var _this$target4;
            Logger$1.info("Element with selector:".concat((_this$target4 = this.target) === null || _this$target4 === void 0 ? void 0 : _this$target4.id, " not found."));
            this._resetRTMAction();
          }
        } else {
          targetFoundCallback();
        }
      }

      /**
       * @function _retryFindingTargetElement
       * @private
       * @description Continuously rechecks the DOM for the target element after every retry_interval.
       * Maximum times it checks is configured through max_retries
       * @param {function} targetFoundCallback
       */
    }, {
      key: "_retryFindingTargetElement",
      value: function _retryFindingTargetElement(targetFoundCallback) {
        var _this3 = this,
          _this$target5;
        //After every find_interval check the DOM for target element.
        var elementRecheckIntervalId = setInterval(function () {
          var _this3$target, _this3$target2;
          _this3.targetElement = getElementFromSelector((_this3$target = _this3.target) === null || _this3$target === void 0 ? void 0 : _this3$target.id, (_this3$target2 = _this3.target) === null || _this3$target2 === void 0 ? void 0 : _this3$target2.frame_id);
          //If the element is found, stop checking the DOM.
          if (_this3.targetElement) {
            clearInterval(elementRecheckIntervalId);
            targetFoundCallback(_this3.targetElement);
          } else {
            var _this3$target3, _this3$target4;
            _this3.target.retry.max_retries = ((_this3$target3 = _this3.target) === null || _this3$target3 === void 0 ? void 0 : _this3$target3.retry.max_retries) - 1;
            // If the element is not found even after max interval, stop checking
            if (((_this3$target4 = _this3.target) === null || _this3$target4 === void 0 ? void 0 : _this3$target4.retry.max_retries) <= 0) {
              var _this3$target5;
              clearInterval(elementRecheckIntervalId);
              console.warn("Element with selector:".concat((_this3$target5 = _this3.target) === null || _this3$target5 === void 0 ? void 0 : _this3$target5.id, " not found."));
              _this3._resetRTMAction();
            }
          }
        }, (_this$target5 = this.target) === null || _this$target5 === void 0 ? void 0 : _this$target5.retry.interval);
      }

      /**
       * @function _targetClickCallback
       * @private
       * @description If the dismiss of coachmark on target click is enabled,
       * logs an event and destroys the coachmark.
       */
    }, {
      key: "_targetClickCallback",
      value: function _targetClickCallback() {
        if (this.enable_dismiss_actions && this.dismiss_actions.target_touch) {
          this.rtmInstance.logActionEvent("InlineTargetViewClicked", this.configId, this.name);
          this._destroyCoachMark();
        }
      }
    }, {
      key: "_scrollIntoTargetIfNeeded",
      value: function _scrollIntoTargetIfNeeded(targetReachedCallback) {
        var _this4 = this;
        var scrolled = false;
        var isTargetInViewPort = isElementInViewport(this.targetElement);
        // If the element is not in the viewport. scroll into the target element only if the config says so.
        if (!isTargetInViewPort) {
          if (this.scrollToView) {
            // We only use one scroll behaviour for coachmark.
            var scrollIntoViewOptions = {
              behavior: SCROLL_BEHAVIOUR.SMOOTH,
              block: CENTER,
              inline: CENTER
            };
            this.targetElement.scrollIntoView(scrollIntoViewOptions);
            scrolled = true;
            window.setTimeout(function () {
              var isTargetElementCovered = isElementCovered(_this4.targetElement);
              if (isTargetElementCovered) {
                window.setTimeout(function () {
                  var isTargetElementCovered = isElementCovered(_this4.targetElement);
                  if (isTargetElementCovered) {
                    console.info("The tooltip is not visible because another element is overlapping the target element.");
                    _this4._resetRTMAction();
                  } else {
                    targetReachedCallback();
                  }
                }, 1000);
              }
            }, 1000);
          } else {
            Logger$1.info("If needed change the config to scroll to the target element.");
          }
        } else {
          scrolled = true;
          window.setTimeout(function () {
            var isTargetElementCovered = isElementCovered(_this4.targetElement);
            if (isTargetElementCovered) {
              window.setTimeout(function () {
                var isTargetElementCovered = isElementCovered(_this4.targetElement);
                if (isTargetElementCovered) {
                  console.info("The tooltip is not visible because another element is overlapping the target element.");
                  _this4._resetRTMAction();
                } else {
                  targetReachedCallback();
                }
              }, 1000);
            }
          }, 1000);
        }

        // If the target is in viewport
        if (scrolled) {
          targetReachedCallback();
        }
      }

      /**
       * @function _resetRTMAction
       * @private
       * @description Resets the current action on the RTM.
       */
    }, {
      key: "_resetRTMAction",
      value: function _resetRTMAction() {
        this.rtmInstance.currentAction = null;
        this.rtmInstance.isShowingAction = false;
        Logger$1.info("RTM coachmark action stopped.");
      }
      /**
       * @function _destroyCoachMark
       * @private
       * @description Destroys the coachmark and notifies the close callback.
       * @param {boolean} isCancelled - true if the cancel action is called else false
       */
    }, {
      key: "_destroyCoachMark",
      value: function _destroyCoachMark() {
        var isCancelled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
        try {
          var _this$targetDeletionO, _this$viewPortObservo, _this$coachmark, _this$dimBackgroundEl;
          //Disconnect both the observors
          (_this$targetDeletionO = this.targetDeletionObserver) === null || _this$targetDeletionO === void 0 || _this$targetDeletionO.disconnect();
          this.targetDeletionObserver = null;
          (_this$viewPortObservo = this.viewPortObservor) === null || _this$viewPortObservo === void 0 || _this$viewPortObservo.disconnect();
          this.viewPortObservor = null;
          //Destroy the coachmark
          (_this$coachmark = this.coachmark) === null || _this$coachmark === void 0 || _this$coachmark.destroy();
          this.svgElement.parentNode.removeChild(this.svgElement);
          this.textElement.parentNode.removeChild(this.textElement);
          this.rippleElement.parentNode.removeChild(this.rippleElement);
          //If the dim background is set, remove that as well.
          (_this$dimBackgroundEl = this.dimBackgroundElement) === null || _this$dimBackgroundEl === void 0 || _this$dimBackgroundEl.remove();
          //Delete all the styles created for coachmark
          this._removeStyles();
          //Remove the highlight styles on the target
          this.targetElement.removeAttribute("apx-inline-dimbackground");
          //this.targetElement.classList.remove("apx-dimbackground");
          clearTimeout(this.terminationTimeoutId);
          this.targetElement.removeEventListener("click", this._targetClickCallback);
        } catch (e) {
          Logger$1.info("Destroying the coachmark:" + e);
        }
        this.closeCallback(isCancelled);
      }

      /**
       * @function _removeStyles
       * @private
       * @description Removes the coachmark styles tag
       */
    }, {
      key: "_removeStyles",
      value: function _removeStyles() {
        try {
          var apxor_coachmark_styles = document.querySelector("style[apx-coachmark-styles]");
          if (apxor_coachmark_styles) {
            apxor_coachmark_styles.remove();
          }
        } catch (e) {
          Logger$1.error("Could not remove the coachmark styles:" + e);
        }
      }

      /**
       * @function _highlightInlineTarget
       * @private
       * @description Creates the overlay and dim background elements and adds them to the document body.
       */
    }, {
      key: "_highlightInlineTarget",
      value: function _highlightInlineTarget() {
        this.coachmarkShown = true;
        if (this.enable_dimbackground) {
          if (this.highlighter.shape === "circle") {
            this.dimBackgroundElement = createMask(this.rippleElement, true);
          } else if (this.highlighter.shape === "rectangle") {
            this.dimBackgroundElement = createMask(this.rippleElement, false);
          }
          document.body.appendChild(this.dimBackgroundElement);
          if (this.enable_dismiss_actions && this.dismiss_actions.target_touch) {
            var maskOpening = this.dimBackgroundElement.querySelector("#tippyModalMaskOpening");
            var targetClickedCallback = this._targetClickCallback.bind(this);
            maskOpening.addEventListener("click", targetClickedCallback);
          }
          //this.targetElement.setAttribute("apx-inline-dimbackground", "");
        }
      }
    }, {
      key: "_createInnerCircle",
      value: function _createInnerCircle(width, height, left, top, type, border_color, border_width, border_style, border_radius, delta_circle, innerrect_x, innerrect_y, innerrect_left, innerrect_right, ripple_width, ripple_duration) {
        var newWidth = Math.sqrt(Math.pow(width, 2) + Math.pow(height, 2));
        // newWidth += delta_circle;
        var rr = newWidth + delta_circle;
        var newHeight = newWidth;
        var newLeft = left - (newWidth - width) / 2;
        var newTop = top - (newWidth - height) / 2;
        type = this.highlighter.shape;
        var rwrw;
        var rhrh;
        if (type != "circle") {
          newWidth = width + innerrect_left + innerrect_right;
          rwrw = newWidth;
          newHeight = height + innerrect_x + innerrect_y;
          rhrh = newHeight;
          newLeft = left - innerrect_left;
          newTop = top - innerrect_x;
        }
        this.rippleElement = document.createElement("div");
        this.rippleElement.setAttribute("id", this.configId + "-ripple-div");
        //this.rippleElement.setAttribute("color", this.ripple.color);
        if (this.enable_ripple) {
          if (this.ripple.ripple_type === "outward") {
            if (type === "circle") {
              this.rippleElement.innerHTML = this._addRippleStylesOutward(type, rr, rr, ripple_width, ripple_duration, this.ripple.color, this.ripple.opacity);
            } else {
              this.rippleElement.innerHTML = this._addRippleStylesOutward(type, rwrw, rhrh, ripple_width, ripple_duration, this.ripple.color, this.ripple.opacity);
            }
          } else if (this.ripple.ripple_type === "inward") {
            if (type === "circle") {
              this.rippleElement.innerHTML = this._addRippleStylesInward(type, rr, rr, ripple_width, ripple_duration, this.ripple.color, this.ripple.opacity);
            } else {
              this.rippleElement.innerHTML = this._addRippleStylesInward(type, rwrw, rhrh, ripple_width, ripple_duration, this.ripple.color, this.ripple.opacity);
            }
          }
        }
        this.rippleElement.style.position = "absolute";
        // newWidth = newWidth + +delta_circle + border_width;
        // newHeight = newWidth;
        if (type === "circle") {
          rr = rr + 2 * border_width;
          var xx = delta_circle / 2;
          newLeft = newLeft - xx - border_width;
          newTop = newTop - xx - border_width;
          this.rippleElement.style.width = "".concat(rr, "px");
          this.rippleElement.style.height = "".concat(rr, "px");
          this.rippleElement.style.left = "".concat(newLeft, "px");
          this.rippleElement.style.top = "".concat(newTop, "px");
        } else {
          newLeft = newLeft - border_width;
          newTop = newTop - border_width;
          this.rippleElement.style.width = "".concat(newWidth, "px");
          this.rippleElement.style.height = "".concat(newHeight, "px");
          this.rippleElement.style.left = "".concat(newLeft, "px");
          this.rippleElement.style.top = "".concat(newTop, "px");
        }
        this.rippleElement.classList.add("ripple-animator");
        this.rippleElement.style.borderRadius = "".concat(this.highlighter.shape === "circle" ? "50%" : border_radius);
        this.rippleElement.style.visibility = "visible";
        this.rippleElement.style.zIndex = 99999;
        // this.rippleElement.style.opacity = "1";
        this.rippleElement.style.color = "".concat(this.ripple.color);
        if (this.highlighter.enable_border) {
          this.rippleElement.style.borderColor = "".concat(border_color);
          this.rippleElement.style.borderWidth = "".concat(border_width, "px");
          this.rippleElement.style.borderStyle = "".concat(border_style);
        }
        document.body.appendChild(this.rippleElement);
        return this.rippleElement;
      }
    }, {
      key: "_getDocumentOffsetPosition",
      value: function _getDocumentOffsetPosition(el) {
        var rect = el.getBoundingClientRect();

        // Add window scroll position to get the offset position
        // relative to the document but not viewport.
        var left = rect.left + window.scrollX;
        var top = rect.top + window.scrollY;
        var right = rect.right + window.scrollX;
        var bottom = rect.bottom + window.scrollY;

        // polyfill missing 'x' and 'y' rect properties not returned
        // from getBoundingClientRect() by older browsers
        var x = isDefined(rect.x) ? rect.x + window.scrollX : left;
        var y = isDefined(rect.y) ? rect.y + window.scrollY : top;

        // width and height are the same
        var width = rect.width;
        var height = rect.height;
        return {
          left: left,
          top: top,
          right: right,
          bottom: bottom,
          x: x,
          y: y,
          width: width,
          height: height
        };
      }
    }, {
      key: "_addRippleStylesInward",
      value: function _addRippleStylesInward(type, width, height, ripple_width, ripple_duration, ripple_color, ripple_opacity) {
        var half_ripple_width = ripple_width / 2;
        ripple_duration = ripple_duration / 1000;
        return "\n<style>\n.ripple-animator {\n  border: none;\n  outline: none;\n  width: 150px;\n  height: 150px;\n  display: block;\n  color: ".concat(ripple_color, ";\n  opacity:").concat(ripple_opacity, ";\n  display: grid;\n  place-items: center;\n  font-size: 18px;\n  cursor: pointer;\n  overflow:hidden;\n\n  animation-name: rippleinward;\n  animation-duration: ").concat(ripple_duration, "s;\n  animation-iteration-count: infinite;\n}\n\n@keyframes rippleinward {\n  0% {\n    \n    box-shadow: 0 0 0 ").concat(half_ripple_width, "px #fff0;\n}\n\n100% {\n  box-shadow: 0 0 0 0 ").concat(ripple_color, ";\n  opacity:").concat(ripple_opacity, ";\n}\n}\n\n</style>");
      }
    }, {
      key: "_addRippleStylesOutward",
      value: function _addRippleStylesOutward(type, width, height, ripple_width, ripple_duration, ripple_color, ripple_opacity) {
        // height = height + 2 * delta_circle;
        // width = width + 2 * delta_circle;
        var half_ripple_width = ripple_width / 2;
        ripple_duration = ripple_duration / 1000;
        return "\n<style>\n.ripple-animator {\n    border: none;\n    outline: none;\n    width: 150px;\n    height: 150px;\n    display: block;\n    color: ".concat(ripple_color, ";\n    opacity:").concat(ripple_opacity, ";\n    display: grid;\n    place-items: center;\n    font-size: 18px;\n    cursor: pointer;\n    overflow:auto;\n\n    animation-name: ripple;\n    animation-duration: ").concat(ripple_duration, "s;\n    animation-iteration-count: infinite;\n}\n\n\n@keyframes ripple {\n    0% {\n        box-shadow: 0 0 0 0 ").concat(ripple_color, ";\n        opacity:").concat(ripple_opacity, ";\n    }\n\n    100% {\n        box-shadow: 0 0 0 ").concat(half_ripple_width, "px #fff0;\n    }\n}\n</style>");
      }

      /**
       * @function _setInlineStyles
       * @private
       * @description Creates all the styles needed by the InLine Coachmark.
       */
    }, {
      key: "_setInlineStyles",
      value: function _setInlineStyles() {
        var apxor_coachmark_styles = document.querySelector("style[apx-coachmark-styles]");
        if (apxor_coachmark_styles) {
          return;
        }
        var styles = " \n      ".concat(this._getBackgroundContainerStyles(), " \n      ").concat(this._getInLineContainerStyles(), " \n       ").concat(this._getInLineMediaContainerStyles(), "\n      ").concat(this._getInLineNonMediaContainerStyles(), "\n      ").concat(this._getTextConatinerStyles(), "\n      ").concat(this._getTitleStyles(), " \n      ").concat(this._getDescriptionStyles(), " \n      ").concat(this._getImageStyles(), " \n    ").replaceAll("\n", "").replace(/[\s]{2,999}/g, "");
        var styleNode = document.createElement("style");
        styleNode.setAttribute("apx-coachmark-styles", "");
        styleNode.innerHTML = styles;
        document.head.appendChild(styleNode);
      }

      /**
       * @function _getBackgroundContainerStyles
       * @private
       * @description Creates the styles for the inline overlay and dimbackground overlay
       * @returns {string} css styles
       */
    }, {
      key: "_getBackgroundContainerStyles",
      value: function _getBackgroundContainerStyles() {
        var backgroundContainerStyle = "";
        if (this.enable_dimbackground) {
          var _this$dimbackground$o, _this$dimbackground$c;
          // :where is used to reduce the specificity of this style.
          // If at all the target element has a position that should not get disturbed.
          backgroundContainerStyle = "\n      #tippyModalOverlayContainer {\n        -ms-filter: \"progid:dximagetransform.microsoft.gradient.alpha(Opacity=50)\";\n        filter: alpha(opacity=50);height: 100vh;left: 0;opacity: ".concat((_this$dimbackground$o = this.dimbackground.opacity) !== null && _this$dimbackground$o !== void 0 ? _this$dimbackground$o : 0.5, ";position: fixed;\n        top: 0;transition: all .3s ease-out;width: 100vw;z-index: 9999;fill: ").concat((_this$dimbackground$c = this.dimbackground.color) !== null && _this$dimbackground$c !== void 0 ? _this$dimbackground$c : "transparent", "\n      }\n      #tippyModalOverlayContainer #tippyModalMask, #tippyModalOverlayContainer #tippyModalMaskRect {\n        height: 100vh;width: 100vw\n      }\n      \n    ");
          /*
            box-shadow: 0 0 0 max(100vh, 100vw) ${hexToRGB(
              this.dimbackground.color,
              this.dimbackground.opacity
            )};
            z-index:9999;
            overflow: visible;
            position:relative;
            */
        }

        return backgroundContainerStyle;
      }

      /**
       * @function _getInLineContainerStyles
       * @private
       * @description Creates the styles for the inline container
       * @returns {string} css styles
       */
    }, {
      key: "_getInLineContainerStyles",
      value: function _getInLineContainerStyles() {
        // let marginStylesForContainer = "";
        // if (this.content.margin) {
        //   marginStylesForContainer = `
        //     padding:${this.content.margin.top}px ${this.content.margin.right}px ${this.content.margin.bottom}px ${this.content.margin.left}px;
        //   `;
        // }

        //justify-content: space-evenly;
        //align-items:stretch
        var inlineContainerStyles = "\n      .apx-inline-container".concat(this.cssPostFix, " {\n         height:auto;\n         width:auto;\n\n        z-index:999999;\n        opacity:1;\n        transition:all .5s cubic-bezier(.96,.23,.07,.8);\n        position:absolute;\n        visibility:visible;\n      }\n\n      .apx-inline-container").concat(this.cssPostFix, ".open{\n        opacity:1;\n        visibility:visible;\n      }\n    ");
        return inlineContainerStyles;
      }
      /**
       * @function _getInLineNonMediaContainerStyles
       * @private
       * @description Creates the styles for the inline Non-Media container
       * @returns {string} css styles
       */
    }, {
      key: "_getInLineNonMediaContainerStyles",
      value: function _getInLineNonMediaContainerStyles() {
        var inlineNonMediaContainerStyles = "";
        var maxHeight = "";
        inlineNonMediaContainerStyles = "\n        .apx-inline-nonmedia-container".concat(this.cssPostFix, "{\n          width:100%;\n          max-width:").concat(this.max_width, ";\n          display:flex;\n          flex-direction:column;\n          justify-content:center;\n          align-items:stretch;\n          ").concat(maxHeight, "\n        }\n      ");
        return inlineNonMediaContainerStyles;
      }

      /**
       * @function _getInLineMediaContainerStyles
       * @private
       * @description Creates the styles for the inline Media container
       * @returns {string} css styles
       */
    }, {
      key: "_getInLineMediaContainerStyles",
      value: function _getInLineMediaContainerStyles() {
        var inlineMediaContainerStyles = "\n    .apx-inline-media-container".concat(this.cssPostFix, "{\n      ").concat(this.enable_image || this.enable_video ? "display:flex;" : "", "\n    }");
        return inlineMediaContainerStyles;
      }

      /**
       * @function _getTextContainerStyles
       * @private
       * @description Creates the styles for the text container
       * @returns {string} css styles
       */
    }, {
      key: "_getTextConatinerStyles",
      value: function _getTextConatinerStyles() {
        var contentStyling = "\n      .apx-inline-text-container".concat(this.cssPostFix, "{\n        width:100%;\n        display:flex;\n        flex-direction:column;\n        justify-content: center;\n        overflow: hidden;\n      }\n    ");
        return contentStyling;
      }

      /**
       * @function _getTitleStyles
       * @private
       * @description Creates the styles for the title
       * @returns {string} css styles
       */
    }, {
      key: "_getTitleStyles",
      value: function _getTitleStyles() {
        if (!this.content.enable_title) {
          return "";
        }
        var titleMarginStyles = "";
        if (this.content.title.enable_margin) {
          titleMarginStyles = " \n        margin-top:".concat(this.content.title.margin.top, "px;\n        margin-bottom:").concat(this.content.title.margin.bottom, "px;\n        margin-left:").concat(this.content.title.margin.left, "px;\n        margin-right:").concat(this.content.title.margin.right, "px;\n      ");
        }
        var titlePaddingStyles = "";
        if (this.content.title.enable_padding) {
          titlePaddingStyles = " \n        padding-top:".concat(this.content.title.padding.top, "px;\n        padding-bottom:").concat(this.content.title.padding.bottom, "px;\n        padding-left:").concat(this.content.title.padding.left, "px;\n        padding-right:").concat(this.content.title.padding.right, "px;\n      ");
        }
        var titleFontStyles = "";
        titleFontStyles = " \n        font-family:".concat(this.content.title.font.family, ";\n        font-size:").concat(this.content.title.font.size, "px;\n        font-style:").concat(this.content.title.font.style, ";\n        font-weight:").concat(this.content.title.font.weight, ";\n      ");
        var titeStyles = "\n      .apx-inline-title-div".concat(this.cssPostFix, " {\n        width:100%;\n        display:flex;\n        background-color:").concat(this.content.title.background_color, "\n        justify-content:").concat(this.content.title.alignment, ";\n        text-align:").concat(this.content.title.alignment, ";\n        ").concat(titleFontStyles, "\n        ").concat(titleMarginStyles, "\n        ").concat(titlePaddingStyles, "\n      }\n    ");
        return titeStyles;
      }

      /**
       * @function _getDescriptionStyles
       * @private
       * @description Creates the styles for text description
       * @returns {string} css styles
       */
    }, {
      key: "_getDescriptionStyles",
      value: function _getDescriptionStyles() {
        if (!this.content.enable_description) {
          return "";
        }
        var descriptionMarginStyles = "";
        if (this.content.description.enable_margin) {
          descriptionMarginStyles = " \n        margin-top:".concat(this.content.description.margin.top, "px;\n        margin-bottom:").concat(this.content.description.margin.bottom, "px;\n        margin-left:").concat(this.content.description.margin.left, "px;\n        margin-right:").concat(this.content.description.margin.right, "px;\n      ");
        }
        var descriptionPaddingStyles = "";
        if (this.content.description.enable_padding) {
          descriptionPaddingStyles = " \n        padding-top:".concat(this.content.description.padding.top, "px;\n        padding-bottom:").concat(this.content.description.padding.bottom, "px;\n        padding-left:").concat(this.content.description.padding.left, "px;\n        padding-right:").concat(this.content.description.padding.right, "px;\n      ");
        }
        var descriptionFontStyles = "";
        descriptionFontStyles = " \n        font-family:".concat(this.content.description.font.family, ";\n        font-size:").concat(this.content.description.font.size, "px;\n        font-style:").concat(this.content.description.font.style, ";\n        font-weight:").concat(this.content.description.font.weight, ";\n      ");
        var descriptionStyles = "\n      .apx-inline-description".concat(this.cssPostFix, " {\n        width:100%;\n        justify-content:").concat(this.content.description.alignment, ";\n        text-align:").concat(this.content.description.alignment, ";\n        ").concat(descriptionFontStyles, "\n        ").concat(descriptionMarginStyles, "\n        ").concat(descriptionPaddingStyles, "\n      }\n    ");
        return descriptionStyles;
      }

      // /**
      //  * @function _getInLineButtonContainerStyles
      //  * @private
      //  * @description Creates the styles for the inline button container
      //  * @returns {string} css styles
      //  */
      // _getInLineButtonContainerStyles() {
      //   const inlineButtonContainerStyles = `
      //   .apx-inline-button-container${this.cssPostFix}{
      //      margin-top:${this.content.margin.top}px;
      //      margin-bottom:${this.content.margin.bottom}px;
      //      margin-left:${this.content.margin.left}px;
      //      margin-right:${this.content.margin.right}px;
      //   }`;
      //   return inlineButtonContainerStyles;
      // }

      /**
       * @function _getImageStyles
       * @private
       * @description Creates the styles for images
       * @returns {string} css styles
       */
    }, {
      key: "_getImageStyles",
      value: function _getImageStyles() {
        var imageStyles = "";

        //Create the css for images only if image_config is sent.
        if (this.enable_image) {
          var _this$image, _this$image6, _this$image7;
          var imageBorderStyles = "";
          if ((_this$image = this.image) !== null && _this$image !== void 0 && _this$image.enable_border) {
            var _this$image2, _this$image3, _this$image4, _this$image5;
            imageBorderStyles = "\n          border-radius:".concat((_this$image2 = this.image) === null || _this$image2 === void 0 ? void 0 : _this$image2.border.radius, "%;\n          border:").concat((_this$image3 = this.image) === null || _this$image3 === void 0 ? void 0 : _this$image3.border.width, "px ").concat((_this$image4 = this.image) === null || _this$image4 === void 0 ? void 0 : _this$image4.border.style, " ").concat((_this$image5 = this.image) === null || _this$image5 === void 0 ? void 0 : _this$image5.border.color, ";\n          ");
          }
          imageStyles = "\n        .apx-inline-image".concat(this.cssPostFix, "{\n          height: ").concat((_this$image6 = this.image) === null || _this$image6 === void 0 ? void 0 : _this$image6.height, "px;\n          width: ").concat((_this$image7 = this.image) === null || _this$image7 === void 0 ? void 0 : _this$image7.width, "px;\n          ").concat(imageBorderStyles, "\n        }\n      ");
        }
        return imageStyles;
      }

      /**
       * @function _setInLineContent
       * @private
       * @description Sets the content of the InLine.
       */
    }, {
      key: "_setInLineContent",
      value: function _setInLineContent() {
        var _this$image8, _this$image9, _this$image10, _this$image11;
        // Create the coachmark container
        this._createInLineContainer();
        if (((_this$image8 = this.image) === null || _this$image8 === void 0 ? void 0 : _this$image8.position) === "T") {
          this._createMediaContainer();
          this._setImageOptions();
          this._createNonMediaContainer();
          // Set the text container
          this._setTextContainer();
          // Set the title content
          this._setTitleContent();
          // Set the description content in the text conatiner
          this._setDescriptionContent();
          // Create Buttom container
          this._createButtonContainer();
          // Create the Media container
          this._setButtons();
        }
        if (((_this$image9 = this.image) === null || _this$image9 === void 0 ? void 0 : _this$image9.position) === "L") {
          this._imageAndContentContainerLeft();
        }
        if (((_this$image10 = this.image) === null || _this$image10 === void 0 ? void 0 : _this$image10.position) === "R") {
          this._imageAndContentContainerRight();
        }
        if (((_this$image11 = this.image) === null || _this$image11 === void 0 ? void 0 : _this$image11.position) === "B") {
          this._createNonMediaContainer();
          // Set the text container
          this._setTextContainer();
          // Set the title content
          this._setTitleContent();
          // Set the description content in the text conatiner
          this._setDescriptionContent();
          // Create Buttom container
          this._createButtonContainer();
          // Create the Media container
          this._setButtons();
          this._createMediaContainer();
          this._setImageOptions();
        } else {
          this._createNonMediaContainer();
          // Set the text container
          this._setTextContainer();
          // Set the title content
          this._setTitleContent();
          // Set the description content in the text conatiner
          this._setDescriptionContent();
          // Create Buttom container
          this._createButtonContainer();
          // Create the Media container
          this._setButtons();
        }
        return this.inLineContainer;
        // Create Buttom container
      }

      /**
       * @function _createInLineContainer
       * @private
       * @description Creates the container for the InLine
       */
    }, {
      key: "_createInLineContainer",
      value: function _createInLineContainer() {
        // InLine coachmark container.
        this.inLineContainer = document.createElement("div");
        this.inLineContainer.classList.add("apx-inline-container".concat(this.cssPostFix));
        this.inLineContainer.style.position = "absolute";
        document.body.appendChild(this.inLineContainer);
        //document.body.appendChild(this.inLineContainer);
      }
    }, {
      key: "_imageAndContentContainerLeft",
      value: function _imageAndContentContainerLeft() {
        this.imageAndContentContainerLeft = document.createElement("div");
        this._createMediaContainer();
        this._setImageOptions();
        this._createNonMediaContainer();
        // Set the text container
        this._setTextContainer();
        // Set the title content
        this._setTitleContent();
        // Set the description content in the text conatiner
        this._setDescriptionContent();
        // Create Buttom container
        this._createButtonContainer();
        // Create the Media container
        this._setButtons();
        this.imageAndContentContainerLeft.style.display = "flex";
        this.imageAndContentContainerLeft.style.flexDirection = "row";
        this.imageAndContentContainerLeft.style.justifyContent = "center";
        this.imageAndContentContainerLeft.style.alignItems = "center";
        this.inLineContainer.appendChild(this.imageAndContentContainerLeft);
      }
    }, {
      key: "_imageAndContentContainerRight",
      value: function _imageAndContentContainerRight() {
        this.imageAndContentContainerRight = document.createElement("div");
        this._createNonMediaContainer();
        // Set the text container
        this._setTextContainer();
        // Set the title content
        this._setTitleContent();
        // Set the description content in the text conatiner
        this._setDescriptionContent();
        // Create Buttom container
        this._createButtonContainer();
        // Create the Media container
        this._setButtons();
        this._createMediaContainer();
        this._setImageOptions();
        this.imageAndContentContainerRight.style.display = "flex";
        this.imageAndContentContainerRight.style.flexDirection = "row";
        this.imageAndContentContainerRight.style.justifyContent = "center";
        this.imageAndContentContainerRight.style.alignItems = "center";
        this.inLineContainer.appendChild(this.imageAndContentContainerRight);
      }

      /**
       * @function _createNonMediaContainer
       * @private
       * @description Creates the container for the text and button
       */
    }, {
      key: "_createNonMediaContainer",
      value: function _createNonMediaContainer() {
        var _this$image12, _this$image13;
        this.nonMediaContainer = document.createElement("div");
        this.nonMediaContainer.classList.add("apx-inline-nonmedia-container".concat(this.cssPostFix));
        if (((_this$image12 = this.image) === null || _this$image12 === void 0 ? void 0 : _this$image12.position) === "L") {
          this.imageAndContentContainerLeft.appendChild(this.nonMediaContainer);
        } else if (((_this$image13 = this.image) === null || _this$image13 === void 0 ? void 0 : _this$image13.position) === "R") {
          this.imageAndContentContainerRight.appendChild(this.nonMediaContainer);
        } else {
          this.inLineContainer.appendChild(this.nonMediaContainer);
        }
      }

      /**
       * @funciton _setTextContainer
       * @private
       * @description Sets the container for the title and the description
       */
    }, {
      key: "_setTextContainer",
      value: function _setTextContainer() {
        this.textContainer = document.createElement("div");
        this.textContainer.classList.add("apx-inline-text-container".concat(this.cssPostFix));
        this.nonMediaContainer.appendChild(this.textContainer);
      }

      /**
       * @funciton _setTitleContent
       * @private
       * @description Sets the title content in the InLine coachmark. This is a common config for all coachmark.
       */
    }, {
      key: "_setTitleContent",
      value: function _setTitleContent() {
        // Create an element for the title and append it to the container.
        if (this.content.enable_title) {
          // Before creating the text element, evaluate the dynamic text if any
          resolveDynamicText(this.title);
          var titleElement = document.createElement("div");
          titleElement.classList.add("apx-inline-title-div".concat(this.cssPostFix));
          titleElement.appendChild(createNewTextElement(this.content.title, this.currentId, "title"));
          this.textContainer.appendChild(titleElement);
        }
      }

      /**
       * @funciton _setDescriptionContent
       * @private
       * @description Sets the description content in the InLine coachmark. This is a common config for all coachmarks.
       */
    }, {
      key: "_setDescriptionContent",
      value: function _setDescriptionContent() {
        // Create an element for the description and append it to the container.
        if (this.content.enable_description) {
          // Before creating the text element, evaluate the dynamic text if any
          resolveDynamicText(this.description);
          this.textElement = document.createElement("div");
          this.textElement.classList.add("apx-inline-description".concat(this.cssPostFix));
          this.textElement.appendChild(createNewTextElement(this.content.description, this.currentId, "description"));
          this.textContainer.appendChild(this.textElement);
        }
      }

      /**
       * @function _createButtomContainer
       * @private
       * @description Creates the container for the buttons
       */
    }, {
      key: "_createButtonContainer",
      value: function _createButtonContainer() {
        this.buttonContainer = document.createElement("div");
        this.buttonContainer.classList.add("apx-inline-button-container".concat(this.cssPostFix));
        this.nonMediaContainer.appendChild(this.buttonContainer);
      }

      /**
       * @function _setButtons
       * @private
       * @description Generate the Button's and append them to the specified button container.
       *
       */
    }, {
      key: "_setButtons",
      value: function _setButtons() {
        var _this5 = this;
        if (!this.content_enable_buttons) {
          return;
        }
        var actionCallback = function actionCallback(isCancelled) {
          _this5._destroyCoachMark(isCancelled);
        };
        var actionHandler = {
          next: actionCallback,
          prev: actionCallback,
          complete: actionCallback,
          cancel: actionCallback,
          _isCancelled: false,
          action: ""
        };
        var buttons_config = {};
        buttons_config = this.buttons.buttonArray;
        var buttons_positionn = this.buttons.alignment;
        for (var i = 0; i < buttons_config.length; i++) {
          if (buttons_positionn === "L" || buttons_positionn === "left") {
            buttons_config[0].slot = "1";
            if (buttons_config.length === 2) {
              buttons_config[1].slot = "2";
            }
          } else if (buttons_positionn === "C" || buttons_positionn === "center") {
            buttons_config[0].slot = "2";
            if (buttons_config.length === 2) {
              buttons_config[1].slot = "3";
            }
          } else if (buttons_positionn === "R" || buttons_positionn === "right") {
            buttons_config[0].slot = "4";
            if (buttons_config.length === 2) {
              buttons_config[1].slot = "5";
            }
          }
        }
        var Buttons = generateButtonsBlock(this.configId, this.name, {}, EVENT_PREFIX.INLINE, buttons_config, this.buttons.direction, this.buttons.alignment, "bottom", actionHandler, false, [], 0);
        this.buttonContainer.appendChild(Buttons);
      }

      /**
       * @function _createMediaContainer
       * @private
       * @description Creates the container for the image/icon/vedio
       */
    }, {
      key: "_createMediaContainer",
      value: function _createMediaContainer() {
        var _this$image14, _this$image15, _this$image16, _this$image17;
        this.mediaContainer = document.createElement("div");
        this.mediaContainer.classList.add("apx-inline-media-container".concat(this.cssPostFix));
        this.mediaContainer.style.position = "relative";
        this.mediaContainer.style.left = "".concat((_this$image14 = this.image) === null || _this$image14 === void 0 ? void 0 : _this$image14.offset.x, "px");
        this.mediaContainer.style.top = "".concat((_this$image15 = this.image) === null || _this$image15 === void 0 ? void 0 : _this$image15.offset.y, "px");
        if (((_this$image16 = this.image) === null || _this$image16 === void 0 ? void 0 : _this$image16.position) === "L") {
          this.imageAndContentContainerLeft.appendChild(this.mediaContainer);
        } else if (((_this$image17 = this.image) === null || _this$image17 === void 0 ? void 0 : _this$image17.position) === "R") {
          this.imageAndContentContainerRight.appendChild(this.mediaContainer);
        } else {
          this.inLineContainer.appendChild(this.mediaContainer);
        }
      }

      /**
       * @function _setImageOptions
       * @private
       * @description Sets the image-only styles on the container. This is a specific config not applicable for all coachmarks.
       */
    }, {
      key: "_setImageOptions",
      value: function _setImageOptions() {
        if (this.enable_image) {
          var _this$image18;
          var imgElement = document.createElement("img");
          imgElement.src = (_this$image18 = this.image) === null || _this$image18 === void 0 ? void 0 : _this$image18.path;
          imgElement.classList.add("apx-inline-image".concat(this.cssPostFix));
          this.mediaContainer.appendChild(imgElement);
        }
      }
    }, {
      key: "_getSVG",
      value: function _getSVG(maskChild, svgChild) {
        return "\n  <svg\n    height=\"".concat(document.scrollingElement.scrollHeight, "\" \n    width=\"").concat(document.scrollingElement.scrollWidth, "\"\n    class=\"apx-fade-in\">\n    <defs>\n      <mask\n        id=\"apx-mask\"\n        x=\"0\"\n        y=\"0\"\n        height=\"").concat(document.scrollingElement.scrollHeight, "\" \n        width=\"").concat(document.scrollingElement.scrollWidth, "\">\n        ").concat(maskChild, "\n      </mask>\n    </defs>\n    ").concat(svgChild, "\n  </svg>\n  ");
      }
    }, {
      key: "_getCircleSVG",
      value: function _getCircleSVG(data) {
        var backgroundd_color = data.backgroundd_color,
          opacityy = data.opacityy,
          innerRadius = data.innerRadius,
          innerCenterX = data.innerCenterX,
          innerCenterY = data.innerCenterY,
          outerRadius = data.outerRadius,
          outerCircleCenterX = data.outerCircleCenterX,
          outerCircleCenterY = data.outerCircleCenterY;
          data.delta_circle;
          data.background_delta_circle;
          var outer_x = data.outer_x,
          outer_y = data.outer_y,
          targetElementLeft = data.targetElementLeft,
          targetElementTop = data.targetElementTop,
          targetElementWidth = data.targetElementWidth,
          targetElementHeight = data.targetElementHeight,
          innerrect_left = data.innerrect_left,
          innerrect_right = data.innerrect_right,
          innerrect_x = data.innerrect_x,
          innerrect_y = data.innerrect_y;
        outerCircleCenterX = outerCircleCenterX + outer_x;
        outerCircleCenterY = outerCircleCenterY + outer_y;
        var finalOuterRadius = 2 * outerRadius;
        if (this.highlighter.shape === "rectangle") {
          targetElementWidth = targetElementWidth + innerrect_left + innerrect_right;
          targetElementHeight = targetElementHeight + innerrect_x + innerrect_y;
          targetElementLeft = targetElementLeft - innerrect_left;
          targetElementTop = targetElementTop - innerrect_x;
          this.maskChild = "\n  <rect\n    x=\"0\" y=\"0\"\n    height=\"".concat(document.scrollingElement.scrollHeight, "\" \n    width=\"").concat(document.scrollingElement.scrollWidth, "\" \n    fill=\"#fff\" />\n  <rect\n    x=\"").concat(targetElementLeft, "\" \n    y=\"").concat(targetElementTop, "\" \n    width=\"").concat(targetElementWidth, "\" \n    height=\"").concat(targetElementHeight, "\" />\n  ");
        } else {
          this.maskChild = "\n  <rect\n    x=\"".concat(outerCircleCenterX - outerRadius, "\"\n    y=\"").concat(outerCircleCenterY - outerRadius < 0 ? 0 : outerCircleCenterY - outerRadius, "\"\n    height=\"").concat(finalOuterRadius, "\"\n    width=\"").concat(finalOuterRadius, "\"\n    fill=\"#fff\" />\n  <circle\n    cx=\"").concat(innerCenterX, "\"\n    cy=\"").concat(innerCenterY, "\"\n    r=\"").concat(innerRadius, "\" />\n  ");
        }
        var svgChild = "\n  <circle\n    cx=\"".concat(outerCircleCenterX, "\" \n    cy=\"").concat(outerCircleCenterY, "\" \n    r=\"").concat(outerRadius, "\" \n    fill=\"").concat(backgroundd_color, "\" \n    fill-opacity=\"").concat(opacityy, "\" \n    mask=\"url(#apx-mask)\" />\n  ");
        return this._getSVG(this.maskChild, svgChild);
      }
    }, {
      key: "_getRectangleSVG",
      value: function _getRectangleSVG(data) {
        var backgroundd_color = data.backgroundd_color,
          opacityy = data.opacityy,
          targetElementLeft = data.targetElementLeft,
          targetElementTop = data.targetElementTop,
          targetElementWidth = data.targetElementWidth,
          targetElementHeight = data.targetElementHeight,
          innerrect_x = data.innerrect_x,
          innerrect_y = data.innerrect_y,
          innerrect_left = data.innerrect_left,
          innerrect_right = data.innerrect_right,
          outerrect_decrease_left = data.outerrect_decrease_left,
          outerrect_decrease_right = data.outerrect_decrease_right,
          outerrect_decrease_top = data.outerrect_decrease_top,
          outerrect_decrease_bottom = data.outerrect_decrease_bottom,
          innerCenterX = data.innerCenterX,
          innerCenterY = data.innerCenterY,
          innerRadius = data.innerRadius,
          outer_x = data.outer_x,
          outer_y = data.outer_y;
        targetElementWidth = targetElementWidth + innerrect_left + innerrect_right;
        targetElementHeight = targetElementHeight + innerrect_x + innerrect_y;
        targetElementLeft = targetElementLeft - innerrect_left;
        targetElementTop = targetElementTop - innerrect_x;
        var modified_rect_height = document.scrollingElement.scrollHeight + outerrect_decrease_top + outerrect_decrease_bottom;
        var modified_rect_width = document.scrollingElement.scrollWidth + outerrect_decrease_left + outerrect_decrease_right;
        if (this.highlighter.shape === "circle") {
          var _ss = -outerrect_decrease_left + outer_x;
          var _pp = -outerrect_decrease_top + outer_y;
          this.maskChild = "\n  <rect\n   x=\"".concat(_ss, "\" y=\"").concat(_pp, "\"\n    height=\"").concat(modified_rect_height, "\" \n    width=\"").concat(modified_rect_width, "\" \n    fill=\"#fff\" />\n  <circle\n    cx=\"").concat(innerCenterX, "\"\n    cy=\"").concat(innerCenterY, "\"\n    r=\"").concat(innerRadius, "\" />\n  ");
        } else {
          this.maskChild = "\n  <rect\n    x=\"0\" y=\"0\"\n    height=\"".concat(document.scrollingElement.scrollHeight, "\" \n    width=\"").concat(document.scrollingElement.scrollWidth, "\" \n    fill=\"#fff\" />\n  <rect\n    x=\"").concat(targetElementLeft, "\" \n    y=\"").concat(targetElementTop, "\" \n    width=\"").concat(targetElementWidth, "\" \n    height=\"").concat(targetElementHeight, "\" />\n  ");
        }
        var ss = -outerrect_decrease_left + outer_x;
        var pp = -outerrect_decrease_top + outer_y;
        var svgChild = "\n  <rect\n    x=\"".concat(ss, "\" y=\"").concat(pp, "\"\n    height=\"").concat(modified_rect_height, "\" \n    width=\"").concat(modified_rect_width, "\" \n    mask=\"url(#apx-mask)\"\n    fill=\"").concat(backgroundd_color, "\" \n    fill-opacity=\"").concat(opacityy, "\" />\n  ");
        return this._getSVG(this.maskChild, svgChild);
      }
    }, {
      key: "_createSVGDiv",
      value: function _createSVGDiv(data) {
        var opacity = data.opacity;
        this.svgElement = document.createElement("div");
        this.svgElement.setAttribute("id", this.currentId + "-svg");
        this.svgElement.style.position = "absolute";
        this.svgElement.style.left = 0;
        this.svgElement.style.top = 0;
        this.svgElement.style.zIndex = 99998;
        this.svgElement.style.width = "100%";
        this.svgElement.style.height = "99%";
        var svg = "";
        if (this.background.shape === "circle") {
          svg = this._getCircleSVG(data);
        } else {
          svg = this._getRectangleSVG(data);
        }
        this.svgElement.innerHTML = "\n  <style>\n    @keyframes apx-anim {\n      from {\n        opacity: 0;\n      }\n\n      to {\n        opacity: ".concat(opacity, ";\n      }\n    }\n    .apx-fade-in {\n      animation: apx-anim 0.4s linear;\n    }\n  </style>\n  ").concat(svg);
        document.body.appendChild(this.svgElement);
        return this.svgElement;
      }
      /**
       * @function _setObservors
       * @private
       * @description Sets the obervors for identifying target deletion and target going out of view port.
       * In both these cases, coachmark needs to be destroyed.
       */
    }, {
      key: "_setObservors",
      value: function _setObservors() {
        var _this6 = this;
        // Add MutationObserver to the target element
        this.targetDeletionObserver = new MutationObserver(function () {
          if (!_this6.coachmarkShown) {
            return;
          }
          if (!document.body.contains(_this6.targetElement)) {
            _this6._destroyCoachMark();
          }
        });
        this.viewPortObservor = new IntersectionObserver(function () {
          if (!_this6.coachmarkShown) {
            return;
          }
          var elementInViewPort = isElementInViewport(_this6.targetElement);
          if (!elementInViewPort) {
            _this6._destroyCoachMark();
          }
        });
      }
    }, {
      key: "_createOuterCircle",
      value: function _createOuterCircle(element) {
        var _this7 = this;
        this.coachmarkShown = true;
        var rect = this._getDocumentOffsetPosition(element);
        var _rect$left = rect.left,
          targetElementLeft = _rect$left === void 0 ? 0 : _rect$left,
          _rect$top = rect.top,
          targetElementTop = _rect$top === void 0 ? 0 : _rect$top,
          _rect$width = rect.width,
          targetElementWidth = _rect$width === void 0 ? 0 : _rect$width,
          _rect$height = rect.height,
          targetElementHeight = _rect$height === void 0 ? 0 : _rect$height;
        var isFirstHalf = rect.left < window.innerWidth / 2;
        if (targetElementHeight === 0 || targetElementWidth === 0) {
          var _this$target6;
          console.warn("Can't show on an invisible element: ", (_this$target6 = this.target) === null || _this$target6 === void 0 ? void 0 : _this$target6.id);
          return;
        }
        this.textElement = this._setInLineContent();
        var textElemOffsetWidth = this.textElement.offsetWidth;
        var textElemOffsetHeight = this.textElement.offsetHeight;
        var textelementrect = this.textElement.getBoundingClientRect();
        this.textElement.left = textelementrect.left + this.content.offset.x;
        this.textElement.top = textelementrect.top + this.content.offset.y;
        var marginLeft = 0;
        var marginRight = 0;
        // if (this.content.margin) {
        //   marginLeft = Number(this.content.margin.left) || 0;
        //   marginRight = Number(this.content.margin.right) || 0;
        // }
        var ripple_width = this.ripple.width;
        var ripple_duration = this.ripple.duration;
        this.transparentCircleElement = this._createInnerCircle(targetElementWidth, targetElementHeight, targetElementLeft, targetElementTop, this.highlighter.shape, this.highlighter.border.color, this.highlighter.border.width, this.highlighter.border.style, this.highlighter.border.radius, this.highlighter.delta_circle, this.highlighter.delta_rect.top, this.highlighter.delta_rect.bottom, this.highlighter.delta_rect.left, this.highlighter.delta_rect.right, ripple_width, ripple_duration);
        var innerCenterX = targetElementLeft + targetElementWidth / 2;
        var innerCenterY = targetElementTop + targetElementHeight / 2;
        var innerRadius = Math.sqrt(Math.pow(targetElementWidth, 2) + Math.pow(targetElementHeight, 2)) / 2;
        innerRadius = innerRadius + this.highlighter.delta_circle / 2;
        var targetElementdiagonal = Math.sqrt(Math.pow(textElemOffsetWidth, 2) + Math.pow(textElemOffsetHeight, 2));
        var outerRadius = innerRadius + this.highlighter.delta_circle + targetElementdiagonal + this.highlighter.border.width;
        outerRadius = outerRadius + this.background.delta_circle;
        var text_ele_x = this.content.offset.x;
        var text_ele_y = this.content.offset.y;
        var textElementOffsetTop = -1;
        var textElementOffsetLeft = -1;
        var left = -1;
        var top = -1;
        var outerCircleCenterY = -1;
        //textElementOffsetLeft = textElementOffsetLeft + text_ele_x;
        //textElementOffsetTop = textElementOffsetTop + text_ele_y;

        outerCircleCenterY = innerCenterY;
        switch (this.content.position) {
          case "T":
            left = innerCenterX - textElemOffsetWidth / 2;
            textElementOffsetLeft = left < 0 ? DEFAULT_PADDING : left;
            if (this.highlighter.shape === "circle") {
              textElementOffsetTop = innerCenterY - innerRadius - textElemOffsetHeight - this.highlighter.border.width - this.content.margin.bottom;
            } else {
              textElementOffsetTop = targetElementTop - textElemOffsetHeight - this.highlighter.delta_rect.top - this.highlighter.border.width - this.content.margin.bottom;
            }
            //outerCircleCenterY = innerCenterY + this.background.delta_circle;
            // outerCircleCenterY =
            //   innerCircleBottom -
            //   Math.abs(innerCircleBottom - textElementOffsetTop) / 2;
            break;
          case "L":
            // Calculate the top position of the text element
            top = innerCenterY - textElemOffsetHeight / 2;
            textElementOffsetTop = top < 0 ? DEFAULT_PADDING : top;
            if (this.highlighter.shape === "circle") {
              textElementOffsetLeft = innerCenterX - innerRadius - textElemOffsetWidth - this.highlighter.border.width - this.content.margin.right;
            } else {
              textElementOffsetLeft = targetElementLeft - textElemOffsetWidth - this.highlighter.delta_rect.left - this.highlighter.border.width - this.content.margin.right;
            }
            // outerCircleCenterY =
            //   innerCircleTop + Math.abs(innerCircleTop - textElementOffsetTop) / 2;
            break;
          case "R":
            // Calculate the top position of the text element
            top = innerCenterY - textElemOffsetHeight / 2;
            textElementOffsetTop = top < 0 ? DEFAULT_PADDING : top;
            if (this.highlighter.shape === "circle") {
              textElementOffsetLeft = innerCenterX + innerRadius + this.highlighter.border.width + this.content.margin.left;
            } else {
              textElementOffsetLeft = targetElementWidth + this.highlighter.border.width + this.content.margin.left + this.highlighter.delta_rect.right;
            }
            // outerCircleCenterY =
            //   innerCircleTop + Math.abs(innerCircleTop - textElementOffsetTop) / 2;
            break;
          case "B":
            left = innerCenterX - textElemOffsetWidth / 2;
            textElementOffsetLeft = left < 0 ? DEFAULT_PADDING : left;
            if (this.highlighter.shape === "circle") {
              textElementOffsetTop = innerCenterY + innerRadius + this.highlighter.border.width + this.content.margin.top;
            } else {
              textElementOffsetTop = targetElementTop + targetElementHeight + this.highlighter.delta_rect.bottom + this.highlighter.border.width + this.content.margin.top;
            }
            // outerCircleCenterY =
            //   innerCircleTop +
            //   (textElementOffsetTop + textElemOffsetHeight - innerCircleTop) / 2;
            break;
        }
        if (textElementOffsetLeft === -1 || textElementOffsetTop === -1 || outerCircleCenterY === -1) {
          console.warn("Failed to identify the right place for text");
          return;
        }

        // Position Text element
        if (!isFirstHalf && textElementOffsetLeft + textElemOffsetWidth > window.innerWidth) {
          textElementOffsetLeft = window.innerWidth - textElemOffsetWidth - marginLeft - marginRight - 10;
        }
        var ll = textElementOffsetLeft + text_ele_x;
        var tt = textElementOffsetTop + text_ele_y;
        this.textElement.style.left = "".concat(ll, "px");
        this.textElement.style.top = "".concat(tt, "px");

        // Calculate outer circle center X position
        // left = Math.min(targetElementLeft, textElementOffsetLeft);
        // let right = Math.max(
        //   targetElementLeft + targetElementWidth,
        //   textElementOffsetLeft + textElemOffsetWidth
        // );

        var outerCircleCenterX = innerCenterX;
        outerCircleCenterX = Math.min(outerCircleCenterX + this.background.offset.x, document.scrollingElement.scrollWidth);
        if (outerCircleCenterX < 0) {
          outerCircleCenterX = 0;
        }
        outerCircleCenterY = Math.min(outerCircleCenterY + this.background.offset.y, document.scrollingElement.scrollHeight);
        if (outerCircleCenterY < 0) {
          outerCircleCenterY = 0;
        }
        var backgroundd_color = this.background.background_color;
        var opacityy = this.background.opacity;
        var outer_shape = this.background.shape;
        var delta_circle = this.highlighter.delta_circle;
        var background_delta_circle = this.background.delta_circle;
        var innerrect_x = this.highlighter.delta_rect.top;
        var innerrect_y = this.highlighter.delta_rect.bottom;
        var innerrect_left = this.highlighter.delta_rect.left;
        var innerrect_right = this.highlighter.delta_rect.right;
        var outerrect_decrease_left = this.background.delta_rect.left;
        var outerrect_decrease_right = this.background.delta_rect.right;
        var outerrect_decrease_top = this.background.delta_rect.top;
        var outerrect_decrease_bottom = this.background.delta_rect.bottom;
        var outer_x = this.background.offset.x;
        var outer_y = this.background.offset.y;
        this.svgElement = this._createSVGDiv({
          backgroundd_color: backgroundd_color,
          opacityy: opacityy,
          innerRadius: innerRadius,
          innerCenterX: innerCenterX,
          innerCenterY: innerCenterY,
          outerRadius: outerRadius,
          outerCircleCenterX: outerCircleCenterX,
          outerCircleCenterY: outerCircleCenterY,
          targetElementLeft: targetElementLeft,
          targetElementTop: targetElementTop,
          targetElementWidth: targetElementWidth,
          targetElementHeight: targetElementHeight,
          outer_shape: outer_shape,
          delta_circle: delta_circle,
          background_delta_circle: background_delta_circle,
          innerrect_x: innerrect_x,
          innerrect_y: innerrect_y,
          innerrect_left: innerrect_left,
          innerrect_right: innerrect_right,
          outerrect_decrease_left: outerrect_decrease_left,
          outerrect_decrease_right: outerrect_decrease_right,
          outerrect_decrease_top: outerrect_decrease_top,
          outerrect_decrease_bottom: outerrect_decrease_bottom,
          outer_x: outer_x,
          outer_y: outer_y
        });
        this.svgElement.style.visibility = "hidden";
        this.transparentCircleElement.style.visibility = "hidden";
        this.textElement.style.visibility = "hidden";
        var dismissCallback = function dismissCallback(e) {
          var isUserHitTarget = false;
          var autoDismiss = false;
          if (e === undefined) {
            autoDismiss = true;
          }
          var rect = element.getBoundingClientRect();
          if (e !== undefined && e.clientX >= rect.left && e.clientX <= rect.left + rect.width && e.clientY >= rect.top && e.clientY <= rect.top + rect.height) {
            isUserHitTarget = true;
          }
          if (_this7.dismiss_outside_touch || isUserHitTarget || autoDismiss) {
            _this7._destroyCoachMark();
            if (isUserHitTarget && element.click) {
              element.click();
            }
          }
        };
        if (this.terminationConfig && this.terminationConfig.autoDismiss === true) {
          setTimeout(function () {
            return dismissCallback();
          }, this.delay + this.terminationConfig.duration);
        }
        this.svgElement.style.visibility = "visible";
        this.transparentCircleElement.style.visibility = "visible";
        this.textElement.style.visibility = "visible";
        if (this.textElement.childElementCount > 0) {
          this.textElement.children[0].style.visibility = "visible";
        }
        if (this.dismiss_outside_touch) {
          this.svgElement.addEventListener("click", dismissCallback);
        }
        this.transparentCircleElement.addEventListener("click", dismissCallback);
        if (this.scrollToView) {
          if (this.content.position === "T") {
            window.scrollTo({
              top: outerCircleCenterY + this.background.offset.y - (outerRadius + this.background.delta_circle),
              behavior: "smooth"
            });
          } else if (this.content.position === "B") {
            window.scrollTo({
              top: Math.min(document.scrollingElement.scrollHeight, outerCircleCenterY + this.background.offset.y + outerRadius + this.background.delta_circle),
              behavior: "smooth"
            });
          }
        }

        // Attach the observer upon show
        this.targetDeletionObserver.observe(document.body, {
          childList: true,
          subtree: true
        });
        this.viewPortObservor.observe(element);
        setTimeout(function () {
          //Highlight the target by dimming other elements.
          _this7._highlightInlineTarget();
          _this7._setAutoTerminate();
          _this7.coachmarkShown = true;
        }, 10);
        //   this.coachmarkShown = true;
        // }, 10);
        // if (on_shown) on_shown();

        // return dismissCallback;
      }
      /**
       * @function _setAutoTerminate
       * @private
       * @description If the auto dismiss is enabled, sets the timeout to call the coachmark destroy.
       */
    }, {
      key: "_setAutoTerminate",
      value: function _setAutoTerminate() {
        var _this8 = this;
        if (this.terminationConfig.auto_dismiss === true) {
          this.terminationTimeoutId = setTimeout(function () {
            _this8._destroyCoachMark();
          }, this.terminationConfig.duration);
        }
      }
    }]);
    return InLineCoachMark;
  }();

  var Logger = window.ApxorLogger;
  var RTA = 0;
  var SURVEYS = 1;
  var getURLs = function getURLs(siteId, userId) {
    var replaceFunc = function replaceFunc(url) {
      return url.replace("<app_id>", siteId).replace("<u_id>", userId);
    };
    var rtaValidateUrl = replaceFunc(RTA_VALIDATE_URL);
    var rtaSyncUrl = replaceFunc(RTA_SYNC_URL);
    var surveysValidateUrl = replaceFunc(SURVEY_VALIDATE_URL);
    var surveysSyncUrl = replaceFunc(SURVEY_SYNC_URL);
    var configSSEUrl = replaceFunc(CONFIG_API_URL);
    var testDevicesValidateUrl = replaceFunc(TEST_DEVICES_API_URL);
    return {
      rtaValidateUrl: rtaValidateUrl,
      rtaSyncUrl: rtaSyncUrl,
      surveysValidateUrl: surveysValidateUrl,
      surveysSyncUrl: surveysSyncUrl,
      configSSEUrl: configSSEUrl,
      testDevicesValidateUrl: testDevicesValidateUrl
    };
  };
  var RTM = /*#__PURE__*/function () {
    function RTM() {
      var _this = this;
      _classCallCheck$1(this, RTM);
      _defineProperty$1(this, "version", 180);
      _defineProperty$1(this, "_configs", {});
      _defineProperty$1(this, "isShowingAction", false);
      _defineProperty$1(this, "currentAction", null);
      _defineProperty$1(this, "_currentTooltip", null);
      _defineProperty$1(this, "_currentBadge", null);
      _defineProperty$1(this, "_currentInApp", null);
      _defineProperty$1(this, "_currentVideoPIP", null);
      _defineProperty$1(this, "_currentCoachmark", null);
      _defineProperty$1(this, "_surveys", new ApxorSurveys());
      _defineProperty$1(this, "_newsurveys", new NewSurveys());
      _defineProperty$1(this, "_inApp", new ApxorInApp());
      _defineProperty$1(this, "_wysiwyg", new WYSIWYG());
      _defineProperty$1(this, "_afterPluginInit", null);
      _defineProperty$1(this, "_eventsInDynamicText", {});
      _defineProperty$1(this, "_configSSEUrl", "");
      _defineProperty$1(this, "isWalkthrough", false);
      _defineProperty$1(this, "_handledOneSync", false);
      _defineProperty$1(this, "_calledPluginInitCallback", false);
      _defineProperty$1(this, "uis", []);
      _defineProperty$1(this, "init", function () {
        var afterPluginInit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {};
        _this._afterPluginInit = afterPluginInit;
        var controller = Apxor.getController();
        _this.ceInstance = ceWrapper.getInstance();
        var siteId = Apxor.getSiteId();
        var userId = Apxor.getClientId();
        var _getURLs = getURLs(siteId, userId),
          rtaValidateUrl = _getURLs.rtaValidateUrl,
          rtaSyncUrl = _getURLs.rtaSyncUrl,
          surveysValidateUrl = _getURLs.surveysValidateUrl,
          surveysSyncUrl = _getURLs.surveysSyncUrl,
          configSSEUrl = _getURLs.configSSEUrl,
          testDevicesValidateUrl = _getURLs.testDevicesValidateUrl;

        // Set the config SSE URL, it is used in other methods of the class.
        _this._configSSEUrl = configSSEUrl;
        _this.ceInstance.initialize();

        // Make network request to fetch Configs
        _this.ceInstance.fetch(RTA, rtaValidateUrl, rtaSyncUrl, _this.handleResponse);
        _this.ceInstance.fetch(SURVEYS, surveysValidateUrl, surveysSyncUrl, _this.handleResponse);
        controller.makeGetRequest(testDevicesValidateUrl, _this.initiateTestSSE);
        controller.registerForEvent("IN_LINE", _this.handleInLine);
        controller.registerForEvent("IN_APP", _this.handleInApp);
        controller.registerForEvent("SURVEY", _this.handleSurvey);
        controller.registerForEvent("ONBOARDING", _this.handleOnboarding);
        _this._wysiwyg.init(siteId, _this);
        Logger.debug("Registered for events");
      });
      /**
       * @function previewTemplate
       * @description Show the preview for inlines,inapps and video pips
       * @param {object} config
       * @param {string} id
       * @param {string} type
       */
      _defineProperty$1(this, "previewTemplate", function (config, id, type) {
        //Call the show functions on the respective templates with a default config
        if (type === "new-inline") {
          _this._currentTooltip = new InLineTooltip(config, [], [], {}, {}, _this, function () {}, function () {
            _this.isShowingAction = false;
            _this.currentAction = null;
            _this._currentTooltip = null;
          }, function () {}, false, 0);
          _this._currentTooltip.createNewTooltip();
          _this.currentAction = function () {
            var _this$_currentTooltip;
            (_this$_currentTooltip = _this._currentTooltip) === null || _this$_currentTooltip === void 0 || _this$_currentTooltip._destroyTooltip();
          };
        } else if (type === "coach_mark_v2") {
          _this._currentCoachmark = new InLineCoachMark(config, [], [], {}, {}, _this, function () {}, function () {
            _this.isShowingAction = false;
            _this.currentAction = null;
            _this._currentCoachmark = null;
          }, function () {}, false, 0);
          _this._currentCoachmark.createNewCoachMark();
        } else if (type === IN_APP_TYPE) {
          _this._currentInApp = new ModalInApp(config, {}, id, APX_PREVIEW_CAMPAIGN_NAME, function () {}, function (backgroundDiv, action) {
            var _dialogContent$classL;
            var cssClass = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ".apx-dlg-c";
            var closeListener = arguments.length > 3 ? arguments[3] : undefined;
            var redirectionListener = arguments.length > 4 ? arguments[4] : undefined;
            document.body.removeEventListener("click", closeListener);
            document.body.removeEventListener("click", redirectionListener);
            var dialogContent = document.querySelector(cssClass);
            dialogContent === null || dialogContent === void 0 || (_dialogContent$classL = dialogContent.classList) === null || _dialogContent$classL === void 0 || _dialogContent$classL.toggle("open");
            backgroundDiv === null || backgroundDiv === void 0 || backgroundDiv.remove();
            _this.isShowingAction = false;
            _this.currentAction = null;
            _this._currentInApp = null;
          }, function () {}, false, [], 0);
          _this._currentInApp.createInAppModal();
        } else if (type === "pip") {
          if (VideoInApp.isAVideoBeingPlayed()) {
            return;
          }
          if (!VideoInApp.canShowVideoInApp(config)) {
            return;
          }
          _this._currentVideoPIP = new VideoInApp(config, id, APX_PREVIEW_CAMPAIGN_NAME, function () {}, function () {
            _this.isShowingAction = false;
            _this.currentAction = null;
            _this._currentVideoPIP = null;
          });
          _this._currentVideoPIP.showVideoInApp();
        }
      });
      _defineProperty$1(this, "show", function (uiJson, uis, duration, uuid, name) {
        var index = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
        var isWalkthrough = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;
        try {
          if (name !== APX_PREVIEW_CAMPAIGN_NAME && _this.getFrequencyCount(uuid) <= 0) {
            Logger.error("Campaign limit reached");
            return;
          }
          if (_this.currentAction !== null && _this.currentAction !== undefined) {
            Logger.error("An action already being shown");
            return;
          }
          var ui_config = JSON.parse(uiJson);
          var terminationConfig = {};
          terminationConfig["auto_dismiss"] = duration > 0;
          terminationConfig["duration"] = duration;
          var on_show = function on_show() {
            _this.logActionEvent("inline_shown", uuid, name);
            if (name !== APX_PREVIEW_CAMPAIGN_NAME) {
              // onShown callback
              _this.updateCount(uuid);
            }
            _this.isShowingAction = true;
            if (isWalkthrough) {
              _this.currentAction = null;
            }
          };
          var on_hide = function on_hide() {
            var isCancelled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
            // onHidden callback
            _this.isShowingAction = false;
            _this.currentAction = null;
            _this._currentTooltip = null;
            _this._currentBadge = null;
            _this._currentCoachmark = null;
            if (!isCancelled) _this.logActionEvent("inline_dismissed", uuid, name);else _this.logActionEvent("walkthrough_cancelled", uuid, name);
          };
          var display_type = ui_config.display_type;
          var campaignConfig = {
            configId: uuid,
            configName: name
          };
          if (display_type === "new-inline") {
            _this._currentTooltip = new InLineTooltip(ui_config, uis, [], terminationConfig, campaignConfig, _this, on_show, on_hide, _this.stepperCallback, isWalkthrough, index);
            _this._currentTooltip.createNewTooltip();
          } else if (display_type === "inline") {
            showTooltip(ui_config, [], terminationConfig, campaignConfig, _this, on_show, on_hide);
          } else if (display_type === "passive_nudge" || display_type === "badge") {
            if (name === APX_PREVIEW_CAMPAIGN_NAME) {
              var badgeList = document.getElementsByClassName("apxor-badge-container");
              while (badgeList.length > 0) badgeList[0].remove();
            }
            _this._currentBadge = new ApxorBadge(ui_config, _this._configs[uuid].terminationConfig, campaignConfig, _this);
            _this._currentBadge.createBadge();
          } else if (display_type === "coach_mark") {
            showCoachmarkWithDelay(ui_config, campaignConfig, terminationConfig, on_show, on_hide, function (callback) {
              _this.currentAction = callback;
            });
          } else if (display_type === "coach_mark_v2") {
            _this._currentCoachmark = new InLineCoachMark(ui_config, uis, [], terminationConfig, campaignConfig, _this, on_show, on_hide, _this.stepperCallback, isWalkthrough, index);
            _this._currentCoachmark.createNewCoachMark();
          } else {
            Logger.error("Unknown type", display_type);
          }
        } catch (e) {
          _this.currentAction = null;
          _this._currentTooltip = null;
          _this._currentBadge = null;
          _this._currentCoachmark = null;
          _this.isShowingAction = false;
          window.ApxorLogger.error(e);
        }
      });
      _defineProperty$1(this, "logActionEvent", function (name, uuid, configName) {
        var meta = _this.getCampaignMeta(uuid);
        var attrs = (meta === null || meta === void 0 ? void 0 : meta._attr) || {};
        Apxor.logEvent(name, _objectSpread2$1({
          id: uuid,
          message_name: configName
        }, attrs));
      });
      _defineProperty$1(this, "logClientEvent", function (name, additional_info) {
        Apxor.logClientEvent(name, additional_info);
      });
      _defineProperty$1(this, "updateCount", function (configId) {
        _this.ceInstance.updateCount(configId);
      });
      _defineProperty$1(this, "getFrequencyCount", function (configId) {
        _this.ceInstance.getFrequencyCount(configId);
      });
      _defineProperty$1(this, "resetFrequencyCounts", function () {
        _this.ceInstance.resetFrequencyCounts();
      });
      _defineProperty$1(this, "removeAll", function () {
        if (_this.currentAction !== null && _this.currentAction !== undefined) {
          _this.isShowingAction = false;
          try {
            _this.currentAction();
          } catch (e) {
            Logger.error("RTM : Failed to remove all RTM actions");
          } finally {
            _this.currentAction = null;
          }
        }
      });
      _defineProperty$1(this, "handleResponse", function (type, configs) {
        if (type === "") {
          Logger.debug("RTM : No configs available");
          _this._afterPluginInit();
        } else {
          Logger.debug("RTM : Fetched configs ".concat(configs, " for type-").concat(type === SURVEYS ? "Surveys" : "RTA"));
          _this._storeConfigs(type, configs);
          _this.ceInstance.parse(configs);
          if (_this._handledOneSync) {
            _this._calledPluginInitCallback = true;
            _this._afterPluginInit();
          }
          _this._handledOneSync = true;
          setTimeout(function () {
            if (!_this._calledPluginInitCallback) {
              _this._afterPluginInit();
            }
          }, 1500);
        }
      });
      _defineProperty$1(this, "handleSSEResponse", function (type, configs) {
        Logger.debug("RTM : Fetched config from SSE");
        if (configs && configs.length > 0) {
          _this._storeConfigs(type, {
            configs: configs
          });
          _this.ceInstance.parse({
            configs: configs
          });
        }
      });
      /**
       * @function initiateTestSSE
       * @description Initiates a new SSE connection to listen to the art config. This is used in case of a preview for A/B.
       */
      _defineProperty$1(this, "initiateTestSSE", function (response) {
        var _response$data;
        if ((response === null || response === void 0 || (_response$data = response.data) === null || _response$data === void 0 ? void 0 : _response$data.is_test_device) === true) {
          var artConfigEventSource = new EventSource(_this._configSSEUrl);
          artConfigEventSource.onmessage = function (e) {
            try {
              if (e && e.data && e.data !== "{}") {
                if (e !== null && e !== void 0 && e.data) {
                  var configs = JSON.parse(e === null || e === void 0 ? void 0 : e.data);
                  _this.handleSSEResponse(RTA, configs.messages);
                }
              }
            } catch (e) {
              Logger.error("SSE art-config parsing error:", e);
            }
          };
        }
      });
      _defineProperty$1(this, "_storeConfigs", function (type, config) {
        var controller = Apxor.getController();
        if (isDefined(config) && isDefined(config.configs)) {
          var configs = config.configs;
          if (!Array.isArray(configs)) {
            return;
          }
          for (var index = 0; index < configs.length; index++) {
            var _config = configs[index];
            var configId = _config._id,
              _config$meta = _config.meta,
              name = _config$meta.name,
              configType = _config$meta.type;
            var terminationCheck = JSON.parse(controller.getFromStorage(APX_TERMINATION_ID));
            if (terminationCheck !== null) {
              if (terminationCheck !== null && terminationCheck !== void 0 && terminationCheck[configId] && terminationCheck[configId].goalAcheived) {
                continue;
              }
            }
            var ui = _config.ui;
            if (type === SURVEYS) {
              if (_config !== null && _config !== void 0 && _config.surveyType && _config.surveyType.toLowerCase() === "latest") {
                _config.ui.version = "v2";
              } else {
                ui = _this._surveys.parse(configId, name, ui);
              }
            } else if (configType === IN_APP_TYPE) {
              ui = _this._inApp.parse(configId, name, ui);
            } else if (configType === "ONBOARDING") {
              _this.isWalkthrough = true;
              _this.uis = _config.uis;
              ui = _config.uis[0].type === "IN_LINE" ? _config.uis[0] : _this._inApp.parse(configId, name, _this.uis[0], _this.uis, 0, _this.stepperCallback, _this.isWalkthrough);
            }
            if (ui === null) {
              // Failed to parse the JSON
              console.warn("Failed to parse the config", configId);
              continue;
            }
            _this._configs[configId] = {
              ui: ui,
              uis: _config.uis,
              terminationConfig: _config["terminate_info"],
              name: name,
              isWalkthrough: _this.isWalkthrough
            };
          }
          Logger.debug("Configs: ", _this._configs);
        }
      });
      _defineProperty$1(this, "handleInLine", function (event) {
        if (isDefined(event.additional_info)) {
          var _this$_configs$config;
          var configId = event.additional_info.uuid;
          if ((_this$_configs$config = _this._configs[configId]) !== null && _this$_configs$config !== void 0 && _this$_configs$config.terminationConfig) {
            var _terminationCheck$con;
            var controller = Apxor.getController();
            controller.persistStartDateInfoLocally(configId);
            var terminationCheck = JSON.parse(controller.getFromStorage(APX_TERMINATION_ID));
            if (terminationCheck !== null && terminationCheck[configId] !== undefined && (_terminationCheck$con = terminationCheck[configId]) !== null && _terminationCheck$con !== void 0 && _terminationCheck$con.goalAcheived) {
              return;
            }
          }
          if (_this._configs[configId]) {
            var _this$_configs$config2 = _this._configs[configId],
              ui = _this$_configs$config2.ui,
              terminationConfig = _this$_configs$config2.terminationConfig,
              name = _this$_configs$config2.name;
            _this.show(JSON.stringify(ui), _this.uis, terminationConfig.auto_dismiss ? terminationConfig.duration : -1, configId, name);
          }
        }
      });
      _defineProperty$1(this, "handleInApp", function (event) {
        if (isDefined(event.additional_info)) {
          var configId = event.additional_info.uuid;
          if (_this._configs[configId]) {
            var terminationConfig = _this._configs[configId].terminationConfig;
            var inAppConfigItem = _this._configs[configId].ui;
            setTimeout(function () {
              inAppConfigItem.showInApp(configId, terminationConfig);
            }, 0);
          }
        }
      });
      _defineProperty$1(this, "handleSurvey", function (event) {
        if (isDefined(event.additional_info)) {
          var _this$_configs$config3;
          var configId = event.additional_info.uuid;
          if ((_this$_configs$config3 = _this._configs[configId]) !== null && _this$_configs$config3 !== void 0 && _this$_configs$config3.terminationConfig && _this._configs[configId].terminationConfig.enable_goal_events) {
            var controller = Apxor.getController();
            controller.persistStartDateInfoLocally(configId);
            var terminationCheck = JSON.parse(controller.getFromStorage(APX_TERMINATION_ID));
            if (terminationCheck !== null && terminationCheck[configId] !== undefined && terminationCheck[configId].goalAcheived) {
              return;
            }
          }
          if (_this._configs[configId]) {
            var _surveyConfigItem$ver;
            var surveyConfigItem = _this._configs[configId].ui;
            // onShown callback //
            var onShown = function onShown(currentActionCallback) {
              _this.updateCount(configId);
              _this.isShowingAction = true;
              _this.currentAction = currentActionCallback;
            };

            // onDismiss callback //
            var onDismiss = function onDismiss() {
              _this.isShowingAction = false;
              _this.currentAction = null;
            };
            if (((_surveyConfigItem$ver = surveyConfigItem.version) === null || _surveyConfigItem$ver === void 0 ? void 0 : _surveyConfigItem$ver.toLowerCase()) === "v2") {
              var survey_obj = new NewSurveys(configId, _this.name, surveyConfigItem, _this.uis, _this, onShown, onDismiss);
              setTimeout(function () {
                survey_obj.showNewSurvey();
              }, surveyConfigItem.delay || 0);
            } else {
              surveyConfigItem.showSurvey(onShown, onDismiss);
            }
          }
        }
      });
      _defineProperty$1(this, "handleOnboarding", function (event) {
        if (isDefined(event.additional_info)) {
          var configId = event.additional_info.uuid;
          if (_this._configs[configId]) {
            _this.ui = _this._configs[configId].ui;
            _this.uis = _this._configs[configId].uis;
            _this.terminationConfig = _this._configs[configId].terminationConfig;
            _this.name = _this._configs[configId].name;
            _this.isWalkthrough = _this._configs[configId].isWalkthrough;
            if (_this.ui.type === "IN_LINE") {
              _this.show(JSON.stringify(_this.ui), _this.uis, _this.terminationConfig.auto_dismiss ? _this.terminationConfig.duration : -1, configId, _this.name, 0, _this.isWalkthrough);
            } else {
              var inAppConfigItem = _this.ui;
              setTimeout(function () {
                inAppConfigItem.showInApp(configId, _this.terminationConfig);
              }, 0);
            }
          }
        }
      });
      /**
       * @function stepperCallback
       * @description this callback function for call the next campaign,it will use only for onBoarding campaigns.
       */
      _defineProperty$1(this, "stepperCallback", function (configId, index) {
        if (_this._configs[configId]) {
          var _this$uis$index;
          _this.uis = _this._configs[configId].uis;
          _this.terminationConfig = _this._configs[configId].terminationConfig;
          _this.name = _this._configs[configId].name;
          _this.isWalkthrough = _this._configs[configId].isWalkthrough;
          _this.ui = ((_this$uis$index = _this.uis[index]) === null || _this$uis$index === void 0 ? void 0 : _this$uis$index.type) === "IN_LINE" ? _this.uis[index] : _this._inApp.parse(configId, _this.name, _this.uis[index], _this.uis, index, _this.stepperCallback, _this.isWalkthrough);
          if (_this.ui.type === "IN_LINE") {
            _this.show(JSON.stringify(_this.ui), _this.uis, _this.terminationConfig.auto_dismiss ? _this.terminationConfig.duration : -1, configId, _this.name, index, _this.isWalkthrough);
          } else {
            var inAppConfigItem = _this.ui;
            setTimeout(function () {
              inAppConfigItem.showInApp(configId, _this.terminationConfig);
            }, 0);
          }
        }
      });
      _defineProperty$1(this, "getCampaignMeta", function (campaignId) {
        var _this$ceInstance;
        return (_this$ceInstance = _this.ceInstance) === null || _this$ceInstance === void 0 ? void 0 : _this$ceInstance.getCampaignMetaFromQueryEngine(campaignId);
      });
      _defineProperty$1(this, "validateForTerminationAttributes", function (campaignId) {
        var _this$ceInstance2;
        return (_this$ceInstance2 = _this.ceInstance) === null || _this$ceInstance2 === void 0 ? void 0 : _this$ceInstance2.validateForTerminationAttributes(campaignId);
      });
    }
    _createClass$1(RTM, [{
      key: "notifyScroll",
      value:
      /**
       * @function notifyScroll
       * @description removes nudge when user scrolls when it is being displayed(i.e when it's isShowingAction value is true )
       */
      function notifyScroll() {
        if (this.isShowingAction) {
          this.removeAll();
        }
      }
    }]);
    return RTM;
  }();

  var rtm = new RTM();
  window.ApxorRTM = rtm;
  var CEWrapper = /*#__PURE__*/function () {
    function CEWrapper() {
      _classCallCheck$1(this, CEWrapper);
    }
    _createClass$1(CEWrapper, [{
      key: "getInstance",
      value: function getInstance() {
        return (CE || window["apxor-qe"]).getInstance();
      }
    }]);
    return CEWrapper;
  }();
  var ceWrapper = new CEWrapper();
  try {
    if (exports !== undefined || exports !== null) {
      exports["default"] = rtm;
      module.exports = exports["default"];
    }
  } catch (e) {}

  exports.ceWrapper = ceWrapper;
  exports.default = rtm;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
